###* @jsx React.DOM ###

###* Зависимости: модули
* StylesMixin           - общие стили для компонентов.
* HelpersMixin          - функции-хэлперы для компонентов.
* BehaviorsMixin        - модуль функция поведения компонентов.
* HierarchyMixin        - модуль для задания иерархии компонентов.
* AnimationsMixin       - набор анимаций для компонентов.
* AnimateMixin          - библиотека добавляющая компонентам.
*                         возможность исользования анимации.
* MoneyFormatterMixin   - модуль для форматирования денежного значения.
* ImplementedPropReader - модуль добавляющий функционал корректного считывания
*                         реализуемых свойств (через хранилище реализаций).
* ServiceStore          - flux-хранилище состояний сервисной части.
* ServiceActionCreators - модуль создания клиентских сервисной действий.
* ServiceFluxConstants  - flux-константы сервисной части.
* keymirror             - модуль для генерации "зеркального" хэша.
* string-template       - модуль для форматирования строк.
* loglevel              - модуль для вывода формитированных логов в отладчик.
* pluralize             - модуль для перевода слов во множественную/единственную форму(англ.).
* lodash                - модуль служебных операций.
###
StylesMixin = require('../mixins/styles')
HelpersMixin = require('../mixins/helpers')
BehaviorsMixin = require('../mixins/behaviors')
HierarchyMixin = require('../mixins/hierarchy_components')
AnimationsMixin = require('../mixins/animations')
AnimateMixin = require('react-animate')
MoneyFormatterMixin = require('../mixins/money_formatter')
ImplementedPropReader = require('../mixins/implemented_prop_reader')
ServiceStore = require('stores/service_store')
ServiceActionCreators = require('actions/service_action_creators')
ServiceFluxConstants = require('constants/service_flux_constants')
keyMirror = require('keymirror')
format = require('string-template')
log = require('loglevel')
pluralize = require('pluralize')
_ = require('lodash')
PureRenderMixin = React.addons.PureRenderMixin


###* Зависимости: компоненты
* Button            - кнопка.
* ButtonGroup       - набор кнопок.
* DropDown          - выпадающий список.
* Input             - поле ввода.
* FormInput         - поле ввода для форм.
* DynamicForm       - компонент динамической формы ввода.
* Dialog            - диалоговое окно.
* AllocationContent - контент с выделением по переданному выражению.
* PageSelector      - выбор страницы.
* PopupFlasher      - всплывающее уведомление.
* StaticForm        - компонент статической формы.
* AjaxLoader        - индикатор загрузки.
* ObjectCard        - карточка объекта.
* ArbitraryArea     - произвольная область.
###
Button = require('components/core/button')
ButtonGroup = require('components/core/button_group')
DropDown = require('components/core/dropdown')
Input = require('components/core/input')
FormInput = require('components/core/form_input')
DynamicForm = require('components/core/dynamic_form')
StaticForm = require('components/core/static_form')
AjaxLoader = require('components/core/ajax_loader')
AllocationContent = require('components/core/allocation_content')
PageSelector = require('components/core/page_selector')
Dialog = require('components/core/dialog')
DialogInteraction = require('components/core/dialog_interaction')
PopupFlasher = require('components/core/popup_flasher')
ObjectCard = require('components/core/object_card')
ArbitraryArea = require('components/core/arbitrary_area')
BreadNavigator = require('components/core/bread_navigator')
Taber = require('components/core/taber')

###* Константы
* _COLORS         - цвета
* _COMMON_PADDING - значение отступа
###
constants = StylesMixin.constants
_COLORS = constants.color
_COMMON_PADDING = _CP = StylesMixin.constants.commonPadding
_COMMON_BORDER_RADIUS = StylesMixin.constants.commonBorderRadius

###* Компонент: Таблица данных
* @props :
*     {Number} recordsPerPage       - кол-во записей на странице.
*     {Number} startPage            - номер стартовой страницы.
*     {String} recordsNotFoundText - надпись выводимая при отсутствии записей.
*     {String} searchPlaceholder    - строка-приглашения ввода строки поиска.
*     {Number, String} instanceID   - идентификатор экземпляра объекта для которого
*                                     создается таблица. Параметр нужен для передачи
*                                     данного параметра в запросы в БЛ, если таблица
*                                     построена по контретной записи модели.
*     {Object} modelParams          - Параметры модели для которой сформирована таблица.
*                                     Вид:
*                    {String} name - имя модели с которой работаем (для создания
*                                    корректных форм работы с данными).
*                    {String} view - имя модели представления базы данных с которой
*                                    работает контроллер ресурса.
*                                    Параметр необходим для корректного построения фильтров
*                                    при работе с ресурсами, построенных на базе представлений.
*             {String} subResource - адрес вложенного ресурса. Данный параметр нужен
*                                    для запроса подмножества из множества, пердставленного
*                                    параметром модели. Если данный параметр задан
*                                    запрос данных будет направляться по адресу:
*                                    /[resourceAddress]/[subResource].json (при использовании
*                                    сервисной инфраструктуры flux).
*                 {String} caption - название модели (локализованное название).
*        {Array<Object>} relations - массив параметров связанных сущностей. Если задан данный
*                                    параметр, то данные параметры будут переданы в API
*                                    для получения записей не модели заданной через параметр
*                                    @props.modelParams.name, а записей последней связки в наборе.
*                                    Для работы с данным параметром должен быть задан
*                                    параметр @props.instanceID, задающий экземпляр, по которой
*                                    будут отбираться связанные записи. Вид элемента:
*                                    {String} caption    - локализованное наименование связки.
*                                    {String} reflection - имя связки.
*                                    {String} identifyingName - имя идентификации связки для получения
*                                                              стандартной реализации по этому имени.
*                                    {Object} primaryKey - параметры первичного ключа связки. Вид:
*                                          {String} name - имя поля ключа.
*                                    {Boolean} isCollection - флаг множественной связки (has_many)
*                                    {Boolean} isFinal - флаг финализированной связки. Если данный
*                                                        флаг задан для последней связки в цепи связок
*                                                        (первой в наборе) то при составлении фильтра
*                                                        на бизнес-логике в цепь связок не будет добавлена
*                                                        корневая модель.
*                                    {Boolean} isReverseMultiple - флаг обратной множественной связи.
*                                                                  Этот флаг означает связана ли предыдущая
*                                                                  связки в цепи или корневая модель
*                                                                  (для первого элемента) множественной
*                                                                  связью.
*                                    {String} polymorphicReverse - наименования обратной полиморфной связи.
*                                                                  Этот параметр должен быть заполнен для
*                                                                  связок связанных с предыдущей связкой или
*                                                                  корневой полиморфной связью.
*                                    {String} recordKey          - ключ экземпляра связки. Для возможности
*                                                                  построения фильтров.
*     {React-element-ref} operationsOrganizer - ссылка на элемент органайзера операций.
*     {String} viewType             - тип таблицы данных. Варианты:
*                                     'flat'      - "плоская" таблица (по-умолчанию).
*                                     'hierarchy' - иерархическая организация записей
*                                     (распредение по директориям или разделам).
*                                     'tree'      - иерахическая организация записей в виде дерева.
*     {Boolean} isRereadData        - флаг перечитывания данных. При установке данного флага
*                                     таблица отправляет запрос данных с текущими параметрами.
*                                     (по-умолчанию = false).
*     {Boolean} isFitToContainer    - флаг - замостить таблицу по контейнеру (по-умолчанию = false).
*     {Boolean} isHasStripFarming   - флаг наличия черезполосицы (по-умолчанию = true).
*     {Boolean} isSearchDoOnClient  - флаг поиска на клиенте (по-умолчанию = false - поисковый запрос идет в БЛ).
*     {Boolean} isFullyClientMode   - флаг полностью режима работы на клиенте. Таблица не работает
*                                     с БЛ. По-умолчанию = false TODO: режим не доделан - не реализовано
*                                     обновление, создание, удаление (если надо).
*     {Boolean} isPageSelectorInLinkMode - флаг селекторов страниц в виде кнопок-ссылок. По-умолчанию = false
*     {Boolean} isSuppressLargeTotalRecordsOutput - флаг подавления опции вывода всех записей при большом общем
*                                                   кол-ве записей(установлено ограничение в 1000 записей).
*                                                   По-умолчанию = false.
*     {Boolean} isUseImplementation - флаг использования стандартных параметров таблицы из
*                                     внешнего общего модуля, представляющего из себя объект,
*                                     разделенный на разделы по названиям модели. Для работы с данным
*                                     флагом компоненту также должен быть задан параметр
*                                     @props.implementationStore - задающий объект в котором
*                                     находятся стандарнтные параметры представления.
*                                     (по-умолчанию = false).
*     {Boolean} isImplementationHigherPriority - флаг более приоритетных свойств из хранилища реализаций.
*                                               Нужен для переопределения свойств, заданных по-умолчанию.
*                                               (по-умолчанию = false).
*     {Boolean} isMergeImplementation - флаг "слияния" свойств компонента со свойствами, заданными в
*                                       хранилище реализаций. (по-умолчанию = false)
*     {Boolean} enableObjectCard    - флаг разрешения показа карточки объекта по клику на строке.
*                                     (по-умолчанию = true).
*     {Boolean} enableColumnsHeader - флаг для показа заголовков колонок (по умолчанию = true).
*     {Boolean} enableRowSelect:    - флаг разрешения выбора записей (по-умолчанию = false).
*  {Boolean} enableRowSelectByClick - флаг разрешения выбора записей по клику на строку. (по-умолчанию = false).
*     {Boolean} enableRowOptions:   - флаг разрешения опций действий над записями (по-умолчанию = true).
*     {Boolean} enableCreate:       - флаг разрешения создания записей (по-умолчанию = true).
*     {Boolean} enableEdit:         - флаг разрешения обновления записей (по-умолчанию = true).
*     {Boolean} enableDelete:       - флаг разрешения удаления записей (по-умолчанию = true).
*     {Boolean} enableFilter:       - флаг разрешения отбора записей (по-умолчанию = true).
*     {Boolean} enableUserFilters   - флаг разрешения области пользовательских фильтров.
*                                     (по-умолчанию = false).
*     {Boolean} enableSettings      - флаг разрешения настроек таблицы. (по-умолчанию = false).
*     {Boolean} enableExport    - флаг разрешения экспорта данных в файл. (по-умолчанию = false)
*     {Boolean} enableSearch:       - флаг разрешения поиска записей (по-умолчанию = true).
*     {Boolean} enableToolbar:      - флаг разрешения панели инструментов (по-умолчанию = true). Если
*                                     задано значение false - будет скрыта панель действий полностью, вне
*                                     зависимости от того какие опции заданы для отдельных элементов панели.
*     {Boolean} enableStatusBar:    - флаг разрешения строки статуса (по-умолчанию = true).
*   {Boolean} enableRowDragAndDrop: - флаг разрешения перетаскивания строк (по-умолчанию = false).
*   {Boolean} enablePerPageSelector - флаг разрешения селектора выбора кол-ва записей на странице
*                                     (по-умолчанию = true).
*   {Boolean} enableLazyLoad        - флаг разрешения подгрузку новых страниц с данными по необходимости
*                                     по скролу до низа контейнера записей. (по-умолчанию = false).
*   {Boolean} enableManuals         - флаг разрешения доступа к руководствам по различным элементам таблицы.
*                                     (по-умолчанию = false).
      {React-element} ManualViewer  - компонент просмотрщика руководств.
*     {Object} createButtonParams   - параметры для кнопки создания записи. Могут быть заданы произвольные
*                                     параметры для компонента Button.
*     {Object} filterButtonParams   - параметры для кнопки открытия панели фильтрации. Могут быть заданы произвольные
*                                     параметры для компонента Button по категориям:
*                                       {Object} ready   - параметры для кнопки, без примененного фильтра.
*                                       {Object} applied - параметры для кнопки, c примененным фильтром.
*                                       {Object} common  - параметры кнопки, применяемые вне зависимости от фильтра.
*     {Object} implementationStore  - объект источников стандартной реализации для таблицы.
*                                     Если данный параметр задан и установлен флаг @props.isUseImplementation,
*                                     то для таблицы будут применены стандартные параметры представления,
*                                     если они будут найдены в заданном источнике. Если вместе с данным
*                                     параметром были заданы пользовательские параметры, определенные в источнике
*                                     стандартной реализации, то стандартные будут переопределены
*                                     пользовательскими.
*     {Object} styleAddition        - хэш параметров дополнительных стилей для таблицы. Вид:
*              {Object} common        - дополнительные стили для всего компонента (применяются к
*                                       корневому узлу компонента).
*              {Object} dataContainer - дополнительные стили для контейнера данных.
*              {Object} dataTable     - дополнительные стили для таблицы данных внутри контейнера.
*              {Object} row           - дополнительные стили для строки.
*              {Object} rowSelected   - дополнительные стили для выбранной строки.
*              {Object} rowFailed     - дополнительные стили для строки, помеченной флагом некорректности
*                                       isFailed.
*              {Object} cell          - дополнительные стили для ячейки.
*     {Object} hierarchyViewParams  - специфичные параметры для иерархического представления данных.
*                                     Вид:
*              {Boolean} enableViewChildsCounter          - флаг разрешения отображения счетчика дочерних узлов.
*                                                           (по-умолчанию =false).
*              {Boolean} enableViewKey                    - флаг разрешения отображения ключа для узла.
*                                                           (по-умолчанию =false).
*              {Boolean} enableViewServiceDate            - флаг разрешения отображения дат создания и обновления.
*                                                           (по-умолчанию =false).
*              {Boolean} enableLeafActivateMode           - флаг разрешения использования режима выбора только
*                                                           листовых узлов. В таком режиме при клике на не листовой узел
*                                                           происходит разворачивание/сворачивание или вход в
*                                                           содержимое узла, при клике на листовой узел происходит
*                                                           активация как обычно.
*                                                           (по-умолчанию =false)
*            {Boolean} enableSpecialActivateForInnerNodes - флаг разрешения специального выбора не листовых узлов.
*                                                           Данная опция позволяет выбирать внутренние узлы иерархии
*                                                           по клику на специальную кнопку. Данная опция имеет смысл
*                                                           при включенном режиме активации только листовых узлов enableLeafActivateMode.
*                                                           (по-умолчанию =false).
*              {Boolean} enableSelectParents              - флаг разрешения выбора родительски узлов
*                                                           (по-умолчанию =false).
*              {Boolean} enableCompetitiveRootSelectMode  - флаг разрешения выбора только одного корневого узла
*                                                           (у узла нет родительских). То есть при выборе определенного
*                                                           корневого узла все предыдущие отметки о выбранности других
*                                                           узлов сбрасываются. Данный режим корректно работает
*                                                           при одиночной вложенности, при более глубокой вложенности
*                                                           будет снимать все ранее выбранные узлы на уровнях ниже первого.
*                                                           (по-умолчанию = false).
*              {Boolean} enableSelectChildsOnSelectParent - флаг разрешения отметки всех дочерних узлов
*                                                           при отметке родительского. (по-умолчанию =false)
*              {Boolean} enableSelectParentOnSelectChild  - флаг разрешения отметки родительского узла
*                                                           при отметке любого дочернего. (по-умолчанию =false)
*              {Boolean} enableSelectRootOnActivateChild  - флаг выбора корневого элемента при активации дочернего узла
*                                                           (клик на узел). Параметр актуален для иерархического представления
*                                                           данных и возвращает корневую запись при клике на дочернюю.
*                                                           (по-умолчанию =false).
*              {Object} mainDataParams   - хэш параметров для отображения основной информации. Вид:
*                       {String} template  - строка-шаблон для формирования строки вывода основой информации.
*                       {Array} fields  - набор полей для подстановки значений в шаблон.
*              {Object} secondaryDataParams - хэш параметров для отображения второстепенной информации. Вид:
*                       {String} template  - строка-шаблон для формирования строки вывода основой информации.
*                       {Array} fields  - набор полей для подстановки значений в шаблон.
*              {Object} titleDataParams   - хэш параметров для отображения информации всплывающей подсказки. Вид:
*                       {String} template  - строка-шаблон для формирования строки вывода основой информации.
*                       {Array} fields  - набор полей для подстановки значений в шаблон.
*              {Object} styleForAdditionCell - стиль для доп. ячейки, содержимое, которой отрисовывается
*                                              функцией onRenderNodeAddition.
*              {Function} onRenderNode   - функция рендера отображения узла.
*              {Function} onRenderNodeAddition - функция рендера отображения дополнительного содержимого
*                                                справа от основного отображения узла.
*     {Object} dimension:           - хэш параметров размеров. Вид:
*             {Object} common -  хэш параметров размерности для корневого элемента. Вид:
*                    {Object} width:  - параметры ширины:
*                             {Number} max - максимальная ширина.
*                             {Number} min - минимальная ширина.
*                    {Object} height:  - параметры ширины:
*                             {Number} max - максимальная высота.
*                             {Number} min - минимальная высота.
*             {Object} dataContainer: - хэш параметров контейнера для таблицы с данными.
*                                       Вид аналогичен common.
*     {Object} reflectionRenderParams - хэш параметров рендера полей селектора. Вид:
*              {Object} [column_name]: - хэш параметров рендера поля селектора по имени column_name. Вид:
*                       {Object} instance: - хэш параметров рендера выбранного значения в поле селектора. Вид:
*                               {String} template - строка шаблон для формирования вывода выбранного элемента.
*                                                   Например, "{0} ({1})".
*                               {Array} fields - массив полей, значения которых подставляются в строку-
*                                                шаблон для вывода. Например, ['name', 'key'] (где
*                                                строка 'key'- означает ключ записи).
*                       {Object} dictionary - хэш параметров рендера словаря поля выборки. Вид:
*                                {Object} columnRenderParams - хэш параметров рендера колонок.
*                                                              Параметр аналогичен этому же параметру
*                                                              таблицы.
*     {Object} columnRenderParams   - хэш с параметрами отрисовки данных в столбцах/ячейках таблицы. Вид:
*                                {Boolean} isStrongRenderRule - флаг строгого форматирования колонок.
*                                                               Если задан = true, будут выводится только
*                                                               колонки, заданные в параметре columns.
*                                {Object} alignRules - правила выравнивания. Вид:
*                                      {Object} headers - правила выравнивания содержимого в заголовках. Вид
*                                            {String} vertical   - правило вертикального выравнивания.
*                                            {String} horizontal - правило горизонтального выравнивания.
*                                      {Object} cells - правила выравнивания содержимого в ячейках. Вид
*                                            {String} vertical   - правило вертикального выравнивания.
*                                            {String} horizontal - правило горизонтального выравнивания.
*                                {Object} columns - набор правил форматирования колонок.  Через данные
*                                                   параметр настраивается правила отображения определенного
*                                                   поля записи или поля связки записи (если задан параметр
*                                                   связок reflections). Также возможно задание произвольной
*                                                   доп. колонки, если для нее задается параметр onRenderCell.
*                                                   Вид:
*                                  (элемент) {Object} [columnName]:
*                                                 {Object} style          - стиль колонки.
*                                                 {String} caption        - выводимый заголовок.
*                                                 {Boolean} isHidden      - флаг скрытой колонки.
*                                                 {Boolean} isVirtual     - флаг "виртуальной" колонки. Данная
*                                                                           опция используется для отображения колонки,
*                                                                           не входящей в набор полей записи набора данных.
*                                                 {Function} onRenderCell - обработчик на отрисовку ячейки
*                                                                           колонки. Позволяет задать произвольное отображение.
*                                                 {Array<String>} reflections - цепь родительских связок для
*                                                                               извлечения целевого поля.
*                                {Object} cells - набор правил форматирования ячеек строк. Вид:
*                                   (элемент) {Object} [columnName]:
*                                                  {Boolean} enableCaption - флаг разрешения вывода заголовка поля.
*                                                  {Boolean} enableName - флаг разрешения вывода имени поля.
*                                                  {Boolean} enableType - флаг разрешения вывода типа поля.
*                                                  {Array} partsOrder - набор, упорядочивающий вывод служебных данных
*                                                                       в ячейке. Возможные значения:
*                                                                       'caption' - заголовок (локализованное название поля).
*                                                                       'name' - имя поля.
*                                                                       'type' - тип поля.
*                                                  {String} partsPosition - позиция слежебной метаинформации. Варианты:
*                                                                           'bottom' - снизу от значения.
*                                                            (по-умолчанию) 'top' (или любое др. значение) - вывод сверху.
*                                                  {String} partsAlign - выравнивание служебной информации. Варианты:
*                                                                           'right' - справа.
*                                                            (по-умолчанию) 'left' - слева.
*                                                  {Object} format: - параметры форматирования значения. Вид:
*                                                        {String} template        - шаблон вывода значения. Например - "{0} ({1})"
*                                                        {Array<String>} fields   - массив полей из записи, подставляемых в шаблон для вывода.
*                                                                                   Например, ['name', 'id']
*                                                        {Array<Object>} arbitrary - массив цепей произвольного выбора членов
*                                                                                    из параметров записи. Данный параметр будет использоваться
*                                                                                    если не задан параметр fields.
*                                                                                    Например:
*                                                                                    [
*                                                                                       {
*                                                                                          chain: ['reflections', 'parameter', 'value', 'fields', 'name', 'value']
*                                                                                       },
*                                                                                       {
*                                                                                          chain: ['reflections', 'parameter', 'value', 'fields', 'measure', 'value'],
*                                                                                          template: '({0})'
*                                                                                          alternatives: [
*                                                                                             chain: ['reflections', 'parameter', 'value', 'fields', 'measurement', 'value'],
*                                                                                             template: '({0})'
*                                                                                          ]
*                                                                                       }
*                                                                                    ].
*                                                                                    где chain - массив наименований членов элементов которые нужно извлесь
*                                                                                                из параметров записи.
*                                                                                        template - индивидуальный шаблон для формирования значения значения
*                                                                                                   извлеченного при помощи chain. Если значение не удалось извлечь
*                                                                                                   или оно пустое, то шаблон не будет применен.
*                                                                                        alternatives - набор альтернатив, по которым будет осуществлена попытка
*                                                                                                       получения значения, если основная цепь не дала результата.
*                                                                                    Если один из элементов - массив, то в цепи нужно указать
*                                                                                           индекс элемента, который нужно взять - например ['reflections', 'types', '0', ...]
*                                                  {Function} handler - обработчик значения в ячейке. В обработчик передаются
*                                                                       параметры по данной ячейке.
*                                {Array} columnsOrder - набор упорядочиваемых столбцов. Они будут выведены
*                                                       первыми в наборе, остальные(неупорядоченные) будут
*                                                       выведены справа от них в порядке, возвращенных из API.
*     {Object} filterAdditionParams   - хэш доп. параметров для фильтров. Вид:
*            {Object} search: - хэш доп. параметров для поискового фильтра. Вид:
*                 {Array<Object>} fields: - массив параметров по которым будет производится поисковый запрос.
*                                           Вид элемента массива:
*                     {Array, String} names - массив имен полей по которым нужно производить поиск
*                                             или одиночное имя поиска или строка-маркер ('all' - все поля).
*            {Object, undefined} affilation - параметры принадлежности поля. Вид:
*                             {Array} parents - массив родительских сущностей.
*                    {String} polyType - тип полиморфной связи.
*     {Object} dataManipulationParams - хэш с параметрами данных, необходимых для построения форм
*                                       манипуляции данными (прокидываются в динамическую форму). Вид:
*           {Boolean} enableClientConstruct - флаг разрешения построения данных, необходимых для формы
*                                              на стороне клиента из данных таблицы и выбранной записи
*                                              (при обновлении). При отрицательном или не заданном флаге
*                                              данные для построения формы будут получаться из API через
*                                              запрос.
*                                              Данная опция является экспериментальной и служит для
*                                              повышения быстродействия создания динамической формы.
*                                              Так как алгоритм для сложных форм достаточно сложный
*                                              и ресурсоемкий некоторые браузеры могут подвисать(Firefox),
*                                              поэтому пока лучше использовать только для простых форм.
*           {Object} sectionsOrder - параметры упорядочивания секций в навигаторе динамической формы
*                                      (секции аккордеона). Вид:
*                    {String} [accordion_name]: {Array<String>} [sectionNames] - где:
*                              accordionName - наименование навигатора для которого применяется
*                                              упорядочивание. Наименование аккордеона совпадает
*                                              с именем связки (например users, legal_entity_employees).
*                                              Для упорядочивания секций в основном навигаторе применяется
*                                              псевдоним 'root'.
*                              sections - набор наименований секций, совпадающих с именем модели(класса)
*                                         связки (например User, PaymentPlan и т.д.).
*                                         Для секции основных данных применяется псевдоним 'main'
*                    Например: root: ['User', 'main', 'Contact'] - для основного навигатора
*                                        секции будут выведены в порядке заданном массивом. Если
*                                        в навигаторе есть ещё секции, то они будут выведены
*                                        после упорядоченных секций в порядке, возвращенным из API.
*           {Object} fieldsOrder  - параметры упорядочивания полей в секции. Вид:
*                    {String} [section_name] : {Array<String>} [field_names] - где:
*                             section_name - имя секции, совпадающая с именем связки. Для коревой
*                                            секции применяется псевдоним 'root'.
*                             field_names  - набор наименований полей. Наименования полей, совпадают
*                                            с именами полей, возвращенных с API.
*                    Например: entity: ['full_name', 'short_name', 'oktmo_id'] - для секции с именем
*                              связки 'entity' первыми будут выведены поля упорядоченные массивом,
*                              остальные поля будут выведены в порядке, возвращенном с API.
*           {Object} presetParams - предварительно предустановленные параметры для создания
*                                   динамической формы. Вид:
*                    {Object} fields - параметры полей.
*                    {Object} externalEntities - параметры внешних связок.
*           {Object} externalEntitiesParams - параметры для внешних сущностей. Вид:
*              TODO: возможно стоит избавиться от этого параметра:
*                    {Object} allowExternalToExternal - параметры разрешенных внешних сущностей для
*                                                       внешних (для которых будут созданы элементы
*                                                       управления). Вид:
*                             {String} [EntityName]: {Array<String>} [AllowedEntities] - где:
*                                   EntityName - имя модели связки, для которой задаются доп. разрешенные
*                                                внешние связки. Например - Ownership.
*                                   AllowedEntities - набор имен моделей разрешенных для создания.
*                    Например: Ownership: ['OwnershipStatus', 'PaymentPlan'] - для внешней связки
*                              'Ownership' разрешены внешние связки 'OwnershipStatus', 'PaymentPlan'.
*           TODO: возможно нужно отказаться от данного парметра, т.к. данная операция производится в API:
*           {Object} hierarchyBreakParams - параметры прерывания иерархии построения связок. Вид:
*                    {String} [reflection_name] : {String, Array<String>} [break_reflection_names]- где.
*                             reflection_name - имя связки для которой настроено прерывание.
*                             break_reflection_names - имя или набор имен связок, на которых должна быть
*                                                      прервана цепь считывания связок.
*            Например: user: 'user_duties'
*                      document: ['document_type', 'document_file']
*            {Object} reflectionParams - доп. параметры для связок. Вид:
*                     {String} [ReflectionModel] : {Object} params, где:
*                              ReflectionModel - имя модели связки, для которой заданы доп. параметры.
*                              params - параметры связки. Вид:
*                                   {String} reflectionName - имя связки (для нахождения данной связки).
*                                   {String} type           - тип связки. Возможные варианты:
*                                                             'new'        - создание полей для создания
*                                                                            новых экземпляров (по-умолчанию).
*                                                             'dictionary' - создание поля выбора существующих
*                                                                            экземпляров (поле Selector).
*                                                             'combine'    - "комбинированный режим" - создаются
*                                                                            поля для создания нового экземпляра
*                                                                            и поле-селектора существующих экземпляров.
*                                  {Object} dictionaryParams - параметры для словаря (поля-селектора). Вид:
*                                           {Boolean} enableMultipleSelect - флаг разрешения множественного выбора.
*                                           {Object} additionFilterParams - доп. параметры фильтрации. Вид:
*                                                    {Boolean} isAddingSelectedItems - флаг разрешения добавления
*                                                                                      идентификаторов выбранных элементов
*                                                                                      в фильтр.
*          {Object} fieldConstraints - параметры ограничений полей. Вид
*                   {Array<Object>} constraints - массив ограничений по конкретным полям. Вид элемента:
*                                    {String} name   - имя поля.
*                         {RegExp object} nameRegExp - регулярное значение имени. Если задан данный
*                                                       параметр и не занад параметр name - то название
*                                                      поля, для которого будут применяться ограничения
*                                                      будут проверяться не по точному совпаданию, а
*                                                      по соответсвию регулярному выражению.
*                                    {Array} parents - массив наименований родительских сущностей.
*                       {String, Number} strongValue - значение "жестко" устанавливаемое
*                                                      в поле, вне зависимости от того
*                                                      было ли установлено значение ранее.
*                                 {Boolean} isHidden - флаг того, что поле скрывается.
*                                 {Boolean} isLocked - флаг того, что поле не доступно для изменений.
*                           {String} identifyingName - идентифицирующее имя поля (для выборки параметров
*                                                      из хранилища реализаций). Если данный
*                                                      параметр не задан для поля, то в качестве идентифицурующего
*                                                      имени будет задано имя поля, по которому построено поле.
*                   {Object} prefixAnchors - параметры "якорей" полей. Данный параметр позволяет
*                                           скрывать/показывать поля в зависимости от значений,
*                                           выбранных в других полях. Вид:
*                          {String} [prefix_name]: {Object} params
*                                   prefix_name - префикс поля на которое распросраняется дейтсвие "якоря".
*                                   params - параметры "якоря". Вид:
*                                       {String} field_name: {String, Number, Array<String, Number>} [values], где:
*                                         field_name - имя поля, на значения которого реагирует "якорь".
*                                         values - значение или значения, на которые задействуется данный якорь.
*           {Object} additionalValidationParams - дополнительные параметры для валидации. Вид:
*                    {Object} allowedPresenceForExternal - параметры разрешенной валидации
*                                                          присутствия(обязательности) для внешних
*                                                          связок(по-умолчанию для этих связок такой
*                                                          вид валидации отключен). Вид:
*                          {String} [reflection_name] - {Object, null} params - параметры связки. Если
*                                                          параметры не заданы ищется связки с единичной
*                                                          длинной цепи связей. Вид параметров:
*                                   {Array<String>} - цепь наименований связок.
*                              Пример:
*                                 allowedPresenceForExternal: {
*                                    entity: null,             - разрешена валидация присутствия полей связки
*                                                                единичной длинны:
*                                                                [@props.modelParams.name] -> entity.
*                                    documents:
*                                       chain: ['ownerships', 'payment_plans', 'documental_basis'] -
*                                                              - разрешена валидация присутсвия полей связки:
*                                                                @props.modelParams.name -> ownerships ->
*                                                                payment_plans -> documental_basis -> documents
*                                }
*                    {Array<Object>} customValidators - набор пользовательских валидаторов для
*                                                       конкретных полей. Вид элемента:
*                          {String} field        - имя поля.
*                          {Array<String>} chain - цепь связок до поля.
*                          {Function} handler    - функция валидатора.
*                              Аргументы:
*                                   {Object, String, Number, Array} value - значение в поле.
*                              Возврат:
*                                   {Array<String>} - массив ошибок (валидация не прошла).
*                                     или
*                                   {null, undefined} - нет ошибок (валидация прошла).
*                             Пример: Задается валидатор для поля с именем 'first_name' связки
*                                     @props.modelParams.name -> entity -> legal_entity_employees:
*                                customValidators:[
*                                   {
*                                      field: 'first_name',
*                                      chain: ['entity', 'legal_entity_employees']
*                                      handler: validateEnmployeeFirstName
*                                   }
*                                ]
*                   {Function} totalValidator - пользовательская функция общей проверки
*                                               полей формы. Через данную функцию можно задать
*                                               комплексную проверку полей. Функция вызывается
*                                               в контексте экземпляра динамической формы.
*                       Аргументы:
*                            {Object} formElements - элементы формы. Вид :
*                                {Array} accordions - контейнеры-аккордеоны формы.
*                                {Object} fields    - поля формы. Вид:
*                                     {String} name - имя поля (имя поля в таблице).
*                                     {String} fieldName - имя поля формы (сгенерированное для
*                                                          DOM-элемента).
*                                     {React-element-ref} instance - ссылка на экземпляр поля.
*                                      ...
*                       Возврат:
*                            {null, undefined} - нет ошибок (валидация прошла).
*                             или
*                            {Object} - набор ошибок (валидация не прошла). Варианты возврата:
*                                {
*                                   error1: 'Ошибка'  - будет выведено: error1: 'Ошибка'
*                                   error2: { error: 'Еще одна ошибка' } - будет выведено:
*                                                                          error2: 'Ещё одна ошибка'.
*                                   error3: { error: 'Последняя ошибка', caption: 'локализованная ошибка' } -
*                                                                          будет выведено:
*                                                                          'локализованная ошибка': 'Последняя ошибка'
*                                }
*           {Object} edit - параметры манипуляции при редактировании. Вид:
*                    {Object} denyToEditReflections - параметры запрещенных для редактирования экземпляров
*                                                    связок. Вид:
*                                      {String} [reflection_name] : {Object, null} - параметры для связки reflection_name.
*                                         Object} - параметры для опознавания связки. Вид:
*                                           {Array<Object>} chain - набор наименований связок до данной связки.
*                                           {Boolean} isAnywhere  - флаг расположения связки в любом месте (вне зависимости от parents)
*                    {Object} denyReflections - запрещенные связки. Если связка
*                                               запрещается для нее не будет создан раздел для работы.
*                                               Вид:
*                             {String} [reflection_name] : {Object, null} - параметры для связки reflection_name.
*                                {Array<String>} chain - набор наименований связок до данной связки.
*                                {Boolean} isAnywhere  - флаг расположения связки в любом месте (вне зависимости от parents)
*                    {Object} eagerlyLoadedReflections - параметры "нетерпеливо"" подгружаемых связок для
*                                                        редактирования. Вид аналогичен параметру denyToEditReflections.
*                    {Object} fieldConstraints - параметры ограничений полей. Аналогичны общему параметру fieldConstraints.
*           {Object} create - параметры манипуляции при создании. Вид:
*                    {Object} fieldConstraints - параметры ограничений полей. Аналогичны общему параметру fieldConstraints.
*                    {Object} denyReflections
*     {Object} initData             - хэш параметров начальных данных. Данный параметр позволяет
*                                     вручную подготовить данные для таблицы или считать их из другого
*                                     компонента и задать их в таблицу. Если начальные данные будут
*                                     заданы таблица не будет отправлять первоначальный запроса на
*                                     получение данных. Вид:
*                  {Object} entityParams:             - параметры сущности.
*                          {Object} externalEntities: - параметры внешних связок.
*                          {Object} fieldParams:      - параметры полей.
*                  {Object} errors:                   - ошибки.
*                  {Object} paginateParams:           - параметры постраничного вывода. Если данный
*                                                       параметр не задан, он определяется при считывании
*                                                       на основании кол-ва записей и параметра @props.recordsPerPage
*                  {Array} records:                   - набор записей.
*     {Obejct<Object>} fluxParams   - хэш с параметрами flux-инфраструктуры
*                                     для работы с данными:
*           {Boolean} isUseServiceInfrastructure - флаг использования сервисной инфраструктуры flux.
*                                                  (единый подход к работе с API). Если данный флаг
*                                                  задан, то параметры store, init, create, update
*                                                  игнорируются.
*           {Object} store - хранилище flux, изменения которого слушаем
*           {Object} init  - параметры инициализации (начальный запрос данных):
*              {String} requestUrl:        - адрес для запроса данных в БЛ. Если данный параметр не
*                                            задан, то адрес должен быть жестко задан в методах flux.
*              {Number} requestIdentifier: - идентификатор запроса. Передается в функцию запроса данных,
*                                            для того, чтобы в инфраструктуре flux можно было делать
*                                            отдельный поток данных для разных экземпляров.
*              {Function} sendRequest:     - фукнция, которую компонент вызывает для
*                                            получения начальных данных таблицы.
*              {String} responseType:      - тип события в хранилище flux, которое слушаем
*                                            для начального получения данных таблицы.
*              {Function} getResponse:     - функция получения инициализационных данных
*                                            из хранилища.
*              {Function} getPageCount:    - функция получения инициализационного кол-ва
*                                            страницы.
*              {Function} getEntriesStatistic - функция получения статистики по записям.
*
*           {Object} create - параметры создания новой записи:
*              {Function} sendInitRequest: - функция запроса полей для формы создания.
*              {String} responseInitType:  - тип события на получение полей для создания.
*              {Function} getInitResponse: - функция получения полей из flux хранилища.
*              {Function} sendRequest:     - функция отправки запроса на создание записи.
*              {Function} getResponse:     - функция получения результата запроса на создания
*                                            из flux-хранилища.
*              {String} responseType:      - тип события на получения результата создания.
*
*           {Object} update - параметры обновления записи:
*              {Function} sendInitRequest: - функция запроса полей для формы с данными записи.
*              {String} responseInitType:  - тип события на получение полей с данными для обновления.
*              {Function} getInitResponse: - функция получения полей с данными из flux хранилища.
*              {Function} sendRequest:     - функция отправки запроса на обновление записи.
*              {Function} getResponse:     - функция получения результата запроса на создания
*                                            из flux-хранилища.
*              {String} responseType:      - тип события на получения результата создания.
*           {Object} userFilters:          - параметры flux-инфраструктуры для пользовательских фильтров.
*     {Object} massOperations:             - хэш с параметрами массовых операций над записями. Вид
*                                             {Boolean} isInPanel - флаг того, что операции будут отражены
*                                                                  на отдельной панели. По умолчанию false.
*                                                                  Если false - операции будут отображены
*                                                                  на панели инструментов таблицы (где поиск и
*                                                                  фильтрация).
*                                             {Boolean} isSparceButtons - флаг "разреженных" кнопок. То есть
*                                                                         кнопки будут располагаться друг от друга
*                                                                         отступами.
*                                             {String} panelOpenButtonCaption - надпись на кнопке открытия панели массовых
*                                                                  операций.
*                                             {Array<Object>} operations - массив хэшей с параметрами операций над записью.
*                                                                  Вид:
*                                                           {String} name         - наименование опции.
*                                                           {String} caption      - заголовок опции.
*                                                           {String} icon         - наименование иконки опции.
*                                                           {String} title        - всплывающее пояснение к опции.
*                                                           {String} confirmText  - текст подтверждения. Если задан,
*                                                                                   то перед действием опции будет выдан
*                                                                                   диалог взаимодействия с запросом подтверждения.
*                                                           {String} responseText - текст ответа, выводимый в уведомлении после
*                                                                                   массовой операции.
*                                                           {Object} customData   - пользовательские данные, отправляемые вместе
*                                                                                   с запросом в API.
*                                                           {Boolean} isOrdinaryButton - флаг создания обычной кнопки операции
*                                                                                        Если флаг не выставлен - создается
*                                                                                        кнопка-ссылка.
*                                                           {Object} styleAddition - доп. стиль для кнопки.
*                                                           {Object} additionButtonParams - доп. параметры для кнопки. Могут
*                                                                                           быть заданы произвольные параметры для
*                                                                                           компонента Button.
*                                                           {Boolean} isUnsetMarkedOnCallback - флаг снятия отметок о выделенности после операции.
*                                                                                   (данное действие приведет к закрытию панели операций).
*                                                                                       recordsHandler: this._prepareAcceptedPayments,
*                                                           {Function} recordsHandler - функция пользовательской подготовки
*                                                                                       специфичных данных на базе выбранных на странице
*                                                                                       записей. Затем подготовленные данные передаются
*                                                                                       в функцию отправки запроса (4-м параметром).
*                                                           {Object} recordsValidatorParams - параметры валидации выбранных строк
*                                                                                             перед отправкой. Вид:
*                                                                    {Function} handler - функция валидации. Валидация, считается
*                                                                                         проиденной если возвращается пустой результат.
*                                                                                         При возвращении любого результата, отличного
*                                                                                         от null или undefined валидация считается не
*                                                                                         пройденной и отправка запроса массовой операции
*                                                                                         будет отменена. Ожидаемый обрабатываемый результат:
*                                                                                            {String} error - произвольная ошибка валидации.
*                                                                                            {Array<Number, String>} failedRecords -
*                                                                                               массив ключей строк не прошедших валидацию,
*                                                                                               то при совместном использовании флага
*                                                                                               isMarkFailedRow - соотсветсвующим строкам
*                                                                                               будет выставлен флаг isFailed, что дает
*                                                                                               возможность применять к ним специфичные стили
*                                                                                               styleAddition.rowFailed для подсветки.
*                                                                     {Boolean} isMarkFailedRow - флаг пометки строк, не прошедших валидацию.
*                                                                     {String} failText - текст, выводимый в окне уведомления
*                                                                                         о неуспешной операции, если данный
*                                                                                         параметр не задан будет выведен стандартный
*                                                                                         текст.
*                                                            {Object} responseBehavior - хэш параметров реакции на ответ. Параметр аналогичен
*                                                                                        параметру операции над записью.
*                                                            {Object} dynamicParams    - хэш параметров для построения формы с динамической формой.
*                                                                                        Данный параметр аналогичен параметру операции над записью.
*                                                            {Object} fluxParams  - хэш параметров взаимодействия с БЛ. Вид:
*                                                                  {Object} store:         ..., - хранилище flux.
*                                                                  {Function} sendRequest: ..., - функция отправки запроса.
*                                                                  {Function} getResponse: ..., - функция получения данных ответа.
*                                                                   {String} responseType: ..., - строка с именем события, которое слушаем.
*     {Array<Object>} customRowOptions:    - массив хэшей с кастомными опциями строки. Вид:
*            [
*               {Object} {
*                          {String} name: ..., - имя кастомной опции.
*                  {Array, String} title: ..., - заголовок кастомной опции (выводимый при наведнии курсора).
*                                                Если задан массив, то выбор  элемента осуществляется
*                                                по состоянию целевого поля fieldForCondition.
*                   {Array, String} icon: ..., - иконка(имя) кастомной опции (из FontAwesome).
*                                                Если задан массив, то выбор  элемента осуществляется
*                                                по состоянию целевого поля fieldForCondition
*                                                (задано/не задано значение, true/false).
*                   {String} confirmText: ..., - текст подтверждения. Если данный параметр задан и опция
*                                                не диалоговаия, то перед проведением операции выдается
*                                                диалог подтверждения операции. При пустом параметре
*                                                операция выполняется по нажатию на кнопку операции.
*             {String} fieldForCondition: ..., - целевое поле
*                 {Boolean} isRereadAfter      - флаг перечитывания после операции. Если
*                                                флаг установлен, то после операции посылает
*                                                запрос на перечитывание с текущими параметрами таблицы.
*                 {Object} contentParams: ..., - хэш параметров контента операции над записью
*                                                (для создания формы) Вид:
*                                      {String} model: ..., - имя модели (для формирования полей формы)
*                        {Object} clarificationParams: ..., - хэш с параметрами пояснения к действию
*                                                             (для формирования заголовка диалога). Вид:
*                                                   {String} template: ..., - строка шаблон для фомирования залоговка
*                                                                             (Например "Диалог для пользователя {0} {1}")
*                                              {Array<String>} fields: ..., - массив строк-имен полей записи,
*                                                                             которые нужно подставить в шаблон.
*                                                                             (Например: ['first_name', 'last_name']).
*                                     {Object} fields: ..., - хэш с параметрами полей, которые должны
*                                                             в форму отправки данных по опции. Вид:
*                                                       {String} type: ..., - тип поля ввода ('text', 'password', ...)
*                                                       {String} name: ..., - имя поля ввода (будет отправлено в БЛ).
*                                                    {String} caption: ..., - заголовок поля (будет выведен на форме).
*                                                      {String} value: ..., - значение в поле.
*                                               {String} defaultValue: ..., - значение по-умолчанию (к нему будет сброшено значение).
*                                     {Object} dynamicParams: - параметры для создания динамической формы. Вид:
*                                                 {Object} constraints: - параметры ограничений для элементов. Вид:
*                                                        {Object} fields - параметры ограничений для полей. Вид:
*                                                            {Array<String>} only - массив имен полей включаемых в
*                                                                                   набор результирующих полей
*                                                                                   по динамической форме (только
*                                                                                   эти поля будут).
*                                                          {Array<String>} except - массив имен полей исключаемых из
*                                                                                   набора результирующих полей по динамической
*                                                                                   форме (будут сформированы все поля кроме
*                                                                                   этих).
*                                                          {Boolean} isPurged - флаг очистки коллекции.
*                                                        {Object} reflections - параметры ограничений для связок. (АХТУНГ!: непроверенная фича)
*                                                             {Array<String>} only  - набор связок, включаемых в реузльтирующие связки.
*                                                             Array<String>} except - набор связок, исключаемых из результирующих.
*                                                 {String} reflectionToMain - наименование связки, параметры которой будут
*                                                                             подставлены на главные параметры для формы
*                                                                             (fields, externalEntities) вместо основных
*                                                                             для текущей входной точки.
*                                                 {Array} reflectionsChain - цепь имен-связок для получения целевого содержимого
*                                                                            (TODO: расписать отличие от reflectionToMain или переработать).
*                                                 {Object} customServiceFluxParams - произвольные параметры взаимодействия с
*                                                                                    бизнес-логикой через flux. Вид:
*                                                         {String} endpoint - адрес взаимодействия с бизнес-логикой.
*                                                         {String} method - метод взаимодействия с бизнес-логикой(методы нужно писать
*                                                                           аналогично вызовам в библиотеке взаимодействия superagent)/
*                                                 {Object} eagerlyLoadedReflections - параметры "нетерпеливо" подгружаемых связок для
*                                                                                     редактирования. Вид аналогичен параметру
*                                                                                     dataManipulationParams.edit.denyToEditReflections.
*                                                 {Boolean} isUseImplementation - флаг разрешения использования стандартных
*                                                                                 реализаций (зачем?)
*                                                 {Function} onReady  - обработчик события "готовности" формы.
*                                                                       В данный момент все элементы формы постоены
*                                                                       и готовы к взаимодействию.
*                                                 {Function} onClearField - обработчик на очистку поля.
*                                                 {Function} onChange - обработчик изменения в любом поле формы.
*                                                 {Function} onInitField - обработчик на инициализацию поля формы.
*                                                 {Function} onDestoryField - обработчик на уничтожение поля формы.
*                    {Object} fluxParams: ..., хэш параметров flux-инфраструктуры для отправки запроса. Вид:
*                                          {Object} store: ..., - хранилище на изменение которого подписываемся.
*                                  {Function} sendRequest: ..., - функция отправки запроса.
*                                  {Function} getResponse: ..., - функция получения данных ответа.
*                                   {String} responseType: ..., - строка с именем события, которое слушаем.
*               {Object} responseBehavior: ..., - хэш с параметрами поведения при ответе. Вид:
*                      {String, Array} successInscription: ..., - текст успешного выполнения операции.
*                                                                 Если задан массив, то выбор  элемента осуществляется
*                                                                 по состоянию целевого поля fieldForCondition.
*                                 {String} responseObject: ..., - имя параметра хэша, которое нужно считать.
*                                                                 (Например {block: {...}} - 'block').
*                              {Boolean} isReRenderRecord: ..., - флаг того, что нужно перерисовать данные по
*                                                                 записи, по которой была выполнена операция.
*                         },
*                ...
*            ]
*     {Object} objectCardParams  - хэш параметров карточки объекта. Вид:
*               {Boolean} isDisplayReflections  - флаг отображения связок.
*               {Number} maxDataTabCountPerLine - максимальное кол-во вкладок для
*                                                 раздела "Данные" в одну линию(вкладки добавляются,
*                                                 если задан флаг isDisplayReflections и для
*                                                 объекта есть связанные сущности). Если
*                                                 общее кол-во вкладок будет выходить за заданный
*                                                 максимум - будет добавляться вкладка выбора
*                                                 остальных с пометкой '...'
*               {Object} formatRules - хэш параметров форматирования карточки. Вид:
*                        {Object} caption: - хэш параметров форматирования заголовка карточки. Вид:
*                                {String} template - шаблон для форматировия. Пример: "{0} ({1}-{2})"
*                                {Array} fields    - массив полей выводимых из записи в шаблон
*                                {String} icon     - иконка в заголовке
*                        {Object} content - параметры ренедра основного содержимого карточки. Вид:
*                                {Function} render - функция рендера содержимого карточки (основного вида).
*                                {Boolean} isHideFieldCaptions - флаг скрытия заголовков для полей при
*                                                                 стандартном рендере полей записи.
*                        {Object} reflections - параметры формирования для связок. Вид элемента:
*                                [collectionName] {Object} - параметры для коллекции collectionName. Вид:
*                                      {String} icon          - иконка, выводимая в заголовке вкладки для данной коллекции.
*                                      {Boolean} isHidden     - флаг скрытия связки (не выводится во вкладке).
*                                      {Boolean} isProhibited - флаг запрещения работы со связкой (не выводится
*                                                               во отдельной вкладке раздела "данные" и
*                                                               при формировании печатной формы карточки).
*                                          {Boolean} isDamned - флаг "проклятости" связки. Если данный флаг задан,
*                                                               то для данной связки не создаются отображения
*                                                               для всех дочерних элементов(на всех уровнях вложенности
*                                                               начиная с текущей).
*                               {Boolean} isUseParentResource - флаг использования родительского ресурса.
*                                                               Если данный флаг задан, то при формировании
*                                                               таблицы данных для отображения экземпляров
*                                                               связки имя модели для таблицы будет задано
*                                                               такое же как и для родительской модели (для
*                                                               работы через сервисное хранилище flux).
*                                   {Array<Object>} relations - параметр аналогичен параметру
*                                                               @props.modelParams.relations
*                                                               для возможности формирования
*                                                               корректных параметров для таблиц данных
*                                                               связок.
*                        {Array<Object>} relationAlternatives - альтернативы связок. Если задан данный
*                                                               параметр, то связки, применяемые для
*                                                               построения таблицы определяются по
*                                                               первой(упорядочивание по индексам
*                                                               массива) подходящей
*                                                               альтернативе. Подходящая альтернатива
*                                                               определяется по имени альтернативы -
*                                                               если она присутствует в связках серилизованной
*                                                               записи, применяются параметры для нее,
*                                                               остальные игнорируются. Если
*                                                               задан параметр relations, то данный параметр
*                                                               игнорируется. Вид элемента:
*                                                               {String} name - имя альтернативы (совпадает с
*                                                                               именем связки серилизованной
*                                                                               записи).
*                                                               {Array<Object>} - relations - параметры
*                                                                                             связок.
*                                   {String} redefinedCaption - переопределяемый заголовок связки.
*                                                               (выводимый в закладке для связки).
*                                                               Если параметр не задан, то выводимый
*                                                               заголовок определяется непосредственно
*                                                               из параметров связей записи.
*                                   {Object} dataTableParams  - любые специфичные параметры для таблицы,
*                                                               используемой для вывода записей связки.
*               {Object} operationParams - параметры операций над объектом. Данный параметр
*                                          нужен для управления стандартными и пользовательскими операцями
*                                          над объектом выполняемые прямым запросом (через кнопку) или
*                                          делегируемых внешнему элементу(диалоговому окну, области и т.д.)
*                                          по нажатию на кнопку. Данный парметр усправляет созданием
*                                          кнопок-операций в заголовке карточки (соответственно заголовок
*                                          должен быть включен). Вид:
*                                       {Boolean} isUseStandard - флаг использования стандартных операций
*                                                                 (переход к редактированию, удаление,
*                                                                  формирование пасспорта объекта в виде файла).
*                                  {Array<Object>} custom - массив параметров произвольных действий
*                                                                  над объектом. Вид:
*                                               {String} icon - иконка на кнопке.
*                                              {String} title - выводимая подсказка на кнопке.
*                                          {Function} onClick - обработчик нажатия на кнопку.
*               {Array<Object>} customActions  - массив с набором пользовательских параметров
*                                        действий над объектом, возможных в карточке объекта.
*                                        Данная опция нужна для доп. манипуляций с объектом через
*                                        пользовательский элемент.
*                                        Вид элемента массива:
*                                           {String} name:    - имя действия.
*                                           {String} caption: - заголовок, выводимый на селекторе вкладки с данным действием.
*                                           {String} icon:    - наименование иконки(FontAwesome), выводимой на селекторе.
*                                           {String} keyProp  - ключ элемента (реактовский - может нужно выпилить).
*                                    {React-element} content  - содержимое дейтсвия.
*     {Function} onRowClick     - обработчик клика по строке. Аргументы:
*                                   {Object} recordData     - данные записи.
*                                   {String} acitveDataName - наименование данных, отображенных в таблице
*                                                             (при комплексных данных).
*     {Function} onReady        - обработчик события на начала готовности компонента к операциям.
*                                 Аргументы:
*                                   {React-element} this - ссылка на экземпляр компонента.
*                                   {Array<Object>} records - загруженные записи.
*     {Function} onKeyDown      - обработчик на нажатие клавиш клавиатуры на контейнере с данными.
*                                 Аргументы:
*                                   {Object} event - объект события.
*     {Function} onSelectRow    - обработчик на выбор строки(отметка галочкой/снятие отметки).
*                                 Аргументы:
*                                   {String, Number} recordID - идентификатор выбираемой строки/узла.
*                                   {Object} markedRows       - параметры выбранных строк (совпадает с
*                                                               состоянием @state.markedRows).
* @state :
*     {Array<Object>} tableData       - массив записей таблицы (записи для отображения).
*     {Object} initData             - изначально заданные параметры. Параметр используется при фильтрации
*                                       записей(поиске) на клиенте для возврата к исходному виду. Вид:
*           {Array<Object>} tableData   - массив записей.
*           {Object} paginateParams     - параметры постраничного вывода.
*     {Object} entityParams           - хэш с параметрами сущности. Вид:
*        {Object} externalEntities    - хэш с параметрами внешних сущностей.
*        {Object} fieldParams         - хэш с параметрами полей таблицы.
*     {Object} paginateParams         - хэш с параметрами постраничного вывода. Вид:
*           {Number} totalPages       - общее кол-во страниц.
*           {Object} entriesStatistic - параметры статистики по возвращенным записям. Вид:
*              {Number} start - с какой.
*              {Number} end   - по какую.
*              {Number} total - сколько всего.
*     {Number} perPage          - текущее значение ко-ва записей на странице.
*     {Number} activePage       - текущая активная страница.
*     {String, Object} recordOperation - текущая операция с записями. Определяет нужно ли показывать
*                                        диалог работы с записями. Варианты:
*                                       ''       - действия отстутствуют.
*                                       'create' - создание.
*                                       'update' - обновление.
*                                       'delete' - удаление.
*                                       {Object} - хэш с параметрами кастомной операции.
*     {String} orderDirection   - направление упорядочивания:
*                                 DESC - по убыванию,
*                                 ASC  - по возрастанию.
*     {Object} appliedMassOperation - параметры примененной операции.
*     {React-element-ref} touchedRow - ссылка на строку с которой произошло взаимодейтсвие пользователя.
*     {String} touchedRecordID  - идентификатор записи, над которой производятся операции.
*     {Array} touchedNodePath   - массив-путь до текущего активированного узла.
*     {String} orderedField     - название поля, по которому было упорядочивание.
*     {Number} pagesCount       - кол-во страниц с данными.
*     {String} searchExpression - подстрока для поиска.
*     {Object} filterParams     - параметры фильтрации записей. Применяются для поисковых
*                                 запросов и фильтрации. Вид:
*                          {Object} filter - параметры сложного фильтра. Вид:
*                                   {Array} terms - массив параметров фильтрации по полям. Вид:
*                                         {String} fieldName: {Object} terms.
*                                                  Если в качестве имени поля передана строка 'all',
*                                                   то фильтрация будет происходить по всем полям модели.
*                                                  Если строка 'key' - то выборка будет по ключу.
*                                                   Вид:
*                                                  {String} expr  - выражение для фильрации,
*                                                  {String} match - тип соответствия. Варианты:
*                                                           'like'    - поиск подстроки expr в значении поля
*                                                           'eq'      - строгое равенство
*                                                           'less'    - field.value > expr
*                                                           'greater' - field.value > expr
*                                                           'not'     - field.value != expr
*                                                           'in'      - field.value in expr
*                                                           'not in'  - field.value not in expr
*                                   {String} template - шаблон строки фильтрации. Для возможности
*                                                       группировки условий. Например:
*                                                       "%s AND (%s OR %s) OR %s". Где порядковые номера
*                                                        символово подстановки строк %s соответствуют индексам
*                                                        параметров фильтрации из массива terms.
*                                   {Boolean} isAnyOfTheTerms - флаг соответствия любому из условий,
*                                                               заданного в параметрах terms.
*                                                               По-умолчанию false.
*                                                               false cоответсвует склейке условий по
*                                                                     строгому соответствию (AND),
*                                                               true  - по OR.
*                          {Object} search - параметры поисковой фильтрации. Пример:
*                                   { all: { expr: 'test', match: 'like' } }   - фильтр по всем текстовым
*                                                                                полям по вхождению подстроки 'test'.
*                          {Object} marked - параметры фильтрации по выделенным строкам. Пример:
*                                   { key: { expr: '(1,2,3)', match: 'in' } }  - фильтр по ключевому полю на
*                                                                                выбор в массиве значений [1,2,3]
*                                   { key: { expr: '(2,4)', match: 'not_in' }} - фильтр по ключевому полю на
*                                                                                выбор всех кроме значений [2,4]
*     {Array} userFilters     - набор пользовательских фильтров.
*     {React-element} activityTarget - целевой узел для всплывающего уведомления и ajax-загрузчика.
*     {Object} popupParams         - параметры всплывающего уведомления. Вид:
*              {String} text - текст уведомления(для показа всплывашки
*                              после выполненной операции)
*              {String} id   - идентификатор уведомления.
*     {Object} dialogInteractionParams - параметры диалога взаимодействия с пользователем. Вид
*              {String} text    - выводимый текст диалога взаимодейтсвия.
*              {String} caption - заголовок диалога взаимодейтсвия.
*              {String} type    - тип диалога взаимодействия.
*     {Object} tableState       - строка-идентификатор состояний компонента:
*                               'init'         - начальная инициализация
*                               'requesting'         - запрос данных
*                               'dataReceived' - данные получены
*                               'dataRendered' - данные отрисованы.
*     {Object} implementationProps - свойства компонента, считанные из хранилища
*                                    стандартных реализаций.
*     {Object} markedRows       - хэш для хранения строк, для которых происходило
*                                 выделение/снятие выделения. Вид:
*                                 {
*                                    rowKey: true/false - true  - помечен,
*                                                         false - пометка снята.
*                                 }
*     {Object} markedNodes       - хэш для хранения узлов, для которых происходило
*                                 выделение/снятие выделения. В качестве ключа хранится
*                                 путь ключей до узла. Вид:
*                                 {
*                                    nodeKeyPath: true/false - true  - помечен,
*                                                              false - пометка снята.
*                                 }
*     {Object} complexDataParams - хэш с параметрами хранения сложных данных.
*
*     {Boolean} isAllRowsMarked - флаг того, что были выбраны все записи.
*     {Boolean} isFilterChanged - флаг того, был изменен фильтр.
*     {Boolean} isSettingsAreaOpen - флаг показа области настройки таблицы.
*     {Boolean} isDataExoprtAreaOpen - флаг показа области экспорта данных.
*     {Boolean} isExportRequested - флаг запрошенности файла экспорта (запрос на
*                                   экспорт отправлен).
*     {String} activeOperationsPanel  - наименование текущей активной панели действий
*                                       над записями. Варианты:
*                                       "massApplication"  - массовые операции над выбранными записями.
*                                       "filter"           - применения фильтра для выборки записей.
*                                       "none"             - текущая активная панель отсутствует.
* @functions:
*     getRecord             - функция получения записи по ключу.
*        Аргументы:
*           {String, Number} key - ключ получаемой записи.
*        @return {Object, undefined}  - параметры найденной запись
*     getRecordFromHierarchy - функция получения записи из иерархии(для иерархических таблиц)
*        Аргументы:
*           {Array<String>} nodePathKey - путь до узла
*           {Boolean} isWithParent      - флаг считывания вместе с родительской записью.
*        @return {Object, undefined}  - параметры найденной запись
*     getHierarchicalRecordsChain  - функция получения цепи записей из иерархии - пути(для иерархических таблиц)
*         Аргументы:
*            {Array<String>} nodePathKey - путь до узла  nodePath
*        @return {Array<Object>, undefined}  - набор записей - путь.
*     refreshRecord         - функция обновления параметров записи в наборе записей
*                             таблицы.
*        Аргументы:
*           {Object} recordParams - параметры обновляемой записи. Обновляемая запись находится
*                                   в коллеции по параметры key.
*        @return {Object} - параметры обновленной записи.
*
*     initKeyManipulation     - функция передачи управления вводом с клавиатуры на
*                               компонент (инициирует активированную строку и
*                               фокусируется на контейнере данных)
*        @return {undefined}
*
*     getActivatedRow         - функция получения ссылки на экземпляр компонента
*                               текущей активированной строки.
*        @return {React-element} - экземляр текущей активированной строки.
*
*     getActivatedRowKey       - функция получения ключа текущей активированной строки.
*                               компонент (инициирует активированную строку и
*                               фокусируется на контейнере данных)
*        @return {Number, String} - ключ записи активированной строки.
###
DataTable = React.createClass
   _DELETE_NOTIFY: 'Запись удалена'
   _CREATE_NOTIFY: 'Запись создана'
   _UPDATE_NOTIFY: 'Запись обновлена'
   _CONFIRM_DELETE_TEXT: 'Удалить запись?'
   _RESPONSE_ERRORS_TITLE: 'Ошибка выполнения: '

   # @const {Object} - наименования элементов компонента.
   _TABLE_ELEMENTS: keyMirror(
      DataTableHeader: null
      DataTableRows: null
      DataTableHierarchyView: null
      DataTableToolbar: null
   )

   # TODO: перенести все текстовые сообщения для уведомлений в данный хэш.
   # @const {Object} - наборы параметров для всплывающих уведомлений.
   _POPUP_CONTENT_DEFAULT:
      standardError:
         text: 'Операция не успешна'
         type: 'error'
      userFilters:
         create:
            text: 'Фильтр успешно сохранен'
         update:
            text: 'Фильтр обновлен'
         delete:
            text: 'Фильтр удален'

   # @const {Object} - параметры для кнопок действия динамической формы
   #                   (для переопределения значений по-умолчанию).
   _DYNAMIC_FORM_ACTION_PARAMS:
      submit:
         isClearAfter: true
      complete:
         isAbsent: false
      reset:
         caption: 'Сбросить'

   # @const {Object} - Параметры для диалога и динамической формы манипуляции
   #                   данными.
   _DIALOG_DATA_MANIPULATION_PARAMS:
      new:
         title: 'Создание новой записи'
         submitCaption: 'Создать'
         resetCaption: 'Сбросить'
      update:
         title: 'Обновление записи'
         submitCaption: 'Сохранить'
         resetCaption: 'Восстановить'

   # @const {Object} - набор системных сообщений.
   _MESSAGES:
      errors:
         initDataOrFluxNotSet: [
            'Для таблицы не заданы первоначальные данные '
            'и параметры считывания данных flux.'
         ].join ''
         massOperations:
            failValidate: 'Валидация записей не пройдена'
         flux:
            getInstanceNotSet: [
               'Параметры для получения экземпляра не заданы для компонента.'
               'Задайте использование сервисной инфраструктуры flux или метод instance '
               'props.fluxParams.instance для получения экземпляра.'
            ].join ''

   # @const {Object} - хэш возможных видов таблицы.
   _TABLE_VIEW_TYPES: keyMirror(
      flat: null,             #(по умолчанию)
      hierarchy: null,
      tree: null
   )

   # @const {Object} - хэш возможных сосояний компонента
   _TABLE_STATES: keyMirror(
      init: null
      requesting: null
      dataReceived: null
      dataRendered: null
   )

   # @const {Object} - хэш возможных операций над записью.
   _RECORD_OPERATIONS: keyMirror(
      delete: null
      update: null
      create: null
      view: null
      none: null
   )

   # @const {Object} - хэш возможных операций над записями.
   _RECORDS_OPERATIONS: keyMirror(
      massApplication: null
      filter: null
      none: null
   )

   # @const {Object} - хэш возможных типов соответсвия в фильтре
   _FILTER_MATCH_TYPES:  keyMirror(
      eq: null
      less: null
      greater: null
      not: null
      like: null
      in: null
      not_in: null
   )

   # @const {Object} - ключи доступа к элементам фильтра
   _FILTER_KEYS: keyMirror(
      terms: null
      expr: null
      fields: null
      keys: null
   )

   # @const {Object} - ключи доступа к различным группам фильтра.
   _FILTER_GROUP_NAMES: keyMirror(
      filter: null
      search: null
      marked: null
   )

   # @const {Object} - параметры для манипуляции пользовательскими фильтрами.
   _USER_FILTER_PARAMS:
      modelName: 'user_filter'
      dialogTitle: 'Введите название фильтра'
      # параметры для полей динамической формы создания/редактирования фильтра.
      fieldConstraints:
         [
            {
               name: 'model'
               parents: null
               isHidden: true
               strongValue: null
            },
            {
               name: 'filter'
               parents: null
               isHidden: true
               strongValue: null
            }
         ]
      # параметры для таблицы пользовательских фильтров.
      dataTableParams:
         dimension:
            dataContainer:
               width:
                  min: 500
         columnRenderParams:
            isStrongRenderRule: true
            columns: {
               name: {},
               description: {}
            }

   # @const {Object} - хэш возможных типов диалога взаимодейтсвия
   # TODO: рассмотреть необходимость переноса этих значений в модуль.
   _DIALOG_INTERACTION_TYPES: keyMirror (
      info: null
      error: null
      confirm: null
      put: null
   )

   # @const {Object} - константы для хранения режимов работы динамической формы.
   _DYNAMIC_FORM_MODES: keyMirror(
      update: null
      create: null
   )

   # @cosnt {String} - наименование поля построения иерархии.
   _PARENT_FIELD_NAME: 'parent_id'

   # @const {Object} - возможные префиксы для ссылок на элементы таблицы данных
   #                   (строки или узлы в зависимости от вида).
   _ROW_PREFIXES:
      flat: 'row'
      hierarchy: 'node'

   # @const {Object} - хэш с доп. ключами статистики по записям для иерархического
   #                   представления.
   _HIERARCHY_ENTRIES_STAT_KEYS: keyMirror(
      rootStart: null
      rootEnd: null
   )

   # @const {Object} - ключи считывания значений полного ответа.
   _RESPONSE_KEYS:
      json: 'json'
      errors: 'errors'
      jsonKeys: keyMirror(
         records: null
         paginateParams: null
         entityParams: null
      )

   # @const {Object} - параметры для работы с поисковым фильтром по-умолчанию.
   _SEARCH_FILTER_PARAMS:
      fieldsKey: 'fields'
      defaultFields:
         [ { names: 'all', affilation: null } ]

   # @const {Object} - ключи для считывания параметров ограничений для полей
   #                   динамической формы.
   _FIELD_CONSTRAINT_KEYS: keyMirror(
      fieldConstraints: null
      constraints: null
      prefixAnchors: null
   )

   # @const {Object} - ключи для считывания параметров данных таблицы
   _DATA_KEYS: keyMirror(
      entityParams: null
      records: null
      errors: null
      paginateParams: null
   )

   # @const {Object} - префиксы для формирования идентификаторов обработчиков на
   #                   изменение состояния хранилища.
   _CHANGE_EVENT_PREFIXES: keyMirror(
      custom: null
      massOperations: null
   )

   # @const {Object} - используемые символы.
   _CHARS:
      empty: ''
      comma: ','
      underscore: '_'

   # @const {Object} - набор используемых ссылок или префиксов ссылок
   #                   на элементы компонента.
   _REFS: keyMirror(
      toolbar: null
      operationsOrganizer: null
      operationDialog: null
      rows: null
      row: null
      node: null
      popupFlasher: null
      dataContainer: null
      notFoundNode: null
   )

   # @const {Object} - параметры для запроса файла экземпляра.
   _GET_INSTANCE_PARAMS:
      formats: keyMirror(
         xlsx: null
         json: null
      )
      method: 'show'

   # @const {Object} - набор свойств, получаемых из хранилища реализаций.
   _IMPLEMENTED_PROPS: keyMirror(
      modelParams: null
      columnRenderParams: null
      dimension: null
      styleAddition: null
      customRowOptions: null
      filterAdditionParams: null
      hierarchyViewParams: null
      objectCardParams: null
      enableRowDragAndDrop: null
      enableRowSelect: null
      enableRowOptions: null
      enableColumnsHeader: null
      enableExport: null
      isHasStripFarming: null
   )

   # @const {Object} - ключи, используемые в параметрах полей.
   _FIELD_KEYS: keyMirror(
      isPrimaryKey: null
   )

   # @const {Object} - маркеры, используемые в регулярных выражениях.
   _REGEXP_FLAGS:
      gi: 'gi'

   # @const {Object} - ключи параметров записи.
   _RECORD_KEYS: keyMirror(
      key: null
      fields: null
      reflections: null
      value: null
   )

   # @const {Object} - ключи параметров правил рендеров колонок.
   _RENDER_RULE_KEYS: keyMirror(
      caption: null
      style: null
      isHidden: null
      reflections: null
      onRenderCell: null
   )

   # @const {Object} - коды нажимаемых клавиш.
   _KEY_CODES:
      enter: 13
      left: 37
      up: 38
      right: 39
      down: 40

   # @const {Object} - цепи для взятия свойств из хэшей.
   _OBJECT_CHAINS:
      massOperationByEndpoint: [
         'contentParams'
         'dynamicParams'
         'customServiceFluxParams'
         'endpoint'
      ]

   # @const {Object} - параметры доп. кнопок для диалога операций
   _DIALOG_ADDITION_BUTTON_PARAMS:
      manual:
         key: 'manual'
         icon: 'book'
         isLink: true
         title: 'Открыть руководство'

   # @const {Object} - шаблон для параметров flux для использования
   #                   сервисной инфраструктуры flux (для динамических форм).
   _USE_SERVICE_FLUX_PATTERN:
      isUseServiceInfrastructure: true

   # @const {Object} - параметры для валидации при экспорте данных.
   _DATA_EXPORT_VALIDATION_PARAMS:
      caption: 'Ошибка экспорта данных'
      texts:
         wrongRecordOnFileCount: 'Некорректно задано количество записей на файл'

   # @const {String} - наименование поля идентификатора модели.
   _ID_FIELD_NAME: 'id'

   # @const {String} - ключ считывания разрешенных к редактированию связок.
   _DENY_TO_EDIT_REFLECTION: 'denyToEditReflections'

   # @const {String} - символ переноса строки (для формирования форматированных строк)
   _NEW_LINE_CHAR: '\n'

   # @const {String} - идентификатор выбранных строк (для отображения в уведомлениях)
   _ALL_MARKED_IDENTIFIER: 'все'

   # @const {Number} - максимальное кол-во, при котором разрешается вывод всех
   #                   записей на странице
   _TO_MANY_RECORDS_BORDER: 1000

   # {String} - идентификатор компонента (временная метка при монтировании)
   _componentIdentifier: null

   mixins: [HelpersMixin,
            HierarchyMixin.container.child,
            ImplementedPropReader]

   styles:
      common:
         width: '100%'
         fontSize: 14
         borderCollapse: 'collapse'
      tableFitToContainer:
         tableLayout: 'fixed'
      recordsNotFound:
         display: 'none'
         padding: _COMMON_PADDING
         margin: _COMMON_PADDING
         color: _COLORS.hierarchy3
      recordsNotFoundShown:
         display: ''
      dataContainer:
         paddingLeft: 1
         overflow: 'auto'
      complexDataTriggerContainer:
         padding: 2

   propTypes:
      recordsPerPage: React.PropTypes.number
      startPage: React.PropTypes.number
      viewType: React.PropTypes.oneOf(['flat', 'hierarchy', 'tree'])
      instanceID: React.PropTypes.oneOfType [
            React.PropTypes.string
            React.PropTypes.number
         ]
      recordsNotFoundText: React.PropTypes.string
      searchPlaceholder: React.PropTypes.string
      enableColumnsHeader: React.PropTypes.bool
      modelParams: React.PropTypes.object
      initData: React.PropTypes.object
      hierarchyViewParams: React.PropTypes.object
      dimension: React.PropTypes.object
      dataManipulationParams: React.PropTypes.object
      filterAdditionParams: React.PropTypes.object
      fluxParams: React.PropTypes.object
      reflectionRenderParams: React.PropTypes.object
      columnRenderParams: React.PropTypes.object
      massOperations: React.PropTypes.object
      createButtonParams: React.PropTypes.object
      filterButtonParams: React.PropTypes.object
      implementationStore: React.PropTypes.object
      isHasStripFarming: React.PropTypes.bool
      isFitToContainer: React.PropTypes.bool
      isRereadData: React.PropTypes.bool
      isFullyClientMode: React.PropTypes.bool
      isSuppressLargeTotalRecordsOutput: React.PropTypes.bool
      isPageSelectorInLinkMode: React.PropTypes.bool
      isUseImplementation: React.PropTypes.bool
      isImplementationHigherPriority: React.PropTypes.bool
      isMergeImplementation: React.PropTypes.bool
      isSearchDoOnClient: React.PropTypes.bool
      enableRowSelect: React.PropTypes.bool
      enableRowSelectByClick: React.PropTypes.bool
      enableRowOptions: React.PropTypes.bool
      enableCreate: React.PropTypes.bool
      enableDelete: React.PropTypes.bool
      enableEdit: React.PropTypes.bool
      enableFilter: React.PropTypes.bool
      enableUserFilters: React.PropTypes.bool
      enableSettings: React.PropTypes.bool
      enableExport: React.PropTypes.bool
      enableSearch: React.PropTypes.bool
      enablePerPageSelector: React.PropTypes.bool
      enableStatusBar: React.PropTypes.bool
      enableToolbar: React.PropTypes.bool
      enableLazyLoad: React.PropTypes.bool
      enableRowDragAndDrop: React.PropTypes.bool
      enableManuals: React.PropTypes.bool
      ManualViewer: React.PropTypes.func
      customRowOptions: React.PropTypes.array
      enableObjectCard: React.PropTypes.bool
      objectCardParams: React.PropTypes.object
      onRowClick: React.PropTypes.func
      onReady: React.PropTypes.func
      onKeyDown: React.PropTypes.func
      onSelectRow: React.PropTypes.func

   getDefaultProps: ->
      recordsPerPage: 15
      startPage: 1
      recordsNotFoundText: 'Нет записей'
      viewType: 'flat'
      hierarchyViewParams: {}
      initData: {}
      isHasStripFarming: true
      isFitToContainer: false
      isRereadData: false
      isFullyClientMode: false
      isPageSelectorInLinkMode: false
      isSuppressLargeTotalRecordsOutput: false
      isUseImplementation: false
      isImplementationHigherPriority: false
      isMergeImplementation: false
      isSearchDoOnClient: false
      enableColumnsHeader: true
      enableRowOptions: true
      enableRowSelect: false
      enableRowSelectByClick: false
      enableObjectCard: true
      enableCreate: true
      enableDelete: true
      enableEdit: true
      enableFilter: true
      enableUserFilters: false
      enableSettings: false
      enableExport: false
      enableSearch: true
      enablePerPageSelector: true
      enableStatusBar: true
      enableToolbar: true
      enableRowDragAndDrop: false
      enableLazyLoad: false
      enableManuals: false

   getInitialState: ->
      implementationProps: @_getImplementationProps()
      perPage: @props.recordsPerPage
      activePage: @props.startPage
      tableState: @_TABLE_STATES.init
      orderDirection: 'DESC'
      touchedRecordID: ''
      touchedNodePath: null
      touchedRow: null
      appliedMassOperation: null
      recordOperation: @_RECORD_OPERATIONS.none
      orderedField: ''
      filterParams: @props.filterParams || {}
      userFilters: {}
      tableData: []
      fieldParams: {}
      searchExpression: ''
      activityTarget: {}
      popupParams: @_getInitPopupFlashParams()
      dialogInteractionParams: @_getInitDialogInteractionParams()
      isAllRowsMarked: false
      isFilterChanged: false
      isDataExoprtAreaOpen: false
      isExportRequested: false
      isSettingsAreaOpen: false
      markedRows: {}
      markedNodes: {}
      complexDataParams: {}
      activeOperationsPanel: @_RECORDS_OPERATIONS.none

   componentWillReceiveProps: (nextProps) ->
      nextInstanceID = nextProps.instanceID
      nextFilter = nextProps.filterParams
      nextInitData = nextProps.initData
      modelParams = @_readModelParams()
      nextStartPage = nextProps.startPage
      nextModelParams = nextProps.modelParams
      isInstenceOther = nextInstanceID isnt @props.instanceID
      isFilterOther = nextFilter? and @_isFilterOther(nextFilter)
      isRereadDataNext = nextProps.isRereadData
      preparedTableState = {}
      paramsForRequest = {}

      # Считаем параметры модели, если они были заданы.
      if modelParams?
         model = modelParams.name
         modelRelations = modelParams.relations
         modelSubResource = modelParams.subResource

      if nextModelParams?
         nextModel = nextModelParams.name
         nextModelRelations = nextModelParams.relations
         nextModelSubResource = nextModelParams.subResource

      isModelOther = model isnt nextModel
      isModelRelationOther = !_.isEqual(modelRelations, nextModelRelations)
      isModelSubResourceOther = modelSubResource isnt nextModelSubResource

      # Переустановим новые начальные данные
      @_reinstallInitData(nextInitData)

      # Если был передан другой идентификатор экземпляра - перечитываем данные.
      if isInstenceOther
         paramsForRequest.instanceID = nextInstanceID

         preparedTableState =
            @mergeObjects(preparedTableState,
               isAllRowsMarked: false
               markedRows: {}
            )

      # Если фильтр был изменен отправляем запрос на считывание данных
      #  и устанавливаем флаг того, что фильтр был изменен.
      if isFilterOther
         paramsForRequest =
            @mergeObjects(paramsForRequest,
               activePage: 1
               newFilterParams: @_prepareFilter(nextFilter)
               isFilterConcat: false
            )

         preparedTableState.isFilterChanged = true

      # Если модель отличается - установим в параметры для начального запроса новую
      #  модель.
      if isModelOther
         paramsForRequest.model = nextModel

      # Если связки модели отличаются - установим в параметры для начального запроса
      #  новые параметры связки.
      if isModelRelationOther
         paramsForRequest.modelRelations = nextModelRelations

      if isModelSubResourceOther
         paramsForRequest.modelSubResource = nextModelSubResource

      if nextStartPage?
         paramsForRequest.activePage = nextStartPage

      isNeedReinitTable = isModelOther or
                          isModelRelationOther or
                          isModelSubResourceOther or
                          isInstenceOther or
                          isFilterOther or
                          isRereadDataNext

      # Если какой-либо флаг, идентифицирующих, что были изменены
      #  параметры для отображения данных таблицы установлен - отправляем
      #  инициирующий запрос данных, перечитыавем параметры реализации.
      if isNeedReinitTable
         @_sendInitRequest paramsForRequest
         @_rereadImplementationProps(nextProps)

      @setState preparedTableState

      # if nextSearchString isnt @props.searchString
      #    @_doSearch nextSearchString

   componentWillUpdate: (nextProps, nextState) ->
      nextTableData = nextState.tableData
      nextInitData = nextProps.initData
      nextActivePage = nextState.activePage
      nextFilterParams = nextState.filterParams
      nextRecordOperation = nextState.recordOperation
      currentRecordOperation = @state.recordOperation
      isActivePageChanged = nextActivePage isnt @state.activePage
      isFilterChanged = nextFilterParams isnt @state.filterParams

      # Если поменялась текущая активная страница и компонент не в режиме работы
      #  полностью на клиента, то отправляем запрос на получение данных.
      if isActivePageChanged and !isFilterChanged and !nextProps.isFullyClientMode
         @_sendInitRequest(
            activePage: nextActivePage
            perPage: nextState.perPage
         )

      # Если изменились данные таблицы - выполним переопределение выбранных строк.
      unless _.eq(nextTableData, @state.tableData)
         @_definedMarkedRows nextTableData

      # # Если задана текущая применанная массовая операция и при этом изменилась
      # #  примененная операция над записью - сбрасываем примененную массовую операцию.
      # if @state.appliedMassOperation? and
      # !_.eq(nextRecordOperation, currentRecordOperation)
      #    @setState appliedMassOperation: null

      @_reinstallInitData(nextInitData)

   render: ->
      refs = @_REFS
      isRequesting = @state.tableState is @_TABLE_STATES.requesting

      `(
         <div style={this._getCommonStyle()}>
            {this._getToolbar()}
            {this._getComplexDataTrigger()}
            <div style={this._getNotFoundStyle()}
                 ref={refs.notFoundNode}>
               {this.props.recordsNotFoundText}
            </div>
            <div style={this._getDataContainerStyle()}
                 ref={refs.dataContainer}
                 tabIndex={0}
                 onScroll={this._onScrollDataWrapper}
                 onClick={this._onClickDataContainer}
                 onKeyDown={this._onKeyDownDataContainer}
               >
               {this._getDataTableContent()}
            </div>
            <AjaxLoader isShown={isRequesting}
                        target={this.state.activityTarget} />
            <PopupFlasher ref={refs.popupFlasher}
                          flash={this.state.popupParams}
                          target={this.state.activityTarget}
                          enableShowIdentifier={true}
                          onHide={this._onHidePopupFlash}
                        />
            {this._getStatusBar()}
            {this._getOperationContent()}
            {this._getSettingsArea()}
            {this._getExportArea()}
            {this._getOperationsOrganizer()}
            {this._getManualViwer()}
            <DialogInteraction {...this.state.dialogInteractionParams}
                               onHide={this._onHideDialogInteraction} />
         </div>
      )`

   componentDidUpdate: (prevProps, prevState) ->
      if @state.tableState is @_TABLE_STATES.dataReceived
         @setState
            tableState: @_TABLE_STATES.dataRendered
            activityTarget: @refs.dataContainer

      popupParams = @state.popupParams
      isPopupParamsExist = popupParams? and !_.isEmpty(popupParams)
      isHasPopupText = isPopupParamsExist and popupParams.text

      # Если заданы параметры всплывающего уведомления - очистим, чтобы они больше не
      #  попадали в компонент мгновенных уведомлений - PopupFlasher.
      if isPopupParamsExist and isHasPopupText
         @setState popupParams: @_getInitPopupFlashParams()

   componentDidMount: ->
      fluxParams = @props.fluxParams
      isHasFluxParams = @_isHasFluxParams()
      isUseServiceFlux = @_isUseServiceFlux()
      isHasInitData = @_isHasInitData()

      preparedTableState =
         activityTarget: @refs.dataContainer

      # Создадим идентификатор компонента.
      @_componentIdentifier = Date.now()

      # Если заданы начальные данные - считываем их для дальнейшей установки
      #  их в состояния компонента без запроса в API.
      # Иначе, если задан флаг использования сервисной инфраструктуры - подписываемся
      #  на изменение сервисной инфраструктуры и отправляем запрос данных.
      # Иначе, если заданы параметры flux - отправляем запрос с подготовленными
      #  параметрами.
      # Иначе выдаем предупреждения, что для таблицы не заданы необходимые
      #  параметры получения данных.
      if isHasInitData
         addons = React.addons
         preparedTableState =
            addons.update(preparedTableState,
                          { $merge: @_getTableDataFromInitData() })
         @_readyHandler(preparedTableState.tableData)
      else if isUseServiceFlux
         ServiceStore.addChangeListener @_onChangeService
         @_sendInitRequest()
      else if isHasFluxParams
         fluxParams.store.addChangeListener @_onChange
         paramsForRequest =
            newFilterParams: @_prepareFilter(@props.filterParams)

         @_sendInitRequest(paramsForRequest)
      else
         log.warn(@_MESSAGES.errors.initDataOrFluxNotSet)

      # Подпишемся на пользователськие обработчики.
      @_subscriptionToCustomEvents()

      @setState preparedTableState

   componentWillUnmount: ->
      fluxParams = @props.fluxParams
      isHasFluxParams = @_isHasFluxParams()
      isUseServiceFlux = @_isUseServiceFlux()

      if isUseServiceFlux
         ServiceStore.removeChangeListener @_onChangeService
      else if isHasFluxParams
         store = fluxParams.store
         store.removeChangeListener @_onChange if store?

      # Запустим функцию удаления ссылки на элемент в органайзере операций
      #  (если он был задан).
      @_participateInToOrganizer(true)

      # Отпишемся от пользовательских обработчиков.
      @_subscriptionToCustomEvents true

   ###*
   * Функция получения записи по ключу.
   *
   * @param {String} key - искомый ключ.
   * @return {Object}    - хэш с параметрами записи.
   ###
   getRecord: (key) ->
      tableData = @state.tableData

      if tableData? and !_.isEmpty tableData
         if @props.viewType is @_TABLE_VIEW_TYPES.flat
            @_getRecordFromRecordsByKey(tableData, key)
         #    for field in @state.tableData
         #       return field if field.key is key
         else
            @_serachInHierarchy(key: key)

   ###*
   * Функция получения записи в ирерархии по ключу-пути к узлу.
   *
   * @param {String} nodePathKey  - искомый ключ записи в иерархии.
   * @param {String} isWithParent - флаг выбора записи вместе с родительской.
   * @return {Object}            - хэш с параметрами записи.
   ###
   getRecordFromHierarchy: (nodePathKey, isWithParent) ->
      @_serachInHierarchy(
         isWithParent: isWithParent,
         targetKeyPath: nodePathKey.split(@_CHARS.comma)
      )

   ###*
   * Функция получения набора записей - иерархического пути по заданным ключам
   *  узлов. То есть при входном параметре [1, 7, 12] будет возвращен массив записей
   *  из иерархии в том же порядке [{..., key: 1}, {..., key: 7}, {..., key: 12}]
   *
   * @param {String} nodePath - путь в иерархии до узла.
   * @return {Array<Object>} - набор записей
   ###
   getHierarchicalRecordsChain: (nodePath) ->
      currentLevelRecords = @state.tableData

      if currentLevelRecords? and (nodePath? and !_.isEmpty(nodePath))
         pathChain = []

         for nodeKey in nodePath
            currentRecord = @_getRecordFromRecordsByKey(currentLevelRecords,
                                                        nodeKey)
            if currentRecord?
               pathChain.push(currentRecord)
               currentLevelRecords = currentRecord.childs
            else
               break

         pathChain

   ###*
   * Функция получения набора выбранных записей. Для обычного вида и
   *  иерархического в виде дерева по-разному выбирает записи.
   *
   * @param {Object} markedCollectionParams - параметры "выбранности" для элементов.
   *                                          Если параметр не задан данный параметр берется
   *                                          из состояний (@state.markedRows или @state.markedNodes)
   * @param {Boolean} isWithParent          - флаг выбора родительских записей вместе с основной записью.
   *                                          Параметр актуален для иерархических представлений.
   * @return {Array}    - коллекция выбранных записей.
   ###
   getSelectedRecords: (markedCollectionParams, isWithParent) ->

      ###*
      * Функция выбора только отмеченных элементов в коллекции. Возвращает
      *  идентификаторы элементов коллекции(ключей записей, или пути узла иерархии).
      *
      * @param {Object} collection - целевая коллекция для выбора.
      * @return {Array, undefined} - набор выбранных идентификаторов.
      ###
      getOnlyMakred = (collection) ->
         if collection? and !_.isEmpty collection
            onlyMarked = []

            for collectionElementKey, isMarked of collection
               onlyMarked.push(collectionElementKey) if isMarked

            onlyMarked

      if @_isTree()
         markedCollection = markedCollectionParams or @state.markedNodes
         recordGetter = @getRecordFromHierarchy
      else
         markedCollection = markedCollectionParams or @state.markedRows
         recordGetter = @getRecord

      getOnlyMakred(markedCollection).map (key) ->
         recordGetter(key, isWithParent)

   ###*
   * Функция получения ссылки на элемент строки таблицы данных.
   *
   * @param {String, Number} rowKey - обновляемая запись.
   * @return {React-element} - ссылка на элемент.
   ###
   getRowElement: (rowKey) ->
      @_getRowByKey(rowKey)

   ###*
   * Функция обновления параметров записи в наборе данных таблицы.
   *
   * @param {Object} refreshedRecord - обновляемая запись.
   * @return {Object}    - хэш с параметрами записи.
   ###
   refreshRecord: (refreshedRecord) ->

      if refreshedRecord? and !_.isEmpty refreshedRecord
         clonedTableData = _.cloneDeep(@state.tableData)
         refreshedRecordIdx =
            _.findIndex(clonedTableData, [@_RECORD_KEYS.key, refreshedRecord.key])

         if refreshedRecordIdx?
            clonedTableData[refreshedRecordIdx] = refreshedRecord
            delete clonedTableData[refreshedRecordIdx].isFailed
            dataTable = this

            dataTable.setState tableData: clonedTableData

   ###*
   * Функция передачи управления вводом с клавиатуры на содержимое таблицы.
   *  устанавливает первую запись из набора активированной (если нет текущей
   *  активированной) и устанавливает фокус на контейнер данных для манипуляций
   *  с клавиатуры.
   *
   * @return
   ###
   initKeyManipulation: ->
      touchedRecordID = @state.touchedRecordID

      unless touchedRecordID
         tableData = @state.tableData
         if tableData?
            @setState touchedRecordID: tableData[0].key

      @_focusOnDataContainer()

   ###*
   * Функция получения экземпляра текущей активированной строки.
   *
   * @return {React-element}
   ###
   getActivatedRow: ->
      @_getActivatedRow()

   ###*
   * Функция ключа текущей активированной строки.
   *
   * @return {React-element}
   ###
   getActivatedRowKey: ->
      @state.touchedRecordID

   ###*
   * Функция формирования представлений записей в таблице данных.
   *  В зависимости от типа представления таблицы формирует различный вид таблицы.
   *
   * @return {React-element} - представление записей таблицы.
   ###
   _getDataTableContent: ->
      tableViewTypes = @_TABLE_VIEW_TYPES
      tableViewType = @props.viewType
      tableData = @state.tableData
      isFlat = tableViewType is tableViewTypes.flat
      isHierarchy = tableViewType is tableViewTypes.hierarchy
      isTree = tableViewType is tableViewTypes.tree
      rowRef = @_REFS.rows
      tableElementNames = @_TABLE_ELEMENTS

      if tableData? and tableData.length
         if isFlat
            rowsProps = @_getElementProps(tableElementNames.DataTableRows)

            `(<table style={this._getComputedStyleDataTable()}
                     cellPadding='0' >
               {this._getTableColumnsHeader()}
               <DataTableRows ref={rowRef}
                              {...rowsProps}
                              rowsData={tableData}
                              markedRows={this.state.markedRows}
                              selectedRecordID={this.state.touchedRecordID}
                              matchExpression={this.state.searchExpression}
                              isAllMarked={this.state.isAllRowsMarked}
                              enableEdit={this.props.enableEdit}
                              enableDelete={this.props.enableDelete}
                              recordOperations={this._RECORD_OPERATIONS}
                              recordKeys={this._RECORD_KEYS}
                              renderRuleKeys={this._RENDER_RULE_KEYS}
                              getEntityParams={this._getEntityParams}
                              getModelParams={this._getModelParams}
                              getInstance={this._getRecordInstance}
                              getRecordReflectionParams={this._getRecordReflectionParams}
                              onRefreshRecord={this._onRefreshRecord}
                              onClick={this._onRowClick}
                              onRowSelect={this._onRowSelect}
                              onRowOptionClick={this._onRowOptionClick}
                              onRowDragAndDropTerminate={this._onRowDragAndDropTerminate} />
            </table>)`
         else if isTree or isHierarchy
            hierarchyRowsProps =
               @_getElementProps(tableElementNames.DataTableHierarchyView)

            `(<DataTableHierarchyView ref={rowRef}
                                 {...hierarchyRowsProps}
                                 rowsData={tableData}
                                 type={tableViewType}
                                 activePage={this.state.activePage}
                                 matchExpression={this.state.searchExpression}
                                 markedNodes={this.state.markedNodes}
                                 enableEdit={this.props.enableEdit}
                                 enableDelete={this.props.enableDelete}
                                 isAllMarked={this.state.isAllRowsMarked}
                                 isFilterApply={this._isFilterApplied()}
                                 selectedNodePath={this.state.touchedNodePath}
                                 onSelectNode={this._onRowSelect}
                                 onClickNode={this._onRowClick}
                                 onClickNodeOption={this._onRowOptionClick}
                                 onHierarchyNavigate={this._onHierarchyNavigate} />)`

   ###*
   * Функция получения панели действий.
   *  по записям.
   *
   * @return {React-element, undefined} - панель действий.
   ###
   _getToolbar: ->
      if @props.enableToolbar
         implementedProps = @_IMPLEMENTED_PROPS
         fluxParams = @props.fluxParams
         fluxParamsUserFilters = fluxParams.userFilters if fluxParams?
         tableElementNames = @_TABLE_ELEMENTS
         toolbarProps = @_getElementProps(tableElementNames.DataTableToolbar)

         #filterAdditionParams={this.props.filterAdditionParams}

         `(
            <DataTableToolbar {...toolbarProps}
                              ref={this._REFS.toolbar}
                              enableCreate={this.props.enableCreate}
                              enableFilter={this.props.enableFilter}
                              enableSearch={this.props.enableSearch}
                              enablePerPageSelector={this.props.enablePerPageSelector}
                              enableRowSelect={this.props.enableRowSelect}
                              enableUserFilters={this.props.enableUserFilters}
                              enableSettings={this.props.enableSettings}
                              isUseImplementation={this.props.isUseImplementation}
                              isMergeImplementation={this.props.isMergeImplementation}
                              isSuppressAllRecordsSelector={this._isSuppressAllRecordsSelector()}
                              isExportRequested={this.state.isExportRequested}
                              createButtonParams={this.props.createButtonParams}
                              filterButtonParams={this.props.filterButtonParams}
                              implementationStore={this.props.implementationStore}
                              dataManipulationParams={this.props.dataManipulationParams}
                              reflectionRenderParams={this.props.reflectionRenderParams}
                              fluxParamsUserFilters={fluxParamsUserFilters}
                              recordsPerPage={this.props.recordsPerPage}
                              recordsOperations={this._RECORDS_OPERATIONS}
                              markedRowsStatistic={this._getMarkedStatistic()}
                              filterParams={this.state.filterParams}
                              massOperations={this.props.massOperations}
                              entityParams={this.state.entityParams}
                              userFilterParams={this._USER_FILTER_PARAMS}
                              userFilters={this.state.userFilters}
                              searchPlaceholder={this.props.searchPlaceholder}
                              isHierarchicallyViewTable={this._isHierarchicallyViewTable()}
                              filterFlags={
                                 {
                                    isComplex: this._isComplexFilterApplied(),
                                    isMarked: this._isMarkedFilterApplied(),
                                    isSearch: this._isSearchFilterApplied(),
                                    isUser: this._isUserFilterApplied()
                                 }
                              }
                              isAllRowsMarked={this.state.isAllRowsMarked}
                              onSearch={this._onSearch}
                              onClearSearch={this._onClearSearch}
                              onClickNewRecord={this._onClickNewRecord}
                              onChangePerPage={this._onChangePerPage}
                              onAfterTriggerPanel={this._onAfterTriggerPanel}
                              onApplyFilter={this._onApplyFilter}
                              onClickOperation={this._onClickMassOperation}
                              onClickSelectAll={this._onClickSelectAll}
                              onClickUserFilter={this._onClickUserFilter}
                              onAfterReceiveFilters={this._onAfterReceiveFilters}
                              onAfterCreateFilter={this._onAfterCreateFilter}
                              onAfterUpdateFilter={this._onAfterUpdateFilter}
                              onAfterDeleteFilter={this._onAfterDeleteFilter}
                              onClickDataExportTrigger={this._onClickDataExportTrigger}
                              onClickSettingsTrigger={this._onClickSettingsTrigger}
                           />
            )`


   ###*
   * Функция получения переключателей составных данных(то, есть если результатом
   *  считывания было несколько разнородных данных, то необходим переключатель между
   *  этими данными).
   *
   * @return {React-element, undefined}
   ###
   _getComplexDataTrigger: ->
      complexDataParams = @state.complexDataParams

      if complexDataParams? and !_.isEmpty complexDataParams
         buttons = []
         complexDataActive = complexDataParams.activeDataName
         complexDataCollection = complexDataParams.collection

         # Формируем переключатели сложных данных, если в составных данных
         #  больше одного набора.
         if Object.keys(complexDataCollection).length > 1
            for dataName, params of complexDataCollection
               isActive = dataName is complexDataActive

               if params.data?
                  buttons.push(
                     caption: params.caption
                     isActive: isActive
                     value: dataName
                  )

            if buttons.length > 1
               `(
                  <div style={this.styles.complexDataTriggerContainer}>
                     <ButtonGroup buttons={buttons}
                                  onClickButton={this._onClickComplexDataSelector} />
                  </div>
                )`

   ###*
   * Функция формирования компонента-заголовка таблицы с наименованиями колонок.
   *  Компонент будет сформирован только если разрешен показ заголовка таблицы.
   *
   * @return {React-element, undefined}
   ###
   _getTableColumnsHeader: ->
      headerProps = @_getElementProps(@_TABLE_ELEMENTS.DataTableHeader)

      if headerProps.enableColumnsHeader
         delete headerProps.enableColumnsHeader

         `(
            <DataTableHeader {...headerProps}
                             columns={this._getRenderedColumns()}
                             onColumnHeaderClick={this._onColumnHeaderClick}
                             orderParams={
                                { column: this.state.orderedField,
                                  direction: this.state.orderDirection }}
                             isAllRowsMarked={this.state.isAllRowsMarked}
                             onClickSelectAll={this._onClickSelectAll} />
         )`


   ###*
   * Функция получения строки статуса таблицы с постраничной навигацией и статисткиой
   *  по записям.
   *
   * @return {React-element, undefined} - строка статуса.
   ###
   _getStatusBar: ->
      if @props.enableStatusBar
         `(
            <DataTableStatusBar activePage={this.state.activePage}
                                tableViewType={this.props.viewType}
                                tableViewTypes={this._TABLE_VIEW_TYPES}
                                paginateParams={this.state.paginateParams}
                                enableLazyLoad={this.props.enableLazyLoad}
                                isPageSelectorInLinkMode={this.props.isPageSelectorInLinkMode}
                                onPageSelect={this._onPageSelect} />
          )`

   ###*
   * Функция формирования области настроек таблицы.
   *
   * @return {React-element}
   ###
   _getExportArea: ->
      if @props.enableExport
         `(
            <DataTableExport target={this.state.isDataExoprtAreaOpen ?
                                     this.refs[this._REFS.toolbar] :
                                     null}
                             isRequested={this.state.isExportRequested}
                             onHide={this._onHideDataExportArea}
                             onExport={this._onExportData}
                          />
          )`
   ###*
   * Функция получения области настроек таблицы.
   *
   * @return {React-element}
   ###
   _getSettingsArea: ->
      if @props.enableSettings

         `(
            <DataTableSettings target={this.state.isSettingsAreaOpen ?
                                       this.state.activityTarget :
                                       null}
                               userFilters={this.state.userFilters}
                               userFilterParams={this._USER_FILTER_PARAMS}
                               fluxParams={this.props.fluxParams}
                               onHide={this._onHideSettingsArea}
                            />
          )`

   ###*
   * Функция получения органайзера операций над записями. Если ссылка на органайзер
   *  не была задана через свойства, то создает новый экземпляр.
   *
   * @return {React-element}
   ###
   _getOperationsOrganizer: ->
      unless @props.operationsOrganizer?
         `(
             <DataTableOperationsOrganizer ref={this._REFS.operationsOrganizer}
                                        />
          )`

   ###*
   * Функция создания экземпляра карточки объекта с отображением информации по
   *  выбранной записи.
   *
   * @param {String} recordID - идентификатор записи.
   * @return {React-element} - карточка объекта
   ###
   _getObjectCard: (recordID) ->
      touchedElementName = @_getTouchedElementName()

      objectCardTarget = @refs.rows.refs[touchedElementName]
      objectCardParams = @_getComponentProp(@_IMPLEMENTED_PROPS.objectCardParams)
      targetRecord = @getRecord(recordID)
      modelParams = @_readModelParams()
      dataManipulationParams = @props.dataManipulationParams

      if objectCardParams?
         formatRules = objectCardParams.formatRules
         customActions = objectCardParams.customActions
         operationParams = objectCardParams.operationParams
         isDisplayReflections = objectCardParams.isDisplayReflections
         isFreezeAtInteraction = objectCardParams.isFreezeAtInteraction
         maxDataTabCountPerLine = objectCardParams.maxDataTabCountPerLine

      # Если таблица работает с представлением базы данных, то необходимо
      #  переопределить модель для записи.
      if modelParams.view? and modelParams.view is _.snakeCase(targetRecord.model)
         targetRecord.model = modelParams.name

      `(
         <ObjectCard record={targetRecord}
                     parentModelParams={this.props.modelParams}
                     processedFields={this._getRenderedColumns()}
                     areaParams={
                        {
                           target: objectCardTarget,
                           isCatchFocus: true
                        }
                     }
                     dataManipulationParams={dataManipulationParams}
                     formatRules={formatRules}
                     customActions={customActions}
                     operationParams={operationParams}
                     implementationStore={this.props.implementationStore}
                     isUseImplementation={this.props.isUseImplementation}
                     isMergeImplementation={this.props.isMergeImplementation}
                     isDisplayReflections={isDisplayReflections}
                     isFreezeAtInteraction={isFreezeAtInteraction}
                     maxDataTabCountPerLine={maxDataTabCountPerLine}
                     enableEdit={this.props.enableEdit}
                     enableDelete={this.props.enableDelete}
                     enableManual={this.props.enableManuals}
                     onClickOpenManual={this._onClickOpenManual}
                     enableExport={this.props.enableExport}
                     onHide={this._onHideObjectCard}
                  />
      )`

   ###*
   * Функция формирования экземпляра компонента просмотрщика руководств. Формирует
   *  экземпляр компонента, если задан класс просмотрища и задана текущая активная
   *  цепь-путь до руководства.
   *
   * @return {React-element} - Просмотрщик мануалов.
   ###
   _getManualViwer: ->
      ManualViewer = @props.ManualViewer
      activatedManualPathParams = @state.activatedManualPathParams

      if ManualViewer? and activatedManualPathParams?
         `(
            <ManualViewer manualPathParams={activatedManualPathParams}
                          isShown={true}
                          onHide={this._onHideManualViewer}
                        />
          )`

   ###*
   * Функция отправки запроса в БЛ на получение экземпляра записи в различных
   *  форматах (пока отправка жестко идет для формата xlsx - если потребуется
   *  другой формат нужна доработка).
   *
   * @param {String} recordKey - ключ записи, по которой запрашивается экземпляр
   * @param {Object} params    - параметры запроса.
   * @return
   ###
   _getRecordInstance: (recordKey, params) ->
      fluxParams = @props.fluxParams
      modelParams = @_readModelParams()
      getInstanceParams = @_GET_INSTANCE_PARAMS

      if modelParams?
         modelRelations = modelParams.relations
         model = modelParams.name

      getInstanceHandler =
         if fluxParams.isUseServiceInfrastructure
            ServiceActionCreators.dataRequest
         else
            fluxParamsGetInstance = fluxParams.instance

      if getInstanceHandler?
         paramsForRequest =
            requestData:
               relations: params
            instanceID: recordKey
            componentID: @_componentIdentifier
            model: model
            format: getInstanceParams.formats.xlsx
            isFileRequest: true
            APIMethod: getInstanceParams.method

         getInstanceHandler paramsForRequest
      else
         log.warn(@_MESSAGES.errors.flux.getInstanceNotSet)

   ###*
   * Функция получения контента в зависимости от текущего действия над записями.
   *  Создает динамическую форму в зависимости от параметров, переданных для
   *  различных действий над записями.
   *
   * @return {React-element, undefined} - контент для текущей операции над записями.
   ###
   _getOperationContent: ->
      recordOperation = @state.recordOperation
      appliedMassOperation = @state.appliedMassOperation
      ManualViewer = @props.ManualViewer
      isHasRecordOperation = recordOperation? and
                             (recordOperation isnt @_RECORD_OPERATIONS.none)
      isHasMassOperation = appliedMassOperation? and !_.isEmpty(appliedMassOperation)
      isMassOperationSelected = !isHasRecordOperation and isHasMassOperation
      refs = @_REFS

      # Параметры операции берем по приоритету - сначала операция над записью
      #  (если задана), затем если задана примененная массовая операция над записями.
      operation =
         if isHasRecordOperation
            recordOperation
         else if isHasMassOperation
            appliedMassOperation

      # Если операция задана - формируем содержимое операции (для стандартной
      #  или пользовательской операций).
      if operation?
         recordID = @state.touchedRecordID
         modelParams = @_readModelParams()
         dialogParams = @_DIALOG_DATA_MANIPULATION_PARAMS
         recordsOperations = @_RECORD_OPERATIONS
         isStandardOperation = _.has(recordsOperations, operation)
         isDialogOperation = true
         dialogTitle = ''
         formSubmitCaption = ''
         formResetCaption = ''
         fluxParams = {}

         if modelParams?
            modelRelations = modelParams.relations
            model = modelParams.name

         # Для стандартных опций создаем динамическую форму.
         # Для пользовательских действий - создаем статическую форму или динамическую
         #  форму(для диалоговых опций) или отправляем запрос в зависимости
         #  от заданных параметров операции.
         if isStandardOperation
            propsFluxParams = @props.fluxParams
            dataManipulationParams = @props.dataManipulationParams
            createOperation = recordsOperations.create
            updateOperation = recordsOperations.update
            isHasDataManipulationParams = dataManipulationParams?

            # Если заданы параметры манипуляции данными - считываем
            #  для дальнейшей передачи в динамическую форму.
            if isHasDataManipulationParams
               enableMainManual = dataManipulationParams.enableMainManual
               enableReflectionManuals = dataManipulationParams.enableReflectionManuals
               enableConstructPresetParams = dataManipulationParams.enableClientConstruct
               reflectionParams = dataManipulationParams.reflectionParams
               fieldConstraints = dataManipulationParams.fieldConstraints
               sectionsOrder = dataManipulationParams.sectionsOrder
               fieldsOrder = dataManipulationParams.fieldsOrder
               additionalValidationParams = dataManipulationParams.additionalValidationParams
               externalEntitiesParams = dataManipulationParams.externalEntitiesParams
               hierarchyBreakParams = dataManipulationParams.hierarchyBreakParams

            methodParams = {}

            # Для различных операций подготавливаем различные данные:
            #  создание, обновление - подготавливаем данные для динамических форм и диалогов,
            #  для удаления - отправляем запрос на удаление.
            #  Если это операция просмотра - то это уже не диалоговая операция.
            switch operation
               when createOperation
                  createParams = dialogParams.new
                  dialogTitle = createParams.title
                  formSubmitCaption = createParams.submitCaption
                  formResetCaption = createParams.resetCaption
                  fluxParams = propsFluxParams.create if propsFluxParams?

                  if isHasDataManipulationParams
                     methodParams = dataManipulationParams.create

               when updateOperation
                  updateParams = dialogParams.update
                  dialogTitle = updateParams.title
                  formSubmitCaption = updateParams.submitCaption
                  formResetCaption = updateParams.resetCaption
                  fluxParams = propsFluxParams.update if propsFluxParams?

                  if isHasDataManipulationParams
                     methodParams = dataManipulationParams.edit
               else
                  isDialogOperation = false

            if isDialogOperation
               if propsFluxParams? and !_.isEmpty(propsFluxParams)
                  fluxParams ||= {}

                  fluxParams.store = propsFluxParams.store
                  fluxParams.isUseServiceInfrastructure =
                     propsFluxParams.isUseServiceInfrastructure

               processedConstraints = @_prepareFieldConstraints(fieldConstraints,
                                                                methodParams)
               denyToEditReflections = @_prepareDenyToEdit(methodParams)
               denyReflections = methodParams.denyReflections if methodParams?

               # Подготавливаем предустановленные данные для формы только если
               #  был задан флаг разрешения формирования предустановленных параметров
               #  на клиенте.
               presetParams =
                  if enableConstructPresetParams
                     @_preparePresetParams
                        methodParams: methodParams
                        recordKey: recordID

               # Если заданы параметры связки, то изменяем индекс последнего элемента на
               #  идентификатор выбранной записи.
               if modelRelations? and modelRelations.length
                  modelRelations[modelRelations.length - 1].recordKey =
                     recordID
                  modelParams.relations = modelRelations


               # manipulationParams={manipulationParams}
               #

               # Определим параметры для кнопок действия формы.
               actionButtonParams = @_DYNAMIC_FORM_ACTION_PARAMS
               actionButtonParams.submit.caption = formSubmitCaption
               actionButtonParams.reset.caption = formResetCaption

               operationContent =
                  `(<DynamicForm actionButtonParams={actionButtonParams}
                                 mode={operation}
                                 modelParams={modelParams}
                                 ManualViewer={ManualViewer}
                                 enableManuals={enableReflectionManuals}
                                 organizer={this._getOperationsOrganizerRef()}
                                 container={this.refs[refs.operationDialog]}
                                 updateIdentifier={recordID}
                                 rootIdentifier={this.props.instanceID}
                                 fieldConstraints={processedConstraints}
                                 denyToEditReflections={denyToEditReflections}
                                 denyReflections={denyReflections}
                                 reflectionParams={reflectionParams}
                                 additionalValidationParams={additionalValidationParams}
                                 presetParams={presetParams}
                                 sectionsOrder={sectionsOrder}
                                 hierarchyBreakParams={hierarchyBreakParams}
                                 externalEntitiesParams={externalEntitiesParams}
                                 fieldsOrder={fieldsOrder}
                                 fluxParams={fluxParams}
                                 reflectionRenderParams={this.props.reflectionRenderParams}
                                 implementationStore={this.props.implementationStore}
                                 isUseImplementation={this.props.isUseImplementation}
                                 isMergeImplementation={this.props.isMergeImplementation}
                                 isImplementationHigherPriority={this.props.isImplementationHigherPriority}
                                 onAfterGetResponse={this._onAfterGetResponseDynamicForm}
                                 onClickOpenManual={this._onClickOpenManual}
                              />)`

            else if operation is @_RECORD_OPERATIONS.view and @props.enableObjectCard
               operationContent = @_getObjectCard(recordID)

         # Если это пользовательская опция и это хэш параметров опции - продолжим.
         else if _.isPlainObject(operation)
            customContentParams = operation.contentParams
            isDialogOperation = customContentParams?

            if isMassOperationSelected
               accompanyingData = @_getAccompanyingDataForMassOperation()
            else
               instanceID = recordID

            # Для диалоговой операции создадим диалоговое окно с наполнением.
            if isDialogOperation
               customOperationParams =
                  @_getCustomDialogOperationParams(operation,
                                                   modelParams,
                                                   instanceID,
                                                   accompanyingData)
               operationContent = customOperationParams.content
               dialogTitle = customOperationParams.title

         if isDialogOperation
            additionFunctionalButtons =
               @_getDialogAdditionFunctionalButton(operation)

            `(
               <Dialog ref={refs.operationDialog}
                       isShown={true}
                       isModal={true}
                       isMovable={true}
                       caption={dialogTitle}
                       content={operationContent}
                       customFunctionalButtons={additionFunctionalButtons}
                       onHide={this._onHideDialogOperations}
                     />
            )`
         else
            operationContent

   ###*
   * Функция формирования доп. кнопок для диалога операций над записями. Возможные
   *  доп. кнопки:
   *    - кнопка открытия руководства.
   *
   * @param {String} operation - наименование операции.
   * @return {Array<React-element>, undefined}
   ###
   _getDialogAdditionFunctionalButton: (operation) ->
      dialogAdditionButtonParams = @_DIALOG_ADDITION_BUTTON_PARAMS
      functionalButtons = []

      ###* Функция формирования кнопки с заданными параметрами.
      *
      * @param {Object} params - параметры кнопки.
      * @return {React-element}
      ###
      getAdditionButton = ((params) ->
         `(
            <Button {...params} />
          )`
      ).bind(this)

      if @props.enableManuals
         manualButtonParams = _.clone(dialogAdditionButtonParams.manual)
         manualButtonParams.value = action: operation
         manualButtonParams.onClick = @_onClickOpenManual

         functionalButtons.push(getAdditionButton(manualButtonParams))

      functionalButtons

   ###*
   * Функция формирования параметров для пользовательской операции над записью
   *  или массовой операции над выбранными записями.
   *
   * @param {Object} operationParams  - параметры операции.
   * @param {Object} modelParams      - параметры модели.
   * @param {Number, Stirng} recordID - ключ записи.
   * @param {Object} accompanyingData - "сопутствующие" данные для операции.
   *                                       данные передаются в компоненты формы,
   *                                       для дальнейшей передачи на бизнес-логику.
   * @return {Object} - параметры:
   *        {React-element} content - содержимое диалога операции.
   *        {String} title          - заголовок диалога.
   ###
   _getCustomDialogOperationParams: (operationParams, modelParams, recordID, accompanyingData)->
      customContentParams = operationParams.contentParams
      customModelName = customContentParams.model
      clarificationParams = customContentParams.clarificationParams
      fluxParams = operationParams.fluxParams
      fieldParams = customContentParams.fields
      dynamicParams = customContentParams.dynamicParams

      if customModelName?
         modelParams.name = customModelName

      content =
         # Если заданы параметры полей - создаем статическую форму.
         if fieldParams?
            `( <StaticForm modelParams={modelParams}
                           fields={fieldParams}
                           recordID={recordID}
                           fluxParams={fluxParams}
                           accompanyingRequestData={accompanyingData}
                        /> )`

         # Если заданы параметры динамического содержимого - создаем динамическую форму.
         else if (dynamicParams? and !_.isEmpty dynamicParams) or fluxParams?

            if dynamicParams?
               reflectionsChain = dynamicParams.reflectionsChain
               presetParams = @_preparePresetParams(
                     recordKey: recordID
                     methodParams: dynamicParams
                     reflectionsChain: reflectionsChain
                  )
               isUseImplementation = dynamicParams.isUseImplementation
               customServiceFluxParams = dynamicParams.customServiceFluxParams
               onChangeFieldHandler = dynamicParams.onChangeField
               onClearFieldHandler = dynamicParams.onClearField
               onReadyHandler = dynamicParams.onReady
               onInitFieldHandler = dynamicParams.onInitField
               onDestroyHandler = dynamicParams.onDestroyField
               reflectionToMain = dynamicParams.reflectionToMain
               additionFormParams = dynamicParams.additionFormParams

            dfFluxParams = fluxParams or @_USE_SERVICE_FLUX_PATTERN

            `(
               <DynamicForm modelParams={modelParams}
                            presetParams={presetParams}
                            mode={this._DYNAMIC_FORM_MODES.update}
                            customServiceFluxParams={customServiceFluxParams}
                            accompanyingRequestData={{init: accompanyingData}}
                            updateIdentifier={recordID}
                            reflectionToMain={reflectionToMain}
                            fluxParams={dfFluxParams}
                            isUseImplementation={isUseImplementation}
                            implementationStore={this.props.implementationStore}
                            isMergeImplementation={this.props.isMergeImplementation}
                            isImplementationHigherPriority={this.props.isImplementationHigherPriority}
                            onChangeField={onChangeFieldHandler}
                            onClearField={onClearFieldHandler}
                            onReady={onReadyHandler}
                            onInitField={onInitFieldHandler}
                            onDestroyField={onDestroyHandler}
                            onAfterGetResponse={this._onAfterGetResponseDynamicForm}
                            {...additionFormParams}
                         />
            )`

      content: content
      title: @_getCustomDialogCaption clarificationParams, recordID

   ###*
   * Функция подготовки данных, сопутствующих массовым операциям над записью.
   *  Функция используется для подготовки данных, отправляемых в бизнес-логику,
   *  вместе с основными данными операциями(данные фильтра, данные о выбранных
   *  записях).
   *
   * @return {Object} - хэш с параметрами. Вид:
   *     {Object} markedKeys - параметры отмеченных строк и строк со
   *                           снятой отметкой.
   *     {Boolean} isAllMarked - флаг отметки всех записей.
   *     {Object} filterParams - параметры фильтра.
   ###
   _getAccompanyingDataForMassOperation: ->
      markedKeys: @_getMarkedKeys()
      isAllMarked: @state.isAllRowsMarked
      filterParams: @state.filterParams

   ###*
   * Функция получения свойств для элементов компонента. Получает свойства
   *  элемента по приоритету: 1. @props 2. @state.implementationProps.
   *  Если задан флаг isImplementationHigherPriority, то в обратном порядке.
   *
   * @param {String} elementName - имя элемента.
   * @return {Object} - свойства для конкретного элемента.
   ###
   _getElementProps: (elementName) ->
      tableElementNames = @_TABLE_ELEMENTS
      implementedProps = @_IMPLEMENTED_PROPS
      # Параметры модели.
      modelParams = @_getComponentProp(implementedProps.modelParams)
      # Параметры рендера колонок.
      columnRenderParams = @_getComponentProp(implementedProps.columnRenderParams)
      # Параметры дополнительных стилей.
      styleAddition =  @_getComponentProp(implementedProps.styleAddition)
      # Параметры пользовательских опций строки.
      customRowOptions = @_getComponentProp(implementedProps.customRowOptions)
      # Доп. параметры фильтра.
      filterAdditionParams = @_getComponentProp(implementedProps.filterAdditionParams)
      # Флаг разрешения опций строки.
      enableRowOptions = @_getComponentProp(implementedProps.enableRowOptions)
      # Флаг разрешения перетаскивания.
      enableRowDragAndDrop = @_getComponentProp(implementedProps.enableRowDragAndDrop)
      # Флаг разрешения выбора строк.
      enableRowSelect = @_getComponentProp(implementedProps.enableRowSelect)
      # Флаг разрешения экспорта данных файл.
      enableExport = @_getComponentProp(implementedProps.enableExport)
      # Флаг использования черезполосицы.
      isHasStripFarming = @_getComponentProp(implementedProps.isHasStripFarming)
      # Флаг разрешения отображения заголовков колонок.
      enableColumnsHeader = @_getComponentProp(implementedProps.enableColumnsHeader)

      switch elementName
         when tableElementNames.DataTableHeader
            enableColumnsHeader: enableColumnsHeader
            columnRenderParams: columnRenderParams
            enableRowSelect: enableRowSelect
         when tableElementNames.DataTableToolbar
            enableColumnsHeader: enableColumnsHeader
            enableExport: enableExport
            modelParams: modelParams
            filterAdditionParams: filterAdditionParams
         when tableElementNames.DataTableRows
            columnRenderParams: columnRenderParams
            enableRowOptions: enableRowOptions
            enableDragAndDrop: enableRowDragAndDrop
            customRowOptions: customRowOptions
            styleAddition: styleAddition
            enableSelect: enableRowSelect
            isHasStripFarming: isHasStripFarming
            isNeedFormatterRow: !enableColumnsHeader and enableRowDragAndDrop
         when tableElementNames.DataTableHierarchyView
            hierarchyViewParams = @_getComponentProp(implementedProps.hierarchyViewParams)

            basisParams =
               customNodeOptions: customRowOptions
               enableNodeOptions: enableRowOptions
               enableSelect: enableRowSelect
               styleAddition: styleAddition

            _.merge(basisParams, hierarchyViewParams)

   ###*
   * Функция формирования имени элемента(строки или ноды) с которой
   *  взаимодействовал пользователь при клике.
   *
   * @return {String} - имя элемента
   ###
   _getTouchedElementName: ->
      rowPrefixes = @_ROW_PREFIXES

      if @_isHierarchicallyViewTable()
         rowNamePrefix =rowPrefixes.hierarchy
         elementIdentifier = @state.touchedNodePath.join()
      else
         rowNamePrefix = rowPrefixes.flat
         elementIdentifier = @state.touchedRecordID

      [rowNamePrefix, elementIdentifier].join @_CHARS.underscore

   ###*
   * Функция получения параметров для сущности-связки.
   *
   * @param {Array<String>} reflectionsChain - цепь имен связок.
   * @return {Object, undefined} - параметры связки. Вид:
   *         {Object} externalEntities - параметры внешних связок.
   *         {Object} fields           - параметры полей.
   ###
   _getEntityParams: (reflectionsChain) ->
      @_preparePresetParams reflectionsChain: reflectionsChain

   ###*
   * Функция получения параметров модели. Если задан параметр reflectionsChain -
   *  формирует новые параметры для сущности-связки, задаваемой данной цепью.
   *
   * @param {Array<String>} reflectionsChain - параметры связки.
   * @return {Object} - параметры модели. Вид:
   *         {String} name      - имя модели.
   *         {String} caption   - локализованное название модели.
   *  {Array<Object>} relations - параметры связки модели.
   ###
   _getModelParams: (reflectionsChain) ->
      modelParams = @_readModelParams()

      if reflectionsChain? and !_.isEmpty reflectionsChain
         entityParams =
            @_getEntityParamsByChain
               reflectionsChain: reflectionsChain
               isPrepareRelations: true

         name: modelParams.name
         caption: modelParams.caption
         relations: entityParams.relations
      else
         modelParams

   ###*
   * Функция получения параметров определенной сущности (или основной для
   *  таблицы или вложенной, если задан параметр reflectionsChain).
   *
   * @param {Object} params - параметры для функции. Вид:
   *        {Boolean} isPrepareRelations - флаг формирования параметров связок
   *                                       в формате @props.modelParams.relations.
   *    {Array<String>} reflectionsChain - цепь связок по которой нужно
   *                                       извлечь целевые параметры связки.
   *                                       Если данный параметр не задан
   *                                       формирует возвращает параметры
   *                                       сущности текущей таблицы.
   * @return {Object}
   ###
   _getEntityParamsByChain: (params) ->
      reflectionsChain = params.reflectionsChain
      isPrepareRelations = params.isPrepareRelations
      entityParams = @state.entityParams
      entityParamsByChain = {}

      if reflectionsChain? and !_.isEmpty reflectionsChain
         externalEntities = entityParams.externalEntities if entityParams?
         chainLength = reflectionsChain.length

         if isPrepareRelations
            fieldKeys = @_FIELD_KEYS
            isPrimaryKeyKey = fieldKeys.isPrimaryKey
            relations = []

         for modelName, idx in reflectionsChain
            targetEntityParams = externalEntities[modelName]

            if isPrepareRelations
               fields = targetEntityParams.fields
               primaryKey = _.find(fields, isPrimaryKeyKey)

               relations.push
                  index: 1
                  reflection: targetEntityParams.reflectionName
                  isCollection: !targetEntityParams.isSingle
                  isReverseMultiple: targetEntityParams.isReverseMultiple
                  primaryKey: primaryKey


            # Если удалось получить параметры связки и ещё есть элементы в цепи
            #  запрошенных связок - перечитываем внешние связки и продолжаем.
            if targetEntityParams? and idx < (chainLength - 1)
               targetEntityParams = targetEntityParams.externalEntities
      else
         targetEntityParams = entityParams

      if targetEntityParams? and !_.isEmpty targetEntityParams
         entityParamsByChain.fieldParams = targetEntityParams.fieldParams or
                                           targetEntityParams.fields

         entityParamsByChain.externalEntities = targetEntityParams.externalEntities

      if isPrepareRelations
         entityParamsByChain.relations = relations

      entityParamsByChain

   ###*
   * Функция получения компонента организатора операций над записями (хлебного
   *  навигатора операций).
   *
   * @return {React-element}
   ###
   _getOperationsOrganizerRef: ->
      @props.operationsOrganizer or @refs[@_REFS.operationsOrganizer]

   ###*
   * Функция получения параметров для всплывающего уведомления.
   *
   * @param {String} text       - текст уведомления.
   * @param {String, Number} id - идентификатор уведомления.
   * @param {String} type       - тип уведомления.
   * @return {Object} - параметры всплывающего уведомления.
   ###
   _getPopupParams: (text, id, type) ->
      text: text
      identifier: id
      type: type

   ###*
   * Функция получения параметров позиционирования строки с контролем совпадения
   *  с перемещаемой строкой по ключу.
   *
   * @param {Number} rowKey - ключ строки.
   * @param {Number} dragRowKey - ключ перемещенной строки.
   * @param {Object} rowPosition - параметры позиционирования перемещенной строки.
   * @return {Object} - параметры позиционирования строки.
   ###
   _getRowClientRect: (rowKey, dragRowKey, rowPosition) ->
      chars = @_CHARS
      refKey =
         [
            @_REFS.row
            chars.underscore
            rowKey
         ].join chars.empty
      if rowKey isnt dragRowKey
         clientRectRow = ReactDOM.findDOMNode(@refs.rows.refs[refKey])
                                 .getBoundingClientRect()
      else
         rowPosition

   ###*
   * Функция получения скомпанованного стиля таблицы данных.
   *
   * @return {Object} - скомпанованный стиль.
   ###
   _getComputedStyleDataTable: ->
      styleAddition = @_getComponentProp(@_IMPLEMENTED_PROPS.styleAddition)

      styleAdditionTable = styleAddition? and styleAddition.dataTable

      @computeStyles @styles.common,
                     @props.isFitToContainer and @styles.tableFitToContainer,
                     styleAdditionTable

   ###*
   * Функция получения доп. стилей для корневого узла таблицы, заданных через
   *  свойства.
   *
   * @return {Object}
   ###
   _getCommonStyle: ->
      implementedProps = @_IMPLEMENTED_PROPS
      styleAddition = @_getComponentProp(implementedProps.styleAddition)
      dimension = @_getComponentProp(implementedProps.dimension)

      commonDimension =
         if dimension? and !_.isEmpty dimension
            dimension.common

      styleAddition = styleAddition? and styleAddition.common

      if commonDimension? or styleAddition?
         @computeStyles styleAddition,
                        @_getDimensionStyle(commonDimension)

   ###*
   * Функция нахождения записи в переданном наборе записей по ключу
   *
   * @param {String} nodePath - путь в иерархии до узла.
   * @return {Array<Object>} - набор записей
   ###
   _getRecordFromRecordsByKey: (records, key) ->
      _.find(records, [@_RECORD_KEYS.key, key])

   ###*
   * Функция получения параметров массовой операции по имени. Перебирает массив
   *  операций и возвращает опцию, если у нее совпало имя с переданным.
   *
   * @param {String} operationName - имя операции над записями.
   * @return {Object} - параметры массовой операции.
   ###
   _getMassOperationByName: (operationName)->
      massOperations = @props.massOperations

      if massOperations?
         for operation in massOperations.operations

            if operation.name?
               return operation if operation.name is operationName

   ###*
   * Функция получения параметров массовой операции по имени. Перебирает массив
   *  операций и возвращает опцию, если у нее совпало имя с переданным.
   *
   * @param {String} responseType - имя операции над записями.
   * @return {Object} - параметры массовой операции.
   ###
   _getMassOperationByResponse: (responseType)->
      massOperations = @props.massOperations

      if massOperations?
         for operation in massOperations.operations
            operationFluxParams = operation.fluxParams
            if operationFluxParams?
               if operationFluxParams.responseType is responseType
                  return operation
   ###*
   * Функция получения параметров массовой операции по пользовательскому методу
   *  взаимодействия с API, заданному в параметрах динамической формы.
   *
   * @param {String} responseType - имя операции над записями.
   * @return {Object} - параметры массовой операции.
   ###
   _getMassOperationByCustomEndpoint: (cutomEndpoint) ->
      massOperations = @props.massOperations

      if massOperations? and massOperations.operations?
         _.find(massOperations.operations, ((operation) ->
            _.get(operation, @_OBJECT_CHAINS.massOperationByEndpoint)?
         ).bind(this))


   ###*
   * Функция получения свойств стандартной реализации для таблицы. Получает свойства
   *  заданные в стандартных реализациях для конкретной таблицы. Пробует получить
   *  параметры, если задан флаг @props.isUseImplementation и хранилище реализаций
   *  @props.implementationStore. Параметры из хранилища считываются по наименованию
   *  модели, полученный по приоритету 1. Наименование последней связки в параметрах
   *  связок. 2. Наименование представления таблицы 3. Наименование модели.
   *
   * @param {Object} props - свойства на базе которых считываются параметры реализации.
   *                         если свойства на переданы, берутся текущие @props.
   * @return {Object}
   ###
   _getImplementationProps: (props) ->
      props ||= @props
      isUseImplementation = props.isUseImplementation
      implementationStore = props.implementationStore

      if isUseImplementation and implementationStore?
         modelParams = props.modelParams
         return unless modelParams?

         modelRelations = modelParams.relations
         modelView = modelParams.view

         currentModelName = if modelRelations? and !_.isEmpty(modelRelations)
                               lastRelation = _.last(modelRelations)

                               lastRelation.identifyingName or lastRelation.reflection
                            else if modelView? and !_.isEmpty(modelView)
                               modelView
                            else
                               modelParams.name

         componentName = @constructor.displayName
         implementationStore.getProps(currentModelName, componentName)

   ###*
   * Функция считывания параметров начальных данных и подготовки хэша состояний
   *  таблицы данных.
   *
   * @param {Object} initData - параметры инициализационных данных.
   * @return {Object}
   ###
   _getTableDataFromInitData: (initData) ->
      initData ||= @props.initData
      initRecords = initData.records
      paginateParams = initData.paginateParams || @_determinePaginateParams(initRecords)
      tableData = initRecords

      # Если заданы параметры постраничного вывода - переопределим начальные
      #  записи - выводим только записи на заданной странице.
      if paginateParams?
         entriesStatistic = paginateParams.entriesStatistic

         if entriesStatistic?
            start = entriesStatistic.start
            end = entriesStatistic.end

            if start? and end?
               tableData = initRecords.slice(start - 1, end + 1)

      tableData: tableData
      initData:
         tableData: initRecords
         paginateParams: paginateParams
      entityParams: initData.entityParams
      paginateParams: paginateParams
      tableState: @_TABLE_STATES.dataReceived

   ###*
   * Функция получения начальных(пустых) значений для диалога взаимодействия
   *
   * @return {Object} - хэш с пустыми параметрами диалога взаимодейсвия.
   ###
   _getInitDialogInteractionParams: ->
      text: ''
      caption: ''
      type: null
      value: null
      callback: null

   ###*
   * Функция получения начальных(пустых) значений для всплывающего уведомления.
   *
   * @return {Object} - хэш с пустыми параметрами.
   ###
   _getInitPopupFlashParams: ->
      text: ''
      id: 0

   ###*
   * Функция получения параметров произвольного действия из массива, заданых в параметрах
   *  Выборка осуществляется по имени или типу события flux.
   *
   * @param {String} optionName   - имя опции.
   * @param {String} responseType - тип события flux.
   * @return {Object} - хэш параметров опции.
   ###
   _getCustomOperation: (optionName, responseType)->
      customRowOptions = @_getComponentProp(@_IMPLEMENTED_PROPS.customRowOptions,
                                            true)
      if customRowOptions?
         _.find(customRowOptions, (option) ->
            fluxParams = option.fluxParams

            (option.name is optionName) or
            (fluxParams? and (fluxParams.responseType is responseType))
         )




   ###*
   * Функция формирования заголовка диалога для пользовательской опции на основе
   *  данных, переданных через параметры.
   *
   * @param {Object} clarificationParams - параметры пояснения к пользовательской опции.
   * @param {String, Number} recordID    - идентификатор записи.
   * @return {String} - сформированный заголовок диалога.
   ###
   _getCustomDialogCaption: (clarificationParams, recordID)->
      template = clarificationParams.template
      fieldNames = clarificationParams.fields

      if fieldNames?
         recordFields = @getRecord(recordID).fields
         values = []

         for fieldName in fieldNames
            values.push recordFields[fieldName].value

         format template, values
      else
         template

   ###*
   * Функция получения стиля контейнера для таблицы данных.
   *
   * @return {Object} - скомпанованный стиль.
   ###
   _getDataContainerStyle: ->
      implementedProps = @_IMPLEMENTED_PROPS
      dimension = @_getComponentProp(implementedProps.dimension)
      styleAddition = @_getComponentProp(implementedProps.styleAddition)

      dataContainerDimension =
         if dimension? and !_.isEmpty dimension
            dimension.dataContainer
      dataContainerAdditionStyle =
         if styleAddition? and !_.isEmpty styleAddition
            styleAddition.dataContainer

      @computeStyles @styles.dataContainer,
                     dataContainerAdditionStyle,
                     @_getDimensionStyle(dataContainerDimension)

   ###*
   * Функция получения доп. стилей размерности.
   *
   * @param {Object} dimension - параметры размерности.
   * @return {Object, undefined}
   ###
   _getDimensionStyle: (dimension) ->

      if dimension? and !_.isEmpty dimension
         dimHeight = dimension.height
         dimWidth = dimension.width
         dimStyle = {}

         if dimHeight?
            dimStyle.maxHeight = dimHeight.max if dimHeight.max?
            dimStyle.minHeight = dimHeight.min if dimHeight.min?

         if dimWidth?
            dimStyle.maxWidth = dimWidth.max if dimWidth.max?
            dimStyle.minWidth = dimWidth.min if dimWidth.min

         dimStyle

   ###*
   * Функция получения стиля объекта с надписью о пуcтом результате вывода записей
   * (записи отсутствуют).
   *
   * @return {Object} - стили
   ###
   _getNotFoundStyle: ->
      styles = @styles
      isNotRequestion = @state.tableState isnt @_TABLE_STATES.requesting
      tableData = @state.tableData
      isNotFound = @_isEmptyRecords()

      @computeStyles styles.recordsNotFound,
                     isNotFound and isNotRequestion and styles.recordsNotFoundShown

   ###*
   * Функция для получения ключа уведомления для отмеченных строк.
   *
   * @return {String} - ключ-строка для уведомления.
   ###
   _getMarkedPopupFlashIdentifier: ->
      markedKeys = @_getMarkedKeys()
      splitter = ' / '
      allIdentifier = @_ALL_MARKED_IDENTIFIER
      without = 'без'

      if @state.isAllRowsMarked
         unmarked = markedKeys.unmarked
         if unmarked? and unmarked.length
            [
              allIdentifier
              without
              unmarked.join(splitter)
            ].join(' ')
         else
            allIdentifier
      else
         markedKeys.marked.join(splitter)

   ###*
   * Функция получения параметров отмеченных строк.
   *
   * @return {Object} -  хэш с параметрами выделенных строк.
   *                     marked - кол-во отмеченных.
   *                     total  - кол-во строк всего с которыми происходило
   *                              взаимодействие по выделению/снятию выделения.
   ###
   _getMarkedStatistic: ->
      isAllRowsMarked = @state.isAllRowsMarked
      markedCount = 0
      totalCount = 0

      for _key, isMarked of @state.markedRows
         markedCount++ if isMarked
         totalCount++

      # Если есть отметка о том что выбраны все - определим общее кол-во и
      #  кол-во выбранных на основе общей статистики записей и кол-ве записей,
      #  с которых была снята отметка.
      if isAllRowsMarked
         unmarkedCount = totalCount - markedCount
         totalRecordsCount = @state.paginateParams.entriesStatistic.total
         totalCount = totalRecordsCount
         isRequesting = @state.tableState is @_TABLE_STATES.requesting
         calculatedTotal = totalRecordsCount - unmarkedCount

         # Если был применен фильтр по выделенным записям, то кол-во отмеченных
         #  совпадает с общим кол-вом(за исключением случая, когда отправлен запрос
         #  в БЛ).
         # Иначе - кол-во отмеченных вычисляется (если панель операций скрыта),
         #  за исключением случая, когда отправлен запрос в БЛ и показана панель операций.
         # TODO: Есть баг - в случае, если были выбраны все записи и с некоторых
         #       была снята отметка и при этом панель операций скрывается вычисляется
         #       кол-во отмеченных записей некорректно, т.к. мы не можем определить, что
         #       это панель операций была скрыта. Можно решить костыльно, но пока оставлю
         #       так пока не нужно будет править(возможно этот баг навечно).
         markedCount = if @_isMarkedFilterApplied()
                          if isRequesting
                             calculatedTotal
                          else
                             totalRecordsCount
                       else
                           if isRequesting and @_isActiveMassApplicationPanel()
                              totalRecordsCount
                           else
                              calculatedTotal

      marked: markedCount
      total: totalCount

   ###*
   * Функция получения отмеченных строк и строк с которых была снята отметка.
   *  Функция работает без учета флага @state.isAllRowsMarked.
   *
   * @return {Object<Array>}. Вид:
   *  {Array} marked   - массив ключей отмеченных строк.
   *  {Array} unmarked - массив ключей строк, с которых снята отметка.
   ###
   _getMarkedKeys: ->
      processedMarkedRows = _.cloneDeep(@state.markedRows)
      tableData = @state.tableData
      marked = []
      unmarked = []

      if tableData? and !_.isEmpty tableData
         # Перебираем все строки таблицы, чтобы сохранялся порядок строк(если, например
         #  разрешен drag-and-drop).
         for rowData in tableData
            rowKey = rowData.key
            isRowMarked = processedMarkedRows[rowKey]

            if isRowMarked?
               if isRowMarked
                  marked.push rowKey
               else
                  unmarked.push rowKey

               # Если такая строка есть в хэше отмеченных строк/строк со снятой отметкой
               #  - удалим, чтобы она не участвовала в дальнейшем отборе.
               delete processedMarkedRows[rowKey]

      # Если еще остались отмеченных строки/строки со снятой отметкой - переберем их
      #  и добавим в массивы.
      unless _.isEmpty processedMarkedRows
         for rowKey, isMarked of processedMarkedRows
            if isMarked
               marked.push rowKey
            else
               unmarked.push rowKey

      marked: marked
      unmarked: unmarked

   ###*
   * Функция получения ключей строк, отмеченных на странице. Для каждой записи
   *  на странице проверяет задан ли флаг выбранности в параметрах @state.markedRows,
   *  а также задан ли флаг для таблицы @state.isAllRowsMarked, но при этом
   *  она не помечена как "невыбранная" в наборе "unmarked".
   *
   * @return {Array<Number, String>}
   ###
   _getMarkedRowsOnPage: ->
      markedRowKeys = @_getMarkedKeys()
      markedRows = markedRowKeys.marked
      unmarkedRows = markedRowKeys.unmarked
      isAllRowsMarked = @state.isAllRowsMarked
      rowKeysOnPage = _.map(@state.tableData, @_RECORD_KEYS.key)
      resultKeys = []

      for rowKey in rowKeysOnPage
         isRowMarked =
            _.includes(markedRows, rowKey) or
            (isAllRowsMarked and !_.includes(unmarkedRows, rowKey))

         if isRowMarked
            resultKeys.push rowKey

      resultKeys

   ###*
   * Функция получения набора отрисовываемых колонок.
   *
   * @return {Object} - хэш параметров колонок:
   *                    name:       - имя колонки,
   *                       type:    - тип колонки,
   *                       caption: - выводимый заголовок
   ###
   _getRenderedColumns: ->
      tableData = @state.tableData
      columnRenderParams =
         @_getComponentProp(@_IMPLEMENTED_PROPS.columnRenderParams)
      clonedColumnRules =
         if columnRenderParams? and columnRenderParams.columns?
            _.cloneDeep(columnRenderParams.columns)
      columns = {}

      # если массив с данными имеет какие-то элементы -
      # от них можно взять название колонок
      if tableData? and tableData.length
         firstRow = tableData[0]
         firstRowFields = firstRow.fields

         # Перебираем все поля в строке
         for fieldName, value of firstRowFields
            isHasColumnRenderRule = _.has(clonedColumnRules, fieldName)
            columnRenderRule =
               if isHasColumnRenderRule
                  clonedColumnRules[fieldName]

            # Определяем заголовок колонки - если заголовок задан в правилах -
            #  получаем его, иначе берем значения из параметров колонки.
            columnCaption =
               if isHasColumnRenderRule and columnRenderRule? and
               columnRenderRule.caption?

                  columnRenderRule.caption
               else
                  value.caption

            # Если поле является отрисовываемым - добавляем в набор колонок.
            if @_isRenderedColumn fieldName
               columns[fieldName] =
                  type: value.type
                  caption: columnCaption

               # Удаляем добавленную колонку из клонированного набора правил
               #  отрисовки колонок (для дальнейшей проверки и обработки данного
               #  правила).
               if isHasColumnRenderRule
                  delete clonedColumnRules[fieldName]

         # Если остались правила отрисовки полей, которые не были удалены при
         #  обработке полей, то перебираем их и смотрим заданы ли для них особые
         #  параметры - если заданы - то добавляем их в результирующий набор.
         unless _.isEmpty clonedColumnRules
            renderRuleKeys = @_RENDER_RULE_KEYS
            recordKeys = @_RECORD_KEYS
            reflectionsKey = renderRuleKeys.reflections
            onRenderCellKey = renderRuleKeys.onRenderCell
            captionKey = renderRuleKeys.caption

            for columnName, columnRules of clonedColumnRules
               continue unless columnRules?

               ruleCaption = columnRules.caption

               if _.has(columnRules, onRenderCellKey)
                  columns[columnName] =
                     caption: ruleCaption || columnName

               # Если в параметрах записи задан ключ 'reflections' - значит
               #  предполагается что это поле связки - значит пробуем получить
               #  данное поле из связок. Если поле удается получить - добавляем
               #  в результирующий набор колонок.
               else if _.has(columnRules, reflectionsKey)
                  reflectionsChain = columnRules[reflectionsKey]
                  reflectionByChain =
                     @_getRecordReflectionParams(firstRow, reflectionsChain)

                  reflectionFields =
                     if reflectionByChain?
                        reflectionByChain[recordKeys.fields]

                  if reflectionFields?
                     columnParams = reflectionFields[columnName]

                     if columnParams?
                        columns[columnName] =
                           type: columnParams.type
                           caption: columnParams.caption
               else if _.has(columnRules, captionKey)
                  columns[columnName] =
                     caption: ruleCaption

      columns

   ###*
   * Функция получения параметров связки на любом уровне вложенности записи.
   *
   * @param {Object} record       - запись.
   * @param {Array<String>} chain - цепь связок по которой нужно получить.
   * @return {Object, undefined} - параметры связки, если удалось прочитать.
   ###

   _getRecordReflectionParams: (record, chain) ->
      recordKeys = @_RECORD_KEYS
      processedChain = []

      for nexus in chain
         processedChain.push(recordKeys.reflections)
         processedChain.push(nexus)
         processedChain.push(recordKeys.value)

      _.get(record, processedChain)

   ###*
   * Функция на получение данных пользовательского действия над записью.
   *
   * @param {Object} cutomOption - хэш с параметрами пользовательского действия над
   *                               записью.
   * @return
   ###
   _getCustomResponse: (customOption)->
      return unless customOption?

      fluxParams = customOption.fluxParams

      # Если нет параметров flux - ничего не делаем дальше.
      return unless fluxParams?

      # Получим фукнцию считывания результата из хранилища.
      getResponseHandler = fluxParams.getResponse
      # Если задан обработчик считывания результата - считываем.
      if getResponseHandler?
         response = getResponseHandler()
         popupFlashTypes = @refs.popupFlasher.getFlashTypes()
         recordID = @state.touchedRecordID

         # Зададим параметры для уведомления. В зависимости от того есть ошибки или нет
         if @_isResponseHasErrors(response)
            popupText = response.errors # @_getResponseErrorsString response.errors
            popupType = popupFlashTypes.error
         else
            responseBehavior = customOption.responseBehavior
            resultRecord = response.json[responseBehavior.responseObject]

            # Если задана опция перерисовки записи по которой была операция по
            #  данным результата считаем запись результата обновим данные таблицы.
            if responseBehavior.isReRenderRecord

               newTableData = @_getTableDataWithUpdateRecord resultRecord

               @setState tableData: newTableData

            popupText = @_getCustomRowSuccessInscription(resultRecord, customOption)
            popupType = popupFlashTypes.info

         @setState popupParams: @_getPopupParams(popupText, recordID, popupType)

   ###*
   * Функция формирования форматированной строки для вывода ошибок при получении ответа
   *  из БЛ.
   *
   * @param {Array, String} errors - массив ошибок или строка с ошибкой.
   * @return {String} - строка с ошибкой и префиксом.
   ###
   _getResponseErrorsString: (errors) ->
      newLineChar = @_NEW_LINE_CHAR

      errorsString =
         if _.isArray errors
            errors.join(newLineChar)
         else if _.isPlainObject errors
            errors

      [
         @_RESPONSE_ERRORS_TITLE
         errorsString
      ].join(newLineChar)

   ###*
   * Функция получения текста сообщения успешного применения пользовательской операции
   *  к записи. Проверяет если описание задано массивом - то выбирает значение, исходя
   *  из состояния целевого поля.
   *
   * @param {Object} record - запись по которой была операция(содержит актуальные данные)
   * @param {Object} option - хэш параметров опции.
   * @return {String} - сообщение
   ###
   _getCustomRowSuccessInscription: (record, option) ->
      responseBehavior = option.responseBehavior
      inscription = responseBehavior.successInscription

      # Если описание - массив - выберем элемент, основываясь на целевом поле.
      if _.isArray(inscription)
         fieldForCondition = option.fieldForCondition
         isPositiveCondition = @_getConditionFromField(record, fieldForCondition)
         inscIndex = if isPositiveCondition then 0 else 1

         inscription[inscIndex]
      else
         inscription

   ###*
   * Выполняет преобразование к логическому формату значение целевого поля опции.
   *
   * @param {Object} record         - запись по которой была операция(содержит актуальные данные)
   * @param {String} conditionField - поле по которому будет выполнятся преобразование
   * @return {Boolean} - результат выполнения преобразования значения поля к логичекому типу.
   ###
   _getConditionFromField: (record, conditionField) ->
      !!record.fields[conditionField].value

   ###*
   * Функция получения массива данных таблицы с обновленным значением новой записи.
   *
   * @param {Object} updatedRecord - объект с данными записи таблицы.
   * @return {Array} - массив с обновленной записью.
   ###
   _getTableDataWithUpdateRecord: (updatedRecord) ->
      newTableData = @state.tableData.splice 0

      ###*
      * Функция обновления данных по записи.
      *
      * @param {Array} records - набор записей.
      * @param {Object} updRecord - обновленная запись.
      ###
      updateRecord = (records, updRecord) ->
         for record, idx in records
            if record.key is updRecord.key
               records[idx] = updRecord
               break

      if @_isHierarchicallyViewTable()
         updatedRecordParent = updatedRecord.fields[@_PARENT_FIELD_NAME]
         #updatedRecord = @_getRecordInHierarchy(newTableData, updatedRecord.key)

         if updatedRecordParent? and updatedRecordParent.value
            parentRecord = @_getRecordInHierarchy(newTableData, updatedRecordParent.value)

            updateRecord(parentRecord.childs, updatedRecord)
         else
            updateRecord(newTableData, updatedRecord)
      else
         updateRecord(newTableData, updatedRecord)

      newTableData

   ###*
   * Функция на получение данных по обновлению записи. Обновляем записи в таблице данных
   *
   * @param {Object} response - параметры ответа. Если на заданы беруться из
   *                            параметров flux-инфраструктуры.
   * @return
   ###
   _getResponseUpdate: (response) ->
      response = @props.fluxParams.update.getResponse() unless response?
      popupFlashTypes = @refs.popupFlasher.getFlashTypes()
      responseJSON = response.json
      operationInfo = responseJSON.operationInfo

      # Если был получен ответ по обновлению для текущей модели
      #  (для отфильтровки случаев, когда обновление произведено для
      #   одной из связок текущей моедли).
      if @_isResponseForCurrentTable(operationInfo)
         if @_isResponseHasErrors response
            popupText = response.errors # @_getResponseErrorsString response.errors
            popupType = popupFlashTypes.error
            popupIdentifier = @state.touchedRecordID
         else
            updateResult = responseJSON.update
            if updateResult?
               newTableData = @_getTableDataWithUpdateRecord updateResult
               @setState tableData: newTableData

               popupText = @_UPDATE_NOTIFY
               popupType = popupFlashTypes.success
               popupIdentifier = updateResult.key


         if popupIdentifier?
            @setState
               popupParams: @_getPopupParams(popupText,
                                             popupIdentifier,
                                             popupType)

   ###*
   * Функция на получение данных по обновлению записи. Обновляем записи в таблице данных
   *
   * @param {Object} response - параметры ответа. Если на заданы берутся из
   *                            параметров flux-инфраструктуры.
   * @return
   ###
   _getResponseDelete: (response) ->
      response = @props.fluxParams.delete.getResponse() unless response?
      popupFlashTypes = @refs.popupFlasher.getFlashTypes()

      if @_isResponseHasErrors(response)
         popupText = response.errors # @_getResponseErrorsString response.errors
         popupType = popupFlashTypes.error
         popupIdentifier = @state.touchedRecordID
      else
         activePage = @state.activePage
         newEntriesStatistic = @state.paginateParams.entriesStatistic
         totalPages = newEntriesStatistic.totalPages
         deletedKey = response.json.deletedKey

         # Уменьшаем общее кол-во записей в статистике.
         newEntriesStatistic.total--
         # Уменьшаем конечное кол-во записей в выборке.
         newEntriesStatistic.end--

         # Если удаляемая запись на последней странице - считаем результат удаления.
         # Иначе - если находимся на любой другой странице - отправляем запрос на
         #  перечитывание записей.
         if activePage is totalPages
            newTableData = @state.tableData.splice 0

            if @_isHierarchicallyViewTable()
               @_deleteRecordFromHierarchy newTableData, deletedKey
            else
               # Удалим удалённую запись из клонированного(нового) массива записей комопнента
               for record, idx in newTableData
                  if record.key is deletedKey
                     newTableData.splice idx, 1
                     break

            # Если в новом массиве записей без удаленной нет больше членов -
            #  уменьшим кол-во страниц, активной страницей сделаем предыдущюю,
            #  а также отправим запрос на перечитываение записей из БЛ.
            unless newTableData.length
               @_rereadAfterOperation()
               newEntriesStatistic = @state.paginateParams.entriesStatistic
               newEntriesStatistic.totalPages--
               activePage--

            @setState
               tableData: newTableData,
               entriesStatistic: newEntriesStatistic,
               activePage: activePage

         else
            @_rereadAfterOperation()

         popupText = @_DELETE_NOTIFY
         popupType = popupFlashTypes.exclamation
         popupIdentifier = deletedKey

      @setState popupParams: @_getPopupParams(popupText, popupIdentifier, popupType)

   ###*
   * Функция на получение данных по созданию записи. В зависимости от активной
   *  страницы производим различные записи.
   *
   * @param {Object} response - параметры ответа. Если на заданы беруться из
   *                            параметров flux-инфраструктуры.
   * @return
   ###
   _getResponseCreate: (response) ->
      response = @props.fluxParams.create.getResponse() unless response?
      popupFlashTypes = @refs.popupFlasher.getFlashTypes()

      ###*
      * Функция получения кол-ва страниц на основе ответа создания новой записи.
      *
      * @param {Number} totalRecordsCount - текущее кол-во записей.
      * @param {Number} perPage - кол-во на странице.
      * @param {Object} createResponse - хэш с параметрами новой записи.
      * @return {Number} - новое кол-во страниц.
      ###
      getPagesCountFromResponse = (totalRecordsCount, perPage, createResponse) ->
         flatCalculation = Math.ceil totalRecordsCount / perPage

         if @_isHierarchicallyViewTable()
            newRecordFields = createResponse.fields
            newRecordParentIDField = newRecordFields.parent_id

            if newRecordParentIDField?
               newRecordParentID = newRecordParentIDField.value

               # Если родитель задан - то дочерняя запись и для неё не нужно
               #  определять новое кол-во страниц, т.к. она входит в родителькую
               #  запись.
               # Иначе - это корневая запись и нужно определить
               if newRecordParentID?
                  return @state.paginateParams.totalPages
               else
                  return Math.ceil @state.paginateParams.entriesStatistic.total / perPage

         flatCalculation

      if @_isResponseHasErrors response
         popupText = response.errors #@_getResponseErrorsString response.errors
         popupIdentifier = '-'
         popupType = popupFlashTypes.error
      else
         perPage = @state.perPage
         orderedField = @state.orderedField
         newTableData = @state.tableData
         paginateParams = @state.paginateParams

         if paginateParams?
            newEntriesStatistic = paginateParams.entriesStatistic if paginateParams?
            newPagesCount = paginateParams.totalPages if paginateParams?
            createResponse = response.json.create if paginateParams?

         # В любом случае увеличиваем общее кол-во записей.
         newEntriesStatistic.total += 1

         # Определим общее кол-во страниц для постраничной навигации
         newPagesCount = getPagesCountFromResponse.call(this,
                                                        newEntriesStatistic.total,
                                                        perPage,
                                                        createResponse)

         # Если текущая активная страница последняя -
         #  считываем результат создания записи.
         if @state.activePage is newPagesCount
            # Если записи в таблице уже заданы и
            #  Если кол-во элементов в новом массиве записей меньше чем кол-во записей
            #    на странице - считываем данные и добавляем в результирующий массив.
            # Иначе(нет записей в таблице) - создаем новый массив записей таблиц
            #  с единственным элементом - созданной записью.
            if newTableData? and !_.isEmpty newTableData
               if newTableData.length < perPage

                  if @_isHierarchicallyViewTable()
                     @_insertRecordInHierarchy(newTableData, createResponse)
                  else
                     newTableData.push createResponse

                  # Прибавим кол-во записей, (по куда показаны) записи.
                  newEntriesStatistic.end++

                  # Если было упорядочивание по полю - упорядочим новый массив
                  if orderedField
                     newTableData = @_orderColumns orderedField, newTableData
            else
               newTableData = [createResponse]

         # Сформируем хэш с новыми параметрами постраничного вывода.
         newPaginateParams =
            entriesStatistic: newEntriesStatistic
            totalPages: newPagesCount

         @setState
            paginateParams: newPaginateParams
            tableData: newTableData

         popupText = @_CREATE_NOTIFY
         popupIdentifier = createResponse.key
         popupType = popupFlashTypes.success

      @setState
         popupParams: @_getPopupParams(popupText, popupIdentifier, popupType)

   ###*
   * Функция на получение инициализационных значений таблицы.
   *
   * @param {Object} response - данные ответа. Если параметр не задан, то
   *                            идет попытка считывания по заданным параметрам.
   * @return
   ###
   _getResponseInit: (response) ->
      unless response?
         fluxParamsInit = @props.fluxParams.init
         requestIdentifier = fluxParamsInit.requestIdentifier
         getResponseIdentifierHandler = fluxParamsInit.getResponseIdentifier
         isNotCurrentRequest = if requestIdentifier? and getResponseIdentifierHandler?
                                  requestIdentifier isnt getResponseIdentifierHandler()
         responseResultKey = fluxParamsInit.responseResultKey
         # Если был передан идентификатор запроса и задана функция получения идентификатора
         #  ответа - сверяем совпадают идентификаторы. Если идентификатор задан и совпадает
         #  c идентификатором ответа - считываем ответ, иначе ничего не делаем
         # Иначе если идентификатор и функция считывания идентификатора ответа не заданы -
         #  считываем результат.
         return if isNotCurrentRequest

         response = fluxParamsInit.getResponse()

      responseParams = @_getInitResponseParams(response, responseResultKey)
      responseResult = responseParams.result
      responseComplexDataParams = responseParams.complexDataParams

      resultParams = @_getInitResponseData(responseResult, fluxParamsInit)
      records = resultParams.records
      paginateParams = resultParams.paginateParams

      @_readyHandler(records)
      @_focusOnDataContainer()

      @setState
         isFilterChanged: false
         tableState: @_TABLE_STATES.dataReceived
         tableData: records
         initData:
            tableData: records
            paginateParams: paginateParams
         paginateParams: paginateParams
         entityParams: resultParams.entityParams
         complexDataParams: responseComplexDataParams

   ###*
   * Функция получения результата произвольной пользовательской операции.
   *  Получает параметры массовой операции по методу взаимодействия с API.
   *  Подготавливает и устанавливает состояния в зависимости от заданных параметров
   *  операции.
   *  TODO: сейчас работает только для массовых операций, работающих
   *        через сервисную инфраструктуру.
   *
   * @param {Object} responseData - параметры ответа.
   * @return
   ###
   _getResponseCustom: (responseData) ->
      eventType = responseData.type
      data = responseData.json

      if eventType?
         customMethod = eventType.customMethod
         massOperationByEndpoint = @_getMassOperationByCustomEndpoint(customMethod)
         isUnsetMarkedOnCallback = massOperationByEndpoint.isUnsetMarkedOnCallback
         responseBehavior = massOperationByEndpoint.responseBehavior
         newState = {}

         if responseBehavior? and !_.isEmpty(responseBehavior)
            successInscription = responseBehavior.successInscription
            responseObjectName = responseBehavior.responseObject
            responseData =
               if _.has(data, responseObjectName)
                  _.toString(data[responseObjectName])

            if successInscription? and responseData?
               _.merge(newState,
                  popupParams: @_getPopupParams(successInscription,
                                                responseData)
               )

         if isUnsetMarkedOnCallback
            _.merge(newState,
               markedRows: {}
               isAllRowsMarked: false
            )

         unless _.isEmpty(newState)
            @setState newState

   ###*
   * Функция считывания ответа экспорта данных. Считывает ссылку на файл экспорта
   *  и выполняет скачивание, устанавливает флаг запрошенности файла экспорта в
   *  false
   *
   * @param {Object} responseData - параметры ответа.
   * @return
   ###
   _getResponseExport: (responseData) ->
      json = responseData.json

      if json? and !_.isEmpty(json)
         exportUrl = json.url

         if exportUrl?
            location.href = exportUrl

      @setState isExportRequested: false

   ###*
   * Функция получения результата считывания начальных данных таблицы. Обрабатывает
   *  ответ - проверяет были ли заданы параметры "составного" ключа(для считывания
   *  разнородных данных), а также обрабатывает "ленивую" подгрузку.
   *
   * @param {Object} response - ответ.
   * @param {Object} responseResultKey - параметры ключа считывания результата.
   * @return {Object} - хэш парметров ответа. Вид:
   *           {Object} result - результат считывания.
   *           {Object} complexDataParams - параметры составных данных.
   ###
   _getInitResponseParams: (response, responseResultKey) ->
      enableLazyLoad = @props.enableLazyLoad
      isComplexResultKey = _.isArray(responseResultKey)
      isFilterChanged = @state.isFilterChanged
      # Если разрешена "ленивая" загрузка записей и фильтр не был изменен, то записи
      #  нужно добалвять к существующей набору.
      isNeedAddToCurrentDataCollection = enableLazyLoad and !isFilterChanged
      responseKeys = @_RESPONSE_KEYS
      jsonKey = responseKeys.json
      jsonKeys = responseKeys.jsonKeys
      recordsKey = jsonKeys.records
      #responseRecords = response.records

      # Если был считан ответ в формате обмена данными утилит flux - считываем
      #  для дальнейшей обработки только основные данные ответа, без служебных данных.
      if _.has(response, jsonKey)
         response = response[jsonKey]

      # # Если задан ключ считывания результата возьмем результат по ключу, иначе
      # #  просто берем ответ (значит данный ключ оперделен непосредственно в flux
      # #  инфраструктуре).
      # if responseResultKey?

      # Если ключ получения записей имеет сложную структуру (т.е. таблица
      #  фактически может работать с разным набором данных), то необходимо
      #  определенным образом обработать результат.
      if isComplexResultKey
         complexDataParams = _.cloneDeep(@state.complexDataParams)
         complexDataParams.collection = {} unless complexDataParams.collection?
         activeDataName = complexDataParams.activeDataName

         # Перебираем все параметры составного ключа ответа.
         for resKeyParams in responseResultKey
            resKey = resKeyParams.key
            responseTemp = response[resKey]

            # Если необходимо добавить новые записи к существующему набору -
            #  соединяем наборы ("ленивая подгрузка").
            if isNeedAddToCurrentDataCollection
               activeData = complexDataParams.collection[resKey]

               if activeData? and !_.isEmpty activeData
                  if responseTemp? and _.has(responseTemp, recordsKey)
                     responseTemp.records = _.concat activeData.data.records,
                                                     responseTemp.records
                  else
                     responseTemp = activeData.data

            # Если результат ещё не был задан и ответ содержит заданный ключ считывания ответа.
            if !responseResult? and _.has(response, resKey)

               # Если задан маркер текущих отображенных составных данных и фильтр не менялся,
               #  то считываем данные по этому ключу.
               # Иначе, если ещё не было задано маркера отображенных данных, то
               #  считываем первый ключ из набора.
               if activeDataName? and !isFilterChanged
                  if activeDataName is resKey

                     responseResult = responseTemp
                     complexDataParams.activeDataName = resKey
               else if responseTemp?
                  responseResult = responseTemp
                  complexDataParams.activeDataName = resKey

            # Если удалось получить какой-то ответ - сохраняем полученные
            #  записи и заголовок в параметрах составных данных.
            #if responseTemp?
            complexDataParams.collection[resKey] =
               data: responseTemp
               caption: resKeyParams.caption

         # else
         #    responseResult = responseRecords[responseResultKey]

      # else
      #    responseResult = responseRecords

      # Если не был задан комплексный ключ считывания результата(если сложный ключ
      #  был задан - то "ленивая" подгрузка обрабатывается при работе с сложными ключами),
      #  то нужна дополнительная обработка, если была задана "ленивая" подгрузка.
      else
         responseResult = response

         # Если необходимо добавить новые записи к существующему набору -
         #  соединяем наборы ("ленивая подгрузка").
         if isNeedAddToCurrentDataCollection
            currentTableData = @state.tableData
            isFullResponse = responseResult.hasOwnProperty recordsKey

            # Если был получен "полный" ответ для таблицы, то считываем
            #  набор записей следующей страницы по ключу "records".
            # Иначе - просто получаем ответ результата считывания.
            nextTableData = if isFullResponse
                               responseResult[recordsKey]
                            else
                               responseResult

            # Новый набор формируем в зависимости от того был ли уже ранее задан
            #  какой-либо набор записей для таблицы.
            newTableData =
               if @_isEmptyRecords()
                  nextTableData
               else
                  if nextTableData? and nextTableData.length
                     _.concat currentTableData, nextTableData
                  else
                     currentTableData

            # Если это "полный" ответ, то сформированный набор записей, запишем в
            #  в ответ по ключу "records".
            if isFullResponse
               responseResult.records = newTableData
            else
               responseResult = newTableData

      result: responseResult
      complexDataParams: complexDataParams

   ###* TODO: доработать обработку ошибок.
   * Функция получения параметров ответа начальных данных.
   *
   * @param {Object} responseResult - хэш с параметрами ответа на запрос данных.
   * @param {Object} fluxParamsInit - параметры flux-параметров.
   * @return {Object} - данные необходимые для таблицы.
   ###
   _getInitResponseData: (responseResult, fluxParamsInit) ->
      if @_isFullParamResponseInit(responseResult)
         responseKeys = @_RESPONSE_KEYS
         jsonKeys = responseKeys.jsonKeys
         jsonKey = responseKeys.json

         # Если поступил ответ в формате утилит работы с API, для дальнейшей
         #  работы считываем только основные данные.
         if _.has(responseResult, jsonKey)
            responseResult = responseResult[jsonKey]

         records: responseResult[jsonKeys.records]
         entityParams: responseResult[jsonKeys.entityParams]
         paginateParams: responseResult[jsonKeys.paginateParams]
      else
         getFieldParamsHandler = fluxParamsInit.getFieldParams
         getPageCountHandler = fluxParamsInit.getPageCount
         getEntriesStatisticHandler = fluxParamsInit.getEntriesStatistic

         records: responseResult
         fieldParams: getFieldParamsHandler() if getFieldParamsHandler?
         pagesCount: getPageCountHandler() if  getPageCountHandler?
         entriesStatistic: getEntriesStatisticHandler() if getEntriesStatisticHandler?

   ###*
   * Функция на получение значений таблицы, соответствующих поисковому выражению.
   *
   * @return
   ###
   _getResponseSearch: ->
      fluxParams = @props.fluxParams

      @setState
         tableData: fluxParams.search.getResponse()
         pagesCount: fluxParams.search.getPageCount()

   ###*
   * Функция получения хэша параметров родительской записи из набора данных таблицы по
   *  ИД родителя.
   *
   * @param {Array} records - набор записей.
   * @param {Number} recordID - ид искомой записи.
   * @return {Object} - родетельская запись.
   ###
   _getRecordInHierarchy: (records, recordID) ->
      for record in records
         parent = record if record.key is recordID

         unless parent?
            childs = record.childs

            if childs?
               parent = @_getRecordInHierarchy(childs, recordID)
      parent

   ###*
   * Функция получения выбранных записей в пределах отображенной страницы.
   *
   * @return {Array} - выбранные записи на текущей странице.
   ###
   _getSelectedRecordOnPage: ->
      markedRowsOnPage = @_getMarkedRowsOnPage()

      selectedRecordInPage = []

      for rowKey in markedRowsOnPage
         selectedRecord = @getRecord(rowKey)

         if selectedRecord?
            selectedRecordInPage.push selectedRecord

      selectedRecordInPage

   ###*
   * Функция получения элемента строки по ключу.
   *
   * @return {React-element, undefined}
   ###
   _getRowByKey: (rowKey) ->
      refPrefixes = @_REFS

      if rowKey?
         rowRefPrefix =
            if @_isHierarchicallyViewTable()
               refPrefixes.node
            else
               refPrefixes.row

         rowRef = [rowRefPrefix, rowKey].join @_CHARS.underscore
         @refs[refPrefixes.rows].refs[rowRef]

   ###*
   * Функция получения элемента текущей активированной строки.
   *
   * @return {React-element, undefined}
   ###
   _getActivatedRow: ->
      @_getRowByKey(@state.touchedRecordID)

   ###*
   * Функция установки состояния по операции над записью.
   *
   * @return
   ###
   _setOperationDialogState: (operation) ->
      @setState recordOperation: operation

   ###*
   * Обработчик клика на кнопку показа области настройки таблицы.
   *  Скрывает/показывает область настроек таблицы.
   *
   * @return
   ###
   _onClickSettingsTrigger: ->
      @setState isSettingsAreaOpen: !@state.isSettingsAreaOpen

   ###*
   * Обработчик клика на кнопку показа области настройки таблицы.
   *  Скрывает/показывает область настроек таблицы.
   *
   * @return
   ###
   _onClickDataExportTrigger: ->
      @setState isDataExoprtAreaOpen: !@state.isDataExoprtAreaOpen

   ###*
   * Обработчик на скролл в обертке для данных. Если задана ленивая загрузка записей
   *  проверяет и при необходимости запускает подгрузку следующей страницы.
   *
   * @param {Event-object} event - объект события.
   * @return
   ###
   _onScrollDataWrapper: (event)->
      if @props.enableLazyLoad
         wrapper = event.target
         wrapperHeight = wrapper.getBoundingClientRect().height
         wrapperScrollTop = wrapper.scrollTop
         wrapperScrollHeight = wrapper.scrollHeight
         entriesStatistic = @state.paginateParams.entriesStatistic

         # Для иерархического представления - определяем конечное значение
         #  выведенных корневых узлов.
         isExistNotLoadedRecords =
            if @_isHierarchy()
               rootEnd = entriesStatistic.rootEnd || entriesStatistic.end
               entriesStatistic.total > rootEnd
            else
               entriesStatistic.total > entriesStatistic.end

         isNeedNewRequest = (wrapperScrollTop + wrapperHeight + 50) >
                             wrapperScrollHeight
         isTableNotRequesting = @state.tableState isnt @_TABLE_STATES.requesting
         isWrapperWithScroll = wrapperScrollHeight > wrapperHeight

         if isExistNotLoadedRecords and isNeedNewRequest and
         isTableNotRequesting and isWrapperWithScroll
            @setState activePage: @state.activePage + 1

   ###*
   * Обработчик на перемещение строки.  Производит сортировку данных таблицы в соответствии
   *  с перемещением строки.
   *
   * @param {Number} dragRowKey  - ключ перемещаемой записи.
   * @param {Objcet} rowPosition - хэш с параметрами позиционирования перемещаемой записи.
   * @return
   ###
   _onRowDragAndDropTerminate: (dragRowKey, rowPosition) ->
      newTableData = @state.tableData[..]
      dataTable = this

      newTableData.sort (active, next) ->
         activeRowKey = active.key
         nextRowKey = next.key

         activeRowPosition = dataTable._getRowClientRect(activeRowKey,
                                             dragRowKey,
                                             rowPosition)
         nextRowPosition = dataTable._getRowClientRect(nextRowKey,
                                           dragRowKey,
                                           rowPosition)

         activeRowPosition.top - nextRowPosition.top

      @setState tableData: newTableData

   ###*
   * Обработчик клика на кнопку массовой операции над записями.
   *
   * @param {String} operationName - наименование операции над записями.
   * @return
   ###
   _onClickMassOperation: (operationName) ->
      massOperation = @_getMassOperationByName operationName
      dialogInteractionTypes = @_DIALOG_INTERACTION_TYPES

      # Если задана такая массовая операция
      if massOperation?
         fluxParams = massOperation.fluxParams
         customData = massOperation.customData
         isDialog = massOperation.contentParams? and
                    !_.isEmpty massOperation.contentParams
         markedRowKeys = @_getMarkedKeys()

         # Если для операции заданы параметры взаимодействия с бизнес-логикой и
         #  это не диалоговая операция - выполняем непосредственное
         #  взаимодействие с бизнес-логикой(с запросом подтверждения или без).
         if fluxParams? and !_.isEmpty(fluxParams) and !isDialog
            selectedRecordOnPage = @_getSelectedRecordOnPage()
            confirmText = massOperation.confirmText
            selectedRecordsValidatorParams = massOperation.recordsValidatorParams
            selectedRecordsHandler = massOperation.recordsHandler

            # Если задан валидатор и/или обработчик выбранных записей
            #  получаем отмеченные записи(только на текущей странице) и
            #  прогоняем их через валидатор и/или обработчик.
            if selectedRecordsValidatorParams? or selectedRecordsHandler?
               validateHandler =
                  if selectedRecordsValidatorParams?
                     selectedRecordsValidatorParams.handler

               processedRecordsData =
                  if selectedRecordsHandler?
                     selectedRecordsHandler(selectedRecordOnPage)

               # Если задан обработчик валидатора выбранных записей -
               #  то запускаем его и если он возвратил отрицательный
               #  результат - выводим ошибку (заданные в параметрах или
               #  стандартную) и прерываем дальнейшее выполнение операции.
               if validateHandler?
                  validateResult = validateHandler(selectedRecordOnPage)

                  # Если был возвращен не пустой результат валидации - значит
                  #  валидация не была пройдена.
                  if validateResult? and !_.isEmpty validateResult
                     failedRecords = validateResult.failedRecords

                     failText =
                        validateResult.error or
                        selectedRecordsValidatorParams.failText or
                        @_MESSAGES.errors.massOperations.failValidate

                     validateState =
                        dialogInteractionParams:
                           type: dialogInteractionTypes.error
                           text: failText

                     if selectedRecordsValidatorParams.isMarkFailedRow and
                     failedRecords?
                        validateState.tableData =
                           @_markRowsAsFailed(failedRecords)

                     @setState validateState

                     return

            operationParams =
               fluxParams: fluxParams
               data:
                  markedKeys: markedRowKeys
                  isAllMarked: @state.isAllRowsMarked
                  processedData: processedRecordsData
                  filterParams: @state.filterParams
                  customData: customData

            # Если задан текст запроса подтверждения - выполним операцию только
            #  после утвердительного ответа на запрос диалога.
            # Иначе - выполним отправку запроса здесь.
            if confirmText
               @setState
                  dialogInteractionParams:
                     type: dialogInteractionTypes.confirm
                     text: massOperation.confirmText
                     value: operationParams
                     callback: @_onConfirmMassOperation
            else
               @_onConfirmMassOperation operationParams

         @setState appliedMassOperation: massOperation

   ###*
   * Функция пометки заданных строк флагом ошибки (для дальнейшей подсветки).
   *  Помечает все строки ошибочными, ключи которых заданы через параметр
   *  failedRows, и если не задан флаг не сбросывания пометки isNotResetFailed
   *  для остальных(не входящих в набор failedRows) сбрасывает пометку ошибочности.
   *
   * @param {Array<Number>} failedRows - набор ключей, строк, необходимых для пометки.
   * @param {Boolean} isSetInState     - флаг необходимости сохранения в состоянии
   *                                     компонента помеченных данных. Если
   *                                     флаг не задан - возвращает обработанные данные таблицы.
   * @param {Boolean} isNotResetFailed - флаг не сбрасывания флага ошибочности у строк
   *                                     ключи которых не входят в набор failedRows.
   * @return {Array, undefined}
   ###
   _markRowsAsFailed: (failedRows, isSetInState, isNotResetFailed) ->
      clonedTableData = _.cloneDeep @state.tableData

      for row, idx in clonedTableData
         if ~_.indexOf(failedRows, row.key)
            row.isFailed = true
         else unless isNotResetFailed
            delete row.isFailed
         clonedTableData[idx] = row

      if isSetInState
         @setState tableData clonedTableData
      else
         clonedTableData

   ###*
   * Обработчик на подтверждение действия массовой операции над записями. Вызывается
   *  непосредственно при клике на кнопку массовых действий или при подтверждении в
   *  диалоге взаимодействия.
   *
   * @param {Object} params - хэш параметров. Вид:
   *        {Object} fluxParams - параметры взаимодейтсвия с БЛ.
   *        {Object} data       - хэш с параметрами на отправку. Вид:
   *              {Object} markedKeys    - хэш с параметрами отмеченных строк и
   *                                      строк со снятой отметкой.
   *              {Object} processedData - специфичные данные для операции, подготовленные
   *                                              пользовательскими обработчиками.
   *              {Boolean} isAllMarked  - флаг отметки всех строк.
   *              {Object} filterParams  - параметры фильтра.
   * @return
   ###
   _onConfirmMassOperation: (params) ->
      # Если для операции заданы параметры отправки запроса - отправляем, с передачей
      #  параметров
      params.fluxParams.sendRequest params.data, @props.instanceID

   ###*
   * Обработчик на закрытие диалога взаимодействия. Сбрасывает параметры для диалога
   *  взаимодействия.
   *
   * @return
   ###
   _onHideDialogInteraction: ->
      @setState
         dialogInteractionParams: @_getInitDialogInteractionParams()

   ###*
   * Обработчик применения/отмены составного фильтра. Отправляет запров на получение
   *  данных таблицы с параметрами фильтра.
   *
   * @param {Object} filterParams - параметры фильтра.
   * @return
   ###
   _onApplyFilter: (filterParams) ->
      filterParams ||=
         filter: {}

      paramsForRequest =
         activePage: 1
         newFilterParams: filterParams

      @_sendInitRequest paramsForRequest

   ###*
   * Обработчик после открытия/скрытия панели операций над записями на панели
   *  действий таблицы. Запускает скрытие/показ неотмеченных записей.
   *
   * @param {String} activePanel - наименование текущей активной панели.
   * @return
   ###
   _onAfterTriggerPanel: (activePanel) ->
      @_applyMarkedFilter(activePanel)

      @setState
         activeOperationsPanel: activePanel
         recordOperation: @_RECORD_OPERATIONS.none

   ###*
   * Обработчик клика по селектору всех записей (в заголовке колонок).
   *
   * @param {Boolean} isAllSelected - флаг выбранности всех строк.
   * @return
   ###
   _onClickSelectAll: (isAllSelected) ->
      @setState
         isAllRowsMarked: isAllSelected
         recordOperation: @_RECORD_OPERATIONS.none
         markedRows: {}

   ###*
   * Обработчик клика по селектору составных данных (выбор какие данные отображать).
   *
   * @param {Boolean} complexDataName - имя набора данных.
   * @param {Number} buttonIndex - индекс кнопки из набора, по которой был сдалан клик.
   * @param {Object} event - объект события.
   * @return
   ###
   _onClickComplexDataSelector: (complexDataName, buttonIndex, event) ->
      complexDataParams = @state.complexDataParams
      complexDataActive = complexDataParams.activeDataName
      complexDataCollection = complexDataParams.collection

      if complexDataName isnt complexDataActive
         complexDataParams.activeDataName = complexDataName
         newData = complexDataCollection[complexDataName].data

         @setState
            complexDataParams: complexDataParams
            tableData: newData.records
            fieldParams: newData.fieldParams
            pagesCount: newData.pagesCount
            entriesStatistic: newData.entriesStatistic

   ###*
   * Обработчик клика по селектору строки. Добавляет значение отмеченности/снятия
   *  отметки со строки, по которой произошел клик. Также проверяет наличие отмеченных
   *  строк вообще и убирает флаг отметки всех строк, если больше нет отмеченных,
   *  запускает доп. обработку для таблицы в иерархическом представлении, запускает
   *  обработчик на выбор строки.
   *
   * @param {Event-Object} event     - объект события.
   * @param {String} rowID           - идентификатор строки, которую пометили/сняли пометку.
   * @param {Boolean} isChecked      - флаг отмеченности.
   * @param {Array} hierarchyKeyPath - путь-цепь до выбранного узла в иерархии
   *                                   (актуально для иерархических представлений).
   * @return
   ###
   _onRowSelect: (event, rowID, isChecked, hierarchyKeyPath) ->
      markedRows = _.cloneDeep(@state.markedRows)
      markedNodes = _.cloneDeep(@state.markedNodes)
      isAllRowsMarked = @state.isAllRowsMarked
      isHasMarkedRows = @_isHasMarkedRows()
      isAllMarked = if !isHasMarkedRows and isAllRowsMarked
                       false
                    else
                       isAllRowsMarked
      onSelectRowHandler = @props.onSelectRow

      if @_isTree()
         markedRows = @_additionNodeMarkedProcess(isChecked,
                                                  markedNodes,
                                                  hierarchyKeyPath)
         markedNodes[hierarchyKeyPath.join()] = isChecked

         if onSelectRowHandler?
            onSelectRowHandler(hierarchyKeyPath, markedNodes)
      else
         markedRows[rowID] = isChecked

         onSelectRowHandler(rowID, markedRows) if onSelectRowHandler?

      # Если панель операций открыта и есть отмеченные записи - отправим запрос
      #  на перечитывание записей.
      if @_isActiveMassApplicationPanel() and isHasMarkedRows
         @_applyMarkedFilter()

      @setState
         markedRows: markedRows
         markedNodes: markedNodes
         recordOperation: @_RECORD_OPERATIONS.none
         isAllRowsMarked: isAllMarked

   ###*
   * Обработчик на скрытие уведомления. Сбрасывает текст уведомления, для того, чтобы
   *  уведомление не показывалось снова.
   *
   * @return
   ###
   _onHidePopupFlash: ->
      @setState popupParams: @_getInitPopupFlashParams()

   ###*
   * Обработчик на клик по кнопке создания новой записи.
   *
   * @return
   ###
   _onClickNewRecord: ->
      @setState
         recordOperation: @_RECORD_OPERATIONS.create
         touchedRecordID: ''

   ###*
   * Функция клика на опцию строки. Принимает ключ записи, по которой будет
   *  произведена операция и наименование операции.
   *
   * @param {String rowID}     - идентификатор записи.
   * @param {String} operation - наименование операции над записью.
   * @return
   ###
   _onRowOptionClick: (rowID, operation)->
      isStandardOperation = _.has(@_RECORD_OPERATIONS, operation)
      dialogInteractionTypes = @_DIALOG_INTERACTION_TYPES

      # Проверим это стандартная опция таблицы (член хэша _RECORD_OPERATIONS).
      # Если не стандартная - значит пользовательская
      if isStandardOperation

         # Если это стандартная операция удаления
         if operation is @_RECORD_OPERATIONS.delete
            @setState
               dialogInteractionParams:
                  text: @_CONFIRM_DELETE_TEXT
                  type: dialogInteractionTypes.confirm
                  value: rowID
                  callback: @_onConfirmDelete
      else
         customOperation = @_getCustomOperation operation
         # Если пользовательская опция содержит параметры содержимого, то это диалоговая
         #  опция(есть параметры для формирования формы).
         # Иначе - это простая опция и нужно отправить запрос по ИД записи.
         isDialog = customOperation.contentParams?
         confirmText = customOperation.confirmText


         # Если это не диалог - отправляем запрос пользовательского действия.
         unless isDialog
            fluxParamsCustom = customOperation.fluxParams
            customHandler = customOperation.customHandler

            # Если заданы параметры работы с flux - реализуем операцию через
            #  инфраструктуру flux,
            # Иначе, если задан произвольный обработчик - запускаем его с передачей
            #  ему записи по строке.
            if fluxParamsCustom?
               fluxSendRequestHandler = fluxParamsCustom.sendRequest

               # Если задан текст подтверждения операции - создаем диалог
               #  на подтверждение действия и по подтвержедению отправляем
               #  запрос.
               if confirmText?
                  @setState
                     dialogInteractionParams:
                        text: confirmText
                        type: dialogInteractionTypes.confirm
                        value: rowID
                        callback: ->
                           if fluxSendRequestHandler?
                              fluxSendRequestHandler rowID
               else if fluxSendRequestHandler?
                  fluxSendRequestHandler rowID
            else if customHandler?
               customHandler @getRecord(rowID)

         operation = customOperation

      @setState
         touchedRecordID: rowID
         recordOperation: operation

   ###*
   * Обработчик на подтверждения удаления записи. Отправляет запрос на удаление
   *
   * @param {Number, String} deletedID - идентификатор строки.
   * @return
   ###
   _onConfirmDelete: (deletedID)->
      isHasFluxParams = @_isHasFluxParams()
      isUseServiceFlux = @_isUseServiceFlux()
      modelParams = @props.modelParams
      model = modelParams.name
      modelRelations = modelParams.relations

      if isUseServiceFlux
         APIMethods = ServiceFluxConstants.APIMethods

         paramsForRequest =
            requestData:
               relations: modelRelations
            instanceID: deletedID
            componentID: @_componentIdentifier
            model: model
            APIMethod: APIMethods.destroy

         ServiceActionCreators.dataRequest paramsForRequest
      else if isHasFluxParams
         deleteParams = @props.fluxParams.delete

         deleteParams.sendRequest deletedID if deleteParams?

   ###*
   * Обработчик на перемещение по иерархии.
   *
   * @param {Number} recordsCount - кол-во записей на текущем уровне иерархии.
   * @return
   ###
   _onHierarchyNavigate: (recordsCount) ->
      entriesStatistic = @state.paginateParams.entriesStatistic
      entriesStatisticHierarchyKeys = @_HIERARCHY_ENTRIES_STAT_KEYS
      rootStartKey = entriesStatisticHierarchyKeys.rootStart
      rootEndKey = entriesStatisticHierarchyKeys.rootEnd

      # Сначала сохраним статистику по началу и окончанию кол-ва корневых записей.
      if !entriesStatistic.hasOwnProperty(rootEndKey) and
      !entriesStatistic.hasOwnProperty(rootStartKey)
         entriesStatistic[rootEndKey] = entriesStatistic.start
         entriesStatistic[rootEndKey] = entriesStatistic.end

      entriesStatistic.start = 1
      entriesStatistic.end = recordsCount

      @setState entriesStatistic: entriesStatistic

   ###*
   * Обработчик на событие скрытия диалога добавления новой записи.
   *  Сбрасывает значение текущей операцией над записью и текущую примененную
   *  массовую операцию.
   *
   * @return
   ###
   _onHideDialogOperations: ->
      @setState
         recordOperation: @_RECORD_OPERATIONS.none
         appliedMassOperation: null

   ###*
   * Обработчик на смену кол-ва записей на странице. Перебрасывает на страницу, где будет видна
   *  первая запись старой страницы.
   *
   * @param {String} perPage - кол-во записей на странице
   * @return
   ###
   _onChangePerPage: (perPage) ->
      activePage = @state.activePage

      if activePage isnt 1
         # Запись, на которой находится пользователь
         firstItem = (@state.activePage - 1) * @state.perPage + 1

         if firstItem < perPage
            activePage = 1
         else
            if firstItem % perPage is 0
               activePage = firstItem / perPage
            else
               activePage = Math.floor(firstItem / perPage) + 1

      paramsForRequest =
         activePage: activePage
         perPage: perPage

      @_sendInitRequest paramsForRequest

   ###*
   * Обработчик на ввод в строку поиска. Отправляет поисковый запрос в БЛ.
   *
   * @param {String} searchValue - значение в поле ввода
   * @return
   ###
   _onSearch: (searchValue) ->
      @_doSearch searchValue

   ###*
   * Обработчик получения ответом динамической формы. Если был передан диалог,
   *  полностью выполненной операции закрывает диалог.
   *
   * @param {Object} _result     - результат операции.
   * @param {Boolean} isComplete - флаг полностью выполненной операции.
   * @return
   ###
   _onAfterGetResponseDynamicForm: (result, isComplete) ->
      dialog = @refs.operationDialog

      dialog.close() if isComplete


   ###*
   * Обработчик на сброс поискового выражения. Запускается по очистке поля поиска.
   *  Отправляет запрос со сброшенным параметров поисковой фильтрации, сбрасывает
   *  искомую подстроку(для сброса подсветки найденных вхождений подстроки).
   *
   * @return
   ###
   _onClearSearch: ->
      emptyChar = @_CHARS.empty

      # Производим действия по сброса поиска только если поиск ещё не был сброшен.
      if @state.searchExpression isnt emptyChar
         preparingState = searchExpression: emptyChar
         isSearchDoOnClient = @props.isSearchDoOnClient
         isFullyClientMode = @props.isFullyClientMode

         # Если задан флаг поиска только на клиенте или полностью режима работы
         #  на клиенте
         # Подготавливаем и отправляем параметры пустого поискового запроса
         if isSearchDoOnClient or isFullyClientMode
            preparingState = @mergeObjects(preparingState,
                                           @_searchInTableData emptyChar)
         else
            paramsForRequest =
               activePage: @props.startPage
               newFilterParams:
                  search: null

            @_sendInitRequest paramsForRequest

         @setState preparingState

   ###*
   * Обработчик на выбор страницы. Отправляет инициализационный запрос
   *  на получение данных передавая номер выбранной страницы, если не задан
   *  режим работы только на клиенте. Если задан режим работы только на
   *  клиенте - выбирает записи из инициализационных данных и сохраняет в состоянии.
   *
   * @param {Number} pageNumber - номер страницы.
   * @return
   ###
   _onPageSelect: (pageNumber) ->

      # Если задана опция работы полностью на клиенте, то отбираем записи на следующей
      #  странице из изначально заданных записей.
      # Иначе отправляем запрос на получение данных в API.
      if @props.isFullyClientMode
         initData = @state.initData
         initRecords = initData.tableData if initData?
         paginateParams = @state.paginateParams
         perPage = @state.perPage

         if paginateParams?
            entriesStatistic = paginateParams.entriesStatistic
            totalPages = paginateParams.totalPages

            if pageNumber <= totalPages and entriesStatistic?
               totalRecords = entriesStatistic.total
               agregatePage = pageNumber - 1
               newStart = (agregatePage * perPage) + agregatePage
               newEnd = newStart + perPage
               newTableData = initRecords.slice(newStart, newEnd)

               if newEnd > totalRecords
                  newEnd = totalRecords

               entriesStatistic.start = newStart or 1
               entriesStatistic.end = newEnd
               paginateParams.entriesStatistic = entriesStatistic

               @setState
                  paginateParams: paginateParams
                  tableData: newTableData
                  activePage: pageNumber
      else
         @setState  activePage: pageNumber

   ###*
   * Обработчик на экспорт данных. Отправляет запрос на подготовку файлов
   *  экспорта данных по параметрам.
   *
   * @param {Object} exportParams - параметры серилизации. Вид:
   *        {String} format - выбранный формат экспорта.
   *        {Number} recordsOnFile - кол-во записей на файл.
   *        {Boolean} isLocalizeCaptions - флаг локализации наименований полей.
   *        {Boolean} isUseAppliedSerializer - флаг использования прикладного серилизатора.
   * @return
   ###
   _onExportData: (exportParams) ->
      recordsOnFile = exportParams.recordsOnFile
      isCorrectCount = (recordsOnFile? and +recordsOnFile >= 1)

      if isCorrectCount
         @_sendExportRequest(exportParams)

         @setState isExportRequested: true
      else
         exportValidationParams = @_DATA_EXPORT_VALIDATION_PARAMS

         @setState
            dialogInteractionParams:
               type: @_DIALOG_INTERACTION_TYPES.error
               caption: exportValidationParams.caption
               text: exportValidationParams.texts.wrongRecordOnFileCount


   ###*
   * Обработчик на скрытие карточки объекта. Сбрасывает маркер операций над записями.
   *
   * @return
   ###
   _onHideObjectCard: ->
      @setState recordOperation: @_RECORD_OPERATIONS.none
      @_focusOnDataContainer()

   ###*
   * Обработчик на срытие области экспорта данных.
   *
   * @return
   ###
   _onHideDataExportArea: ->
      @setState isDataExoprtAreaOpen: false

   ###*
   * Обработчик на срытие области настроек таблицы.
   *
   * @return
   ###
   _onHideSettingsArea: ->
      @setState isSettingsAreaOpen: false

   ###*
   * Обработчик на изменение состояния сервисного хранилища. Обрабатывает
   *  стандартные события сервисной инфраструктуры flux работы с API.
   *
   * @return
   ###
   _onChangeService: ->
      modelParams = @props.modelParams
      model = modelParams.name
      componentIdentifier = @_componentIdentifier
      APIMethods = ServiceFluxConstants.APIMethods
      isEventOccuredForComponent =
         ServiceStore.isEventOccuredForComponent(model, componentIdentifier)
      isEventOccuredForModel = ServiceStore.isEventOccuredForModel(model)
      lastEvent = ServiceStore.getLastEvent()

      # Считаем параметры последнего события в хранилище.
      if lastEvent?
         lastAPIMethod = lastEvent.APIMethod
         lastCustomMethod = lastEvent.customMethod

      # Получаем данные операции - в зависимости от того данные произошли точно
      #  для данного компонента или для данной модели.
      responseData =
         if isEventOccuredForComponent
            ServiceStore.getData(model,
                                 componentIdentifier,
                                 lastAPIMethod,
                                 lastCustomMethod)
         else if isEventOccuredForModel
            ServiceStore.getDataByEvent(lastEvent)

      # Если данные операции были получены вызывает различные обработчики в
      #  зависимости от метода операции - если для события задан произвольный
      #  метод - запускаем обработчик ответа произвольного метода в иных случаях
      #  по методу взаимодействия запускаем обработчики стандартных методов работы
      #  с  API.
      if responseData?
         if lastCustomMethod?
            @_getResponseCustom(responseData)
         else
            if isEventOccuredForComponent
               switch lastAPIMethod
                  when APIMethods.index
                     @_getResponseInit(responseData)
                  when APIMethods.destroy
                     @_getResponseDelete(responseData)
                  when APIMethods.export
                     @_getResponseExport(responseData)
            else if isEventOccuredForModel
               switch lastAPIMethod
                  when APIMethods.create
                     @_getResponseCreate(responseData)
                  when APIMethods.update
                     @_getResponseUpdate(responseData)

            # Запустим функцию выполнения действий после выполнения операции.
            @_processOperationAftereffect()

   ###*
   * Обработчик изменения в хранилище flux при пользовательской операции над записью.
   *
   * @return
   ###
   _onChangeCustom: ->
      recordOperation = @state.recordOperation

      if recordOperation?
         fluxParams = recordOperation.fluxParams

         if fluxParams?
            storeLastInteraction = fluxParams.store.getLastInteraction()
            customOption = @_getCustomOperation(null, storeLastInteraction)

            @_getCustomResponse(customOption)

            # Запустим функцию выполнения действий после выполнения операции.
            @_processOperationAftereffect()


   ###*
   * Обработчик изменения в хранилище flux при пользовательской операции над
   *  набором записей.
   *
   * @return
   ###
   _onChangeMassOperation: ->
      massOperation = @state.appliedMassOperation

      # Если считали массовую операцию - продолжим.
      if massOperation? and !_.isEmpty(massOperation)
         fluxParams = massOperation.fluxParams
         lastInteraction = fluxParams.store.getLastInteraction()
         isResponseToThisOperation = lastInteraction is fluxParams.responseType

         if isResponseToThisOperation
            response = fluxParams.getResponse()
            popupFlashTypes = @refs.popupFlasher.getFlashTypes()
            popupIdentifier = @_getMarkedKeys()

            if @_isResponseHasErrors response
               popupText = response.errors # @_getResponseErrorsString response.errors
               popupType = popupFlashTypes.error
            else
               responseContent = response.json
               popupText = massOperation.responseText
               popupType = popupFlashTypes.info
               popupIdentifier = @_getMarkedPopupFlashIdentifier()

            # Если задан флаг снятия отметки с выделенных строк -
            #  снимем отметки с отмеченных строк и сбросим флаг отметки всех строк.
            # Иначе просто перечитываем записи после операции.
            if massOperation.isUnsetMarkedOnCallback
               @setState
                  markedRows: {}
                  isAllRowsMarked: false
            else
               @_rereadAfterOperation()

            @setState
               popupParams: @_getPopupParams popupText,
                                             popupIdentifier,
                                             popupType

   ###*
   * Обработчик на изменение состояния хранилища. Обрабатывает события, заданные
   *  параметрами инфраструктуры flux через свойтсва @props.fluxParams.
   *
   * @return
   ###
   _onChange: ->
      #return unless @isMounted()

      fluxParams = @props.fluxParams
      storeLastInteraction = fluxParams.store.getLastInteraction()
      initResponse = fluxParams.init and fluxParams.init.responseType
      createResponse = fluxParams.create and fluxParams.create.responseType
      updateResponse = fluxParams.update and fluxParams.update.responseType
      deleteResponse = fluxParams.delete and fluxParams.delete.responseType

      switch storeLastInteraction
         # ответ инициализационного запроса.
         when initResponse
            @_getResponseInit()
         # ответ запроса на добавление записи.
         when createResponse
            @_getResponseCreate()
         # ответ запроса на обновление записи.
         when updateResponse
            @_getResponseUpdate()
         # ответ запроса на удаление записи.
         when deleteResponse
            @_getResponseDelete()

   ###*
   * Обработчик клика по заголовку колонки таблицы
   *
   * @param {String} columnName - имя колонки.
   * @return
   ###
   _onColumnHeaderClick: (columnName) ->
      newOrder = if @state.orderDirection is 'DESC' then 'ASC' else 'DESC'

      @setState
         tableData: @_orderColumns(columnName, @state.tableData)
         orderDirection: newOrder
         orderedField: columnName
         recordOperation: @_RECORD_OPERATIONS.none

   ###*
   * Обработчик клика по строке таблице. Посылает данные по строке в обработчик.
   *  Устанавливает в состояние компонента запись по которой был клик в текущую
   *  активную запись.
   *
   * @param {Object} recordData - запись или хэш данных по записи и родительской
   *                              записи (для иерархических представлений).
   * @param {React-element-ref} rowRef - ссылка на строку таблицы данных.
   * @param {Array} hierarchyKeyPath - путь ключей до узла(для иерархии).
   * @return
   ###
   _onRowClick: (recordData, rowRef, hierarchyKeyPath) ->
      onRowClickHandler = @props.onRowClick

      # Если задан обработчик клика по строке таблице - вызываем обработчик и
      #  передаем в него данные по строке и текущий активный набор составных данных
      #  (если параметры такового заданы).
      if onRowClickHandler?
         complexDataParams = @state.complexDataParams
         acitveDataName =
            if complexDataParams? and !_.isEmpty complexDataParams
               complexDataParams.activeDataName

         onRowClickHandler recordData, acitveDataName, hierarchyKeyPath

      # Если задан флаг выбора строки по клику - запустим обработчик выбора строки.
      if @props.enableRowSelectByClick
         rowID = recordData.key
         isChecked = rowRef.isSelected()
         @_onRowSelect(null, rowID, !isChecked, hierarchyKeyPath)

      # Если таблица в иерархическом виде - проверим был задан возврат родительской
      #  записи вместе с записью, по строке которой был клик. В зависимости от этого
      #  возьмем ключ от записи или сначала извлечем запись из хэша и затем возьмем ключ.
      recordKey =
         if @_isHierarchicallyViewTable()
            hierarchyViewParams = @props.hierarchyViewParams
            isReturnRecordWithParent =
               if hierarchyViewParams? and !_.isEmpty hierarchyViewParams
                  !!hierarchyViewParams.enableSelectRootOnActivateChild
            if isReturnRecordWithParent
               recordData.record.key
            else
               recordData.key
         else
            recordData.key

      @setState
         recordOperation: @_RECORD_OPERATIONS.view
         touchedRecordID: recordKey
         touchedNodePath: hierarchyKeyPath
         touchedRow: rowRef

   ###*
   * Обработчик на обновление данных по записи.
   *
   * @param {Object} refreshedRecord - данные обновленной записи.
   ###
   _onRefreshRecord: (refreshedRecord) ->
      @refreshRecord(refreshedRecord)

   ###*
   * Обработчик клика по кнопке пользовательского фильтра. Подготавливает
   *  параметры фильтра для запроса начальных данных и вызывает функцию отправки
   *  запроса.
   *
   * @param {Object, null} filterValue - параметры пользователького фильтра.
   * @return
   ###
   _onClickUserFilter: (filterValue)->
      paramsForInitRequest =
         if filterValue? and !_.isEmpty filterValue
            # Для пользовательского фильтра добавим маркер, для отличия от обычного
            #  комплексного фильтра.
            filterValue.filter.isUser = true

            activePage: 1
            newFilterParams: filterValue
            isFilterConcat: false
         else
            newFilterParams:
               filter: null
            isFilterConcat: false

      @_sendInitRequest paramsForInitRequest

   ###*
   * Обработчик события после получения пользовательских фильтров.
   *
   * @param {Array} filters - массив пользовательских фильтров.
   * @return
   ###
   _onAfterReceiveFilters: (filters)->
      @setState userFilters: filters

   ###*
   * Обработчик события после создания фильтра. Создает параметры уведомления
   *  о сохранении фильтра и обновляет набор пользовательских фильтров.
   *
   * @param {Object} newFitlerParams - параметры нового фильтра.
   * @return
   ###
   _onAfterCreateFilter: (newFilterParams) ->
      @_executeUserFiltersOperation(@_RECORD_OPERATIONS.create,
                                    newFilterParams)

   ###*
   * Обработчик события после обновления фильтра. Создает параметры уведомления
   *  о сохранении фильтра и обновляет набор пользовательских фильтров.
   *
   * @param {Object} newFitlerParams - параметры нового фильтра.
   * @return
   ###
   _onAfterUpdateFilter: (updatedFilterParams) ->
      @_executeUserFiltersOperation(@_RECORD_OPERATIONS.update,
                                    updatedFilterParams)

   ###*
   * Обработчик события после удаления фильтра. Создает параметры уведомления
   *  о сохранении фильтра и обновляет набор пользовательских фильтров.
   *
   * @param {Object} newFitlerParams - параметры нового фильтра.
   * @return
   ###
   _onAfterDeleteFilter: (deletedKey) ->
      @_executeUserFiltersOperation(@_RECORD_OPERATIONS.delete,
                                    deletedKey)

   ###*
   * Обработчик нажатия клавиши не контейнере данных. Выполняет управляющие
   *  операции над таблицей (переход по записям, переход между страницами, показ
   *  карточки).
   *
   * @param {Object} event - объект события.
   * @return
   ###
   _onKeyDownDataContainer: (event) ->
      #event.stopPropagation()
      #event.preventDefault()

      keyCodes = @_KEY_CODES
      refs = @_REFS
      touchedRecordID = @state.touchedRecordID
      eventKeyCode = event.keyCode
      upCode = keyCodes.up
      downCode = keyCodes.down
      leftCode = keyCodes.left
      rightCode = keyCodes.right
      isVerticalDirectKey = _.includes([upCode, downCode], eventKeyCode)
      isHorizontalDirectKey = _.includes([rightCode, leftCode], eventKeyCode)
      isEnterKey = eventKeyCode is keyCodes.enter
      onKeyDownHandler = @props.onKeyDown
      preparedState = {}

      # Кнопки "вверх", "вниз" - перемещение по записям.
      # Кнопки "вперед", "назад" - перелистывание страниц(если не задана опция
      #  ленивой подгрузки).
      # Кнопка "Enter" - эмуляция клика по строке.
      if isVerticalDirectKey
         tableData = @state.tableData
         recordsPerPage = @props.recordsPerPage

         if tableData? and !_.isEmpty tableData
            newTouchedRowIndex =
               unless touchedRecordID?
                  0
               else
                  touchedRowIndex = _.findIndex(tableData, key: touchedRecordID)

                  switch eventKeyCode
                     when upCode
                        if touchedRowIndex > 0
                           --touchedRowIndex
                        else
                           touchedRowIndex
                     when downCode
                        if touchedRowIndex is (_.size(tableData) - 1)
                           touchedRowIndex
                        else
                           ++touchedRowIndex
            newTouchedRowKey =
               if newTouchedRowIndex?
                  tableData[newTouchedRowIndex].key
               else
                  newTouchedRowIndex

            preparedState.touchedRecordID = newTouchedRowKey

            # Если задан ключ новой активной записи - выполним операции скрола
            #  контейнера данных для удержания текущей активированной записи в
            #  пределах видимой области.
            if newTouchedRowKey?
               activatedRowNode = ReactDOM.findDOMNode(@_getRowByKey(newTouchedRowKey))
               dataContainerNode = @refs.dataContainer
               event.preventDefault()
               dataContainerNode.scrollTop = activatedRowNode.offsetTop

      else if isHorizontalDirectKey and !@props.enableLazyLoad
         activePage = @state.activePage
         totalPages = @state.paginateParams.totalPages

         newActivePage =
            switch eventKeyCode
               when leftCode
                  if activePage > 0
                     --activePage
               when rightCode
                  if activePage < totalPages
                     ++activePage

         if newActivePage?
            preparedState.activePage = newActivePage

      else if isEnterKey
         @_onRowClick(@getRecord(touchedRecordID),
                      @_getRowByKey(touchedRecordID))

      unless _.isEmpty(preparedState)
         @setState preparedState

      if onKeyDownHandler?
         onKeyDownHandler event


   ###*
   * Обработчик клика на контейнере с данными. Выполняет фокусировку на контейнера
   *  с данными для возможности выполнения управляющих операций с клавиатуры.
   *
   * @param {Object} event - объект события.
   * @return
   ###
   _onClickDataContainer: (event) ->
      @_focusOnDataContainer()

   ###*
   * Обработчик клика по кнопке открытия просмотрщика руководств. Устанавливает
   *  текущую активированную цепь пути до руководства.
   *
   * @param {Array} manualPathParams - цепь элементов пути до руководства.
   * @param {Object} event - объект события.
   * @return
   ###
   _onClickOpenManual: (manualPathParams, event) ->
      event.stopPropagation()

      @setState activatedManualPathParams: manualPathParams

   ###*
   * Обработчик на скрытие просмотрщика мануалов - сбрасывает текущую
   *  активированную цепь, для избегания повторного показа при повторном рендере.
   *
   * @return
   ###
   _onHideManualViewer: ->
      @setState activatedManualPathParams: null


   ###*
   * Функция-пердикат соответсвует ли параметры операции параметрами текущего
   *  компонента таблицы данных. Сравниваются параметры @props.model
   *  и @props.modelRelation.
   *
   * @param {Object} operationInfo - данные по операции, полученные из ответа API.
   * @return {Boolean}
   ###
   _isResponseForCurrentTable: (operationInfo) ->

      if operationInfo? and !_.isEmpty operationInfo
         updatedModel = operationInfo.model
         updatedRelation = operationInfo.relation
         modelParams = @props.modelParams
         model = modelParams.name
         isModelsEqual = _.upperFirst(_.camelCase(model)) is updatedModel

         if updatedRelation? and !_.isEmpty updatedRelation
            modelRelations = modelParams.relations

            if modelRelations? and modelRelations.length
               modelLastRelations = modelRelations[modelRelations.length - 1]

               return modelLastRelations.reflection is updatedRelation.reflection
            else
               return false

         else
            return isModelsEqual

      true

   ###*
   * Фнукция определения отличаются ли следующие парметры фильтра от текущих.
   *
   * @param {Object} nextFilter - новые параметры фильтра.
   * @return {Boolean}
   ###
   _isFilterOther: (nextFilter) ->
      return JSON.stringify(@props.filterParams) isnt JSON.stringify(nextFilter)

   ###*
   * Функция-предикат для определения отличаются ли инициализационные данные.
   *
   * @param {Object} newInitData - новые инициализационные параметры.
   * @return {Boolean}
   ###
   _isInitDataOther: (newInitData) ->
      initData = @props.initData

      if initData? and newInitData?
         currentTableData = initData.tableData
         nextTableData = newInitData.tableData

         if currentTableData? and nextTableData?
            return JSON.stringify(currentTableData) isnt
                   JSON.stringify(nextTableData)

      false

   ###*
   * Функция-предикат для определения заданы ли для таблицы начальные данные.
   *
   * @return {Boolean} - флаг наличия начальных данных.
   ###
   _isHasInitData: ->
      initData = @props.initData

      if initData? and !_.isEmpty initData
         records = initData[@_DATA_KEYS.records]

         return !!(records? and records.length)

      false

   ###*
   * Функция-предикат для определения заданы ли параметры flux.
   *
   * @return {Boolean} - флаг наличия начальных данных.
   ###
   _isHasFluxParams: ->
      fluxParams = @props.fluxParams
      isFluxParamsSet = fluxParams? and !_.isEmpty(fluxParams)

      if isFluxParamsSet
         initParams = fluxParams.init
         isHasStore = fluxParams.store?
         isHasInitParams = initParams? and !_.isEmpty(initParams)

         return isHasStore and isHasInitParams

      false

   ###*
   * Функция-предикат для определения задан ли флаг использования
   *  сервисной инфраструктуры flux.
   *
   * @return {Boolean} - флаг наличия начальных данных.
   ###
   _isUseServiceFlux: ->
      fluxParams = @props.fluxParams

      fluxParams? and fluxParams.isUseServiceInfrastructure

   ###*
   * Функция-предикат для определения того, что набор записей таблицы пуст.
   *
   * @return {Boolean}
   ###
   _isEmptyRecords: ->
      tableData = @state.tableData

      !(tableData? and tableData.length)

   ###*
   * Функция-предикат для определения является ли таблица иерахическим представлением
   *
   * @return {Boolean}
   ###
   _isHierarchicallyViewTable: ->
      tableViewTypes = @_TABLE_VIEW_TYPES
      viewType = @props.viewType

      viewType is tableViewTypes.tree or viewType is tableViewTypes.hierarchy

   ###*
   * Функция-предикат для определения является ли таблица иерархическим представлением
   *  в виде дерева.
   *
   * @return {Boolean}
   ###
   _isTree: ->
      if @_isHierarchicallyViewTable()
         @props.viewType is @_TABLE_VIEW_TYPES.tree
      else
         false

   ###*
   * Функция-предикат для определения является ли таблица иерархическим представлением
   *  (по папкам)
   *
   * @return {Boolean}
   ###
   _isHierarchy: ->
      if @_isHierarchicallyViewTable()
         @props.viewType is @_TABLE_VIEW_TYPES.hierarchy
      else
         false


   ###*
   * Функция-предикат для проверки был ли применен фильтр. Перебирает все параметры
   *  фильтра ищет в параметрах заполненное значение параметра 'expr'.
   *
   * @return {Boolean}
   ###
   _isFilterApplied: ->
      filterParams = @state.filterParams
      filterKeys = @_FILTER_KEYS
      filterGroups = @_FILTER_GROUP_NAMES
      termsKey = filterKeys.terms
      exprKey = filterKeys.expr
      fieldsKey = filterKeys.fields
      keysKey = filterKeys.keys
      emptyChar = @_CHARS.empty

      if filterParams? and !_.isEmpty filterParams
         for groupName, groupParams of filterParams

            if groupParams? and _.isPlainObject groupParams

               # Производим различные проверки в зависимости от типа фильтра.
               switch groupName
                  # Сложный фильтр.
                  when filterGroups.filter
                     terms = groupParams[termsKey]

                     unless _.isEmpty(terms)
                        for fieldTerm in terms
                           #for _name, term of fieldTerm

                           if fieldTerm? and _.has(fieldTerm, exprKey)
                              expr = fieldTerm[exprKey]

                              if expr? and expr isnt emptyChar
                                 return true

                  # Поисковый фильтр.
                  when filterGroups.search
                     expr = groupParams[exprKey]
                     fields = groupParams[fieldsKey]

                     if expr? and fields?
                        if (expr? and expr isnt emptyChar) and (fields? and fields.length)
                           return true
                  # Фильтр по отмеченным.
                  when filterGroups.marked
                     keys = groupParams[keysKey]

                     if keys? and keys.length
                        return true

      false

   ###*
   * Функция-предикат для определения был ли применен сложный фильтр.
   *
   * @return {undefined, Boolean}
   ###
   _isComplexFilterApplied: ->
      complexFilter = @state.filterParams.filter

      if complexFilter?
         terms = complexFilter.terms
         isUser = complexFilter.isUser

         if terms? and !isUser
            return !!terms.length
      false

   ###*
   * Функция-предикат для определения был ли применен сложный фильтр.
   *
   * @return {Boolean}
   ###
   _isUserFilterApplied: ->
      complexFilter = @state.filterParams.filter

      if complexFilter?
         terms = complexFilter.terms
         isUser = complexFilter.isUser

         if terms? and isUser
            return !!terms.length
      false

   ###*
   * Функция-предикат для определения был ли применён фильтр по выбранным строкам.
   *
   * @return {Boolean}
   ###
   _isMarkedFilterApplied: ->
      filterParams = @state.filterParams

      if filterParams? and !_.isEmpty(filterParams)
         markedFilterParams = filterParams.marked
         markedFilterParams? and !_.isEmpty(markedFilterParams)
      else
         false

   ###*
   * Функция-предикат для определения был ли применён поисковый фильтр.
   *
   * @return {Boolean}
   ###
   _isSearchFilterApplied: ->
      filterParams = @state.filterParams

      if filterParams? and !_.isEmpty(filterParams)
         searchFilterParams = filterParams.search

         searchFilterParams? and !_.isEmpty(searchFilterParams)
      else
         false

   ###*
   * Функция-предикат для определения является ли текущая активная панель - панелью
   *  массовых операций над выделенными записями.
   *
   * @param {String} activePanel - наименование текущей активной панели операций.
   * @return {Boolean} - true - текущая активная панель действий - панель
   *                             массовых операций над выделенными записями.
   ###
   _isActiveMassApplicationPanel: (activePanel) ->
      activePanel ||= @state.activeOperationsPanel
      activePanel is @_RECORDS_OPERATIONS.massApplication

   ###*
   * Функция определения наличия отмеченных строк.
   *
   * @return {Boolean} - флаг наличия отмеченных строк.
   ###
   _isHasMarkedRows: ->
      isHasMarked = false
      markedStatistic = @_getMarkedStatistic()
      totalMarkedCount = markedStatistic.total
      markedCount = markedStatistic.marked
      unmarkedCount = totalMarkedCount - markedCount

      if @state.isAllRowsMarked
         unmarkedCount isnt @state.paginateParams.entriesStatistic.total
      else
         markedCount isnt 0

   ###*
   * Функция проверки отличаются ли новые параметры фильтрации по выделенным записям
   *  от параметров, сохраненных в состоянии.
   *
   * @param {Object} newMarkedFilterParams - массив новых условий фильтрации по
   *                                         отмеченным строкам.
   * @return {Boolean} - флаг отличия от текущих параметров.
   ###
   _isNeedSendInitRequestWithMarkedFilter: (newMarkedFilterParams) ->
      filterParams = @state.filterParams
      newMarkedTerm = newMarkedFilterParams.marked
      markedTerm = if filterParams? and !_.isEmpty(filterParams)
                      filterParams.marked

      if markedTerm
         JSON.stringify(markedTerm) isnt JSON.stringify(newMarkedTerm)
      else
         newMarkedTerm?

   ###*
   * Функция проверки по имени колонки необходимо ли её отрисовывать. Проверяет параметры
   *  columnRenderParams.
   *
   * @param {String} columnName - имя колонки.
   * @return {Boolean}
   ###
   _isRenderedColumn: (columnName) ->
      columnRenderParams =
         @_getComponentProp(@_IMPLEMENTED_PROPS.columnRenderParams)
      isRendered = true

      if columnRenderParams? and !_.isEmpty(columnRenderParams)
         isStrongRenderRule = columnRenderParams.isStrongRenderRule
         columns = columnRenderParams.columns

         if columns? and !_.isEmpty(columns)
            columnRenderRule = columns[columnName]
            isRenderRuleHasColumn = _.has(columns, columnName)

            isRendered =
               if isStrongRenderRule
                  isRenderRuleHasColumn
               else if columnRenderRule?
                  !columnRenderRule.isHidden
               else
                  true

      isRendered

   ###*
   * Функция-предикат для определения наличия ошибок в ответе из БЛ.
   *
   * @param {Object} errors - объект с ошибками.
   * @return {Boolean} - содержит ли ошибки.
   ###
   _isResponseHasErrors: (response) ->
      errors = response? and response.errors
      errors? and !_.isEmpty(errors)

   ###*
   * Функция-предикат для определения является ли ответ на запрос инициализационных
   *  данных полным (содержащим всю необходимую информацию для работы таблицы) или
   *  эти данные необходимо запрашивать(по-старому).
   *
   * @param {Object} response - объект ответа.
   * @return {Boolean} - флаг того, является ли ответ полным.
   ###
   _isFullParamResponseInit: (response) ->

      if response? and !_.isEmpty response
         responseKeys = @_RESPONSE_KEYS
         jsonKeys = responseKeys.jsonKeys
         jsonKey = responseKeys.json

         if _.has(response, jsonKey)
            response = response[jsonKey]

         for key of jsonKeys
            return false unless _.has(response, key)

         return true

      false

   ###* Фуникция-предикат для определения необходим ли запрет на вывод всех записей
   *  на странице. Проверяет общее кол-во записей для вывода в таблице на превышение
   *  заданной границе кол-ва записей.
   *
   * @return {Boolean}
   ###
   _isSuppressAllRecordsSelector: ->
      isSuppressLargeTotalRecordsOutput = @props.isSuppressLargeTotalRecordsOutput

      if isSuppressLargeTotalRecordsOutput
         paginateParams = @state.paginateParams
         entriesStatistic = paginateParams.entriesStatistic if paginateParams?

         if entriesStatistic?
            entriesStatistic.total > @_TO_MANY_RECORDS_BORDER
         else
            false
      else
         false

   ###*
   * Функция подписки на изменения хранилищ, заданных через пользовательские опции.
   *
   * @param {Boolean} isUnsubscribe - флаг отписки от изменений.
   * @return
   ###
   _subscriptionToCustomEvents: (isUnsubscribe) ->
      componentIdentifier = @_componentIdentifier
      customRowOptions = @props.customRowOptions
      massOperationParams = @props.massOperations
      massOperations = massOperationParams.operations if massOperationParams
      changeEventPrefixes = @_CHANGE_EVENT_PREFIXES

      subscribeForCollection = (subscriberCollection,
                                changeHandler,
                                identifier,
                                isUnsubscribe) ->
         changeHandler.identifier = identifier

         for subscriber in subscriberCollection
            fluxParams = subscriber.fluxParams

            if fluxParams?
               subscribedStore = fluxParams.store

               if subscribedStore?
                  isStoreHasAddChangeListener =
                     subscribedStore.addChangeListener?
                  isStoreHasRemoveChangeListener =
                     subscribedStore.removeChangeListener

                  # Если это отписка от события - просто отписываемся.
                  # Иначе - проверяем необходимо ли подписаться, если необходимо
                  # - подписываемся.
                  if isUnsubscribe
                     if isStoreHasRemoveChangeListener
                        subscribedStore.removeChangeListener changeHandler
                     else
                        # TODO: доделать выдачу предупреждений в консоль
                        log.warn()
                  else if isStoreHasAddChangeListener

                     # Получаем все обработчики на событие изменения хралища.
                     changeListeners =
                        if subscribedStore._events?
                           subscribedStore._events.change

                     isHasListeners = changeListeners? and
                                      !_.isEmpty(changeListeners)
                     isNewSubscribe = true

                     # Проверяем не подписаны ли обработчики с тем же идентификатором.
                     if isHasListeners
                        if _.isArray changeListeners
                           for listener in changeListeners
                              if listener.identifier is identifier
                                 isNewSubscribe = false
                                 break
                        else if changeListeners.identifier is identifier
                           isNewSubscribe = false

                     # Подписываемся на изменение хранилища только если еще
                     #  не было подписки.
                     if isNewSubscribe
                        subscribedStore.addChangeListener changeHandler

      if customRowOptions? and customRowOptions.length
         onCustomChangeHandler = @_onChangeCustom
         identifier = componentIdentifier + changeEventPrefixes.custom

         subscribeForCollection customRowOptions,
                                onCustomChangeHandler,
                                identifier,
                                isUnsubscribe

      if massOperations? and massOperations.length
         onMassOperationChangeHandler = @_onChangeMassOperation
         identifier = componentIdentifier + changeEventPrefixes.massOperations

         subscribeForCollection massOperations,
                                onMassOperationChangeHandler,
                                identifier,
                                isUnsubscribe

   ###*
   * Функция доп. обработки выбранных строк для иерархического древовидного
   *  вида таблицы. Доп. помечает или снимает пометку со дочерних строк выбранного
   *  узла(если у него есть дочерние) если задан флаг enableSelectChildsOnSelectParent.
   *  или родительский, если задан флаг enableSelectParentOnSelectChild. Если
   *  задан флаг enableCompetitiveRootSelectMode, то при выборе одного из
   *  корневых узлов(у которого нет родительского узла), то снимает отметки с других
   *  узлов.
   *
   * @param {Boolean} isChecked      - флаг отмеченности.
   * @param {Object} markedNodes     - хэш для хранения флагов отметки узлов.
   * @param {Array} hierarchyKeyPath - путь ключей до текущего узла.
   * @return
   ###
   _additionNodeMarkedProcess: (isChecked, markedNodes, hierarchyKeyPath) ->
      markedRecordParams = @_serachInHierarchy(
         records: @state.tableData,
         isWithParent: true,
         targetKeyPath: hierarchyKeyPath
      )
      hierarchyKeyPathParent = _.dropRight(hierarchyKeyPath)
      hierarchyKeyPathKey = hierarchyKeyPath.join()
      markedRecord = markedRecordParams.record
      markedRecordParent = markedRecordParams.parent
      markedRecordChilds = markedRecord.childs
      hierarchyViewParams = @props.hierarchyViewParams
      isHasHierarchyViewParams = hierarchyViewParams? and
                                 !_.isEmpty(hierarchyViewParams)
      isHasChilds = markedRecordChilds? and !_.isEmpty(markedRecordChilds)
      isHasParent = markedRecordParent?
      commaChar = @_CHARS.comma
      childsMarkedTerm = {}
      parentMarkedTerm = {}

      if isHasHierarchyViewParams
         enableSelectChildsOnSelectParent =
            hierarchyViewParams.enableSelectChildsOnSelectParent
         enableSelectParentOnSelectChild =
            hierarchyViewParams.enableSelectParentOnSelectChild
         enableCompetitiveRootSelectMode =
            hierarchyViewParams.enableCompetitiveRootSelectMode

      # Обрабатываем выбор родительских узлов по выбору дочернего.
      if isHasParent and enableSelectParentOnSelectChild and isChecked
         parentKey = markedRecordParent.key

         parentMarkedTerm[hierarchyKeyPathParent.join()] = isChecked

      # Обрабатываем "конкурентый" выбор корневых узлов.
      if !isHasParent and isChecked and enableCompetitiveRootSelectMode
         for nodePath, marker of markedNodes
            isParentNode = nodePath.split(commaChar).length is 1

            if isParentNode and (nodePath isnt hierarchyKeyPathKey)
               markedNodes[nodePath] = false

      # Обрабатываем выбор дочерних узлов по выбору родительского.
      if isHasChilds and enableSelectChildsOnSelectParent
         for childNode in markedRecordChilds
            childNodePath =
               _.concat(hierarchyKeyPath, childNode.key).join()
            childsMarkedTerm[childNodePath] = isChecked

      _.assign(markedNodes, childsMarkedTerm, parentMarkedTerm)

   ###*
   * Функция фокусировки на элементе контейнера данными. Выполняется для возможности
   *  дальнейшего выполнения процедур управляющих манипуляций с клавиатуры.
   *
   * @return
   ###
   _focusOnDataContainer: ->
      ReactDOM.findDOMNode(@refs[@_REFS.dataContainer]).focus()

   ###*
   * Функция считывания параметров модели. Получает параметры модели по приоритету
   *  1. Свойства компонента. 2. Свойства из хранилища реализаций.
   *
   * @return {Object, undefined}
   ###
   _readModelParams: ->
      @_getComponentProp(@_IMPLEMENTED_PROPS.modelParams)

   ###*
   * Функция считывания доп. параметров фильтров. Получает параметры по приоритету
   *  1. Свойства компонента. 2. Свойства из хранилища реализаций.
   *
   * @return {Object, undefined}
   ###
   _readFilterAdditionParams: ->
      @_getComponentProp(@_IMPLEMENTED_PROPS.filterAdditionParams)

   ###*
   * Функция обарбатывающее событие готовности компонента к проведению операций.
   *
   * @params {Array<Object>} records - загруженные данные.
   * @return
   ###
   _readyHandler: (records) ->
      onReadyHandler = @props.onReady
      organizer = @props.operationsOrganizer

      # Если начальные данные были получены, то вызываем обработчик события
      #  готовности к проведению операции.
      if onReadyHandler?
         onReadyHandler(this, records)

      @_participateInToOrganizer()

   ###*
   * Функция добавления/удаленя в/из органайзер(а) опреаций, если они был задан
   *  через свойства компонента.
   *
   * @props {Boolean} isRemove - флаг удаления из органайзера.
   * @return
   ###
   _participateInToOrganizer: (isRemove) ->
      organizer = @props.operationsOrganizer

      if organizer?
         componentIdentifier = @_componentIdentifier

         if isRemove
            organizer.removeElement(componentIdentifier)
         else
            modelParams = @props.modelParams
            modelRelations = modelParams.relations
            operationCaption = if modelRelations?
                                  modelRelations[modelRelations.length - 1].caption
                               else
                                  modelParams.name

            element =
               identifier: componentIdentifier
               caption: operationCaption
               component: this

            organizer.addElement(element)

   ###*
   * Функция переустановки в состояние начальных данных таблицы. Производит
   *  установку только в случае если новые данные заданы и они отличаются от
   *  текущих начальных данных
   *
   * @return
   ###
   _reinstallInitData: (newInitData) ->
      isHasNewInitData = newInitData? and !_.isEmpty(newInitData)

      # Если были заданы инициализационные данные отличные от предыдущих -
      #  перечитываем данные.
      if isHasNewInitData and @_isInitDataOther(newInitData)
         @setState @_getTableDataFromInitData(newInitData)


   ###*
   * Функция запуска действий после выполнения операции над записью. Получает
   *  текущую операцию над записью и проверяет нужно ли выполнить какое-либо
   *  последействия. Пока реализовано перечитывание записей на странице, если
   *  у операции задан флаг перечитывания (isRereadAfter).
   *
   * @return
   ###
   _processOperationAftereffect: ->
      recordOperation = @state.recordOperation

      if recordOperation? and !_.isEmpty recordOperation
         isRereadAfter = recordOperation.isRereadAfter

         @_rereadAfterOperation() if isRereadAfter

   ###*
   * Функция определения параметров постраничного вывода.
   *
   * @param {Array} records - набор начальных записей.
   * @return {Object}
   ###
   _determinePaginateParams: (records) ->
      if records? and records.length
         recordsPerPage = @props.recordsPerPage
         recordsCount = records.length
         endRecords = if recordsCount > recordsPerPage
                         recordsPerPage
                      else
                         recordsCount
         # Определяем общее кол-во страниц с учетом смещения
         #  записей на каждой странице.
         totalPages = Math.ceil(
            (recordsCount - (Math.ceil(recordsCount / recordsPerPage))) / recordsPerPage
         )

         entriesStatistic:
            start: 1
            end: endRecords
            total: recordsCount
         totalPages: totalPages

   ###*
   * Функция поиска в полученных данных (поиск на клиенте).
   *
   * @param {String} searchExpression - поисковая подстрока.
   * @return {Object} - параметры найденных данных. Вид:
   *     {Array<Object>} tableData - найденные записи.
   *     {Object} paginateParams   - параметры постраничного вывода.
   ###
   _searchInTableData: (searchExpression) ->
      initData = @state.initData
      initTableData = initData.tableData[..]
      initPaginateParams = initData.paginateParams
      recordsPerPage = @props.recordsPerPage
      newTableData = []
      newPaginateParams = {}

      if initTableData? and initTableData.length
         # Если поисковая строка - пустая строка, то поиск среди записей не производим.
         #  Просто присваиваем начальным данным.
         # Иначе отбираем записи по частичному совпадению значения поля записи и
         #  затем переопределям параметры параметры постраничного вывода.
         if searchExpression is @_CHARS.empty
            newTableData = initTableData
            newPaginateParams = initPaginateParams
         else

            for row, idx in initTableData
               fields = row.fields

               for field of fields

                  if _.has(fields, field)
                     value = fields[field].value
                     regExpSearch = new RegExp(searchExpression, @_REGEXP_FLAGS.gi)

                     if regExpSearch.test(value)
                        newTableData.push row
                        break

            newPaginateParams = @_determinePaginateParams(newTableData)

      # Если найденных записей больше чем кол-во записей на странице - обрежем
      #  их, по кол-ву вмещающихся на страницу.
      if newTableData.length >= recordsPerPage
         newTableData.splice(recordsPerPage)

      tableData: newTableData
      paginateParams: newPaginateParams

   ###*
   * Функция подготовки параметров фильтра. Вызывается при пробросе параметров
   *  фильтра через свойства. Необходимма для проведения дополнительных
   *  манипуляций над параметрами, если заданы доп. параметры фильтра. (Пока
   *  реализован только поисковый фильтр).
   *
   * @param {Object} filterParams - Параметры фильтра.
   * @return {Object}
   ###
   _prepareFilter: (filterParams) ->
      filterAdditionParams = @_readFilterAdditionParams()
      filterGroupNames = @_FILTER_GROUP_NAMES
      searchGroupName = filterGroupNames.search
      isHasSearchParams = _.has(filterParams, searchGroupName)

      if isHasSearchParams and _.has(filterAdditionParams, searchGroupName)
         filterParams[searchGroupName] =
            _.merge({}, filterParams[searchGroupName], filterAdditionParams[searchGroupName])

      filterParams
   ###*
   * Функция подготовки ограничений полей. Объединяет ограничения, задаваемые
   *  динамической форме напрямую и ограничения, задаваемые через параметры
   *  конкретного метода манипуляции.
   *
   * @param {Object} fieldConstraints - ограничения для полей.
   * @param {Object} methodParams - параметры по конкретному методу.
   * @return {Object}
   ###
   _prepareFieldConstraints: (fieldConstraints, methodParams) ->
      constraintKeys = @_FIELD_CONSTRAINT_KEYS
      fieldConstraintsKey = constraintKeys.fieldConstraints
      constraintsKey = constraintKeys.constraints
      prefixAnchorsKey = constraintKeys.prefixAnchors
      methodFieldConstraints =
         if methodParams?
            _.cloneDeep(methodParams[fieldConstraintsKey])
      preparedConstraints = _.cloneDeep(fieldConstraints) || {}
      setConstraints = preparedConstraints[constraintsKey]
      setPrefixAnchors = preparedConstraints[prefixAnchorsKey]

      if methodFieldConstraints?
         methodFCPrefixAnchors = methodFieldConstraints[prefixAnchorsKey]
         methodFCConstraints = methodFieldConstraints[constraintsKey]

         if methodFCPrefixAnchors?
            preparedConstraints.prefixAnchors =
               if setPrefixAnchors?
                  $.extend(setPrefixAnchors, methodFCPrefixAnchors)
               else
                  methodFCPrefixAnchors

         if methodFCConstraints?
            preparedConstraints.constraints =
               if setConstraints?
                  methodFCConstraints.concat preparedConstraints.constraints
               else
                  methodFCConstraints

      preparedConstraints

   ###*
   * Функция получения параметров разрешенных для редактирования связок.
   *
   * @param {Object} methodParams - параметры по конкретному методу.
   * @return {Object}
   ###
   _prepareDenyToEdit: (methodParams) ->
      if methodParams? and !_.isEmpty(methodParams)
         methodParams[@_DENY_TO_EDIT_REFLECTION]

   ###*
   * Функция подготовки предустановленных параметров для манипуляции данными
   *  через динамическую форму.
   *
   * @param {Object} params          - параметры для подготовки предустановленных параметров.
   *        {Object} methodParams    - доп. параметры метода. Вид:
   *              {Array<Object>} eagerlyLoadedReflections - набор "жадно подгружаемых связок".
   *                                                         (тех, которые нужно выводить на
   *                                                          редактирование в текущей форме).
   *              {Object} constraints - ограничения по полям и связкам.
   * {Array<Object>} reflectionChain - массив связок по которому нужно вытащить
   *                                   параметры целевой сущности. Таким образом,
   *                                   Задавая последовательность сущностей можно
   *                                   получить предустановленные параметры для
   *                                   сущности-связки на любом уровне вложенности.
   *                                   Например: ['Entity', 'LegalEntityEnmployee'] -
   *                                   получить параметры для сущности LegalEntityEmployee.
   *        {Number} recordKey       - идентификатор записи по которой подготавливаются
   *                                   параметры.
   * @return {Object} - подготовленные предустановленные параметры.
   *     {Object} fields               - параметры полей.
   *     {Object} externalEntities     - параметры внешних связок.
   ###
   _preparePresetParams: (params) ->
      dataTable = this

      ###*
      * Функция получения внутренней связки поля.
      *
      * @param {Object} fieldParams  - параметры поля.
      * @return {Object, undefiened} - параметры связки.
      *     {String} name -     имя связки.
      *     {Object} relation - параметры отношения.
      ###
      getFieldReflection = (fieldParams) ->
         fieldReflection = fieldParams.reflection
         reflection = {}

         if fieldReflection? and !_.isEmpty fieldReflection
            reflInstance = fieldReflection.instance
            dictionaryParams = fieldReflection.dictionary
            reflName = fieldReflection.name

            if reflInstance? and !_.isEmpty reflInstance
               reflection.relations = reflInstance.readingParams.relation

            if reflName?
               reflection.name = reflName

            if dictionaryParams? and !_.isEmpty dictionaryParams
               reflection.requestingParams = dictionaryParams.requestingParams

         unless _.isEmpty reflection
            reflection

      ###*
      * Функция заполнения параметров поля. Заполяет значение поля и значения во
      *  внутренних связках. Вызывается рекурсивно для полей-внутренних связок.
      *
      * @param {Object} fieldParams    - параметры поля.
      * @param {Object} selectedRecord - выбранная запись.
      * @param {String, Number} foreignKey - значение внешнего ключа родительской сущности.
      ###
      fillFieldParams = ((fieldParams, selectedRecord, foreignKey, instanceKey) ->
         return if !selectedRecord? and !foreignKey?

         underscoreChar = @_CHARS.underscore
         idFieldName = @_ID_FIELD_NAME
         fieldName = fieldParams.name
         enumValues = fieldParams.enumValues
         isEnum = enumValues? and !_.isEmpty(enumValues)
         isPolymorphicType = fieldParams.isPolymorphicType
         fieldReflParams = getFieldReflection(fieldParams)
         isHasReflection = fieldReflParams? and
                           !_.isEmpty(fieldReflParams)
         isHasRelation = isHasReflection and
                         fieldReflParams.relations? and
                         !_.isEmpty(fieldReflParams.relations)
         isHasRequestingParams = isHasReflection and
                                 fieldReflParams.requestingParams? and
                                 !_.isEmpty(fieldReflParams.requestingParams)
         reflName = if isHasReflection
                       fieldReflParams.name
         if selectedRecord?
            selectedRecordKey = selectedRecord.key
            selectedRecordFields = selectedRecord.fields
            selectedRecordReflections = selectedRecord.reflections
            selectedField = selectedRecordFields[fieldName]
            selectedFieldValue = selectedField.value
            selectedFieldSpecific = selectedField.specific

            recordReflection = if selectedRecordReflections?
                                  selectedRecordReflections[reflName]

         if isEnum and !isPolymorphicType
            for key, value of enumValues
               if value is selectedFieldValue
                  fieldValue = key
                  break
         else if isHasRelation and !isHasRequestingParams
            fieldRelations = fieldReflParams.relations
            for relationName, relation of fieldRelations

               # Если в параметрах связей записи задана такая связка(по имени) для
               #  обрабатываемого поля - производим обработку по данным параметрам
               #  связки с рекурсивным вызовом, если поля связки содержат внутренние связки.
               # Иначе, если задан внешний ключ - берутся поля связки и по текущему
               #  родительскому полю внутренней связи (родитель) и среди них
               #  получается имя аналогичное имени родительского поля и в значение
               #  ему устанавливается значение внешнего ключа (это специфичная обработка
               #  полей вложений, для того, чтобы они могли подгрузить вложение).
               if recordReflection? and !_.isEmpty recordReflection
                  recordReflectionValue = recordReflection.value
                  recordReflectionModel = recordReflectionValue.model

                  if relationName is recordReflectionModel

                     recordReflectionFields = if recordReflectionValue?
                                                 recordReflectionValue.fields

                     relationClonedFields = _.cloneDeep(relation.fields)

                     for clFieldName, clFieldParams of relationClonedFields
                        recordField = recordReflectionFields[clFieldName]

                        if recordField?
                           recordFieldValue = recordField.value
                           recordFieldSpecific = recordField.specific

                        clFieldReflParams = getFieldReflection(clFieldParams)
                        isClFieldHasReflection = clFieldReflParams? and
                                                 !_.isEmpty(clFieldReflParams)
                        isClFieldHasReflName = isClFieldHasReflection and
                                               clFieldParams.name
                        isClFieldHasRelation = isClFieldHasReflection and
                                               clFieldReflParams.relations? and
                                               !_.isEmpty(clFieldReflParams.relations)
                        clFieldRequestingParams = if isClFieldHasReflection
                                                     clFieldReflParams.requestingParams
                        isClFieldHasDataSource = isClFieldHasReflection and
                                                 clFieldRequestingParams? and
                                                 !_.isEmpty clFieldRequestingParams
                        clFieldNameElements = clFieldName.split(underscoreChar)
                        isClFieldForeignKey =
                           _.last(clFieldNameElements) is idFieldName
                        recordReflectionReflections = recordReflectionValue.reflections

                        # Получаем запись по данной связке - если заданы связки текущей записи.
                        #  И если поле имеет форму внешнего ключа - пробуем получить имя связки по
                        #  имени поля и по нему получить значение записи связки.
                        #  Иначе если поле имеет имя связки - получаем значение связки по этому имени.
                        recordRelfectionSelectedRecord =
                           if recordReflectionReflections?
                              if isClFieldForeignKey
                                 reflectionNameFromFieldName =
                                    _.dropRight(clFieldNameElements, 1)
                                     .join(underscoreChar)
                                 recordReflectionReflections[reflectionNameFromFieldName]
                              else if isClFieldHasReflName
                                 recordReflectionReflections[clFieldReflParams.name]

                        if isClFieldHasRelation and !isClFieldHasDataSource
                           fillFieldParams(clFieldParams,
                                           recordRelfectionSelectedRecord,
                                           recordFieldValue)
                        else if clFieldParams.name is fieldName
                           clFieldParams.value = recordReflectionValue.key
                        else
                           clFieldParams.value =
                              if isClFieldHasDataSource and _.isPlainObject(recordRelfectionSelectedRecord)
                                 [recordRelfectionSelectedRecord.value]
                              else
                                 recordFieldValue

                        if recordFieldSpecific?
                           clFieldParams.specific = recordFieldSpecific

                     relation.fields = relationClonedFields
               else if foreignKey?
                  relationClonedFields = _.cloneDeep(relation.fields)
                  relationForeignField = relationClonedFields[fieldName]

                  if relationForeignField?
                     relationForeignField.value = foreignKey
                     relation.fields = relationClonedFields

         else
            fieldValue =
               if isHasRequestingParams and recordReflection? and !_.isEmpty(recordReflection)
                  [recordReflection.value]
               else
                  selectedFieldValue

         #clonedFields[fieldName].value = fieldValue if fieldValue?
         if fieldValue?
            if instanceKey?
               unless _.isPlainObject(fieldParams.value)
                  fieldParams.value = {}

               fieldParams.value[instanceKey] = fieldValue
            else
               fieldParams.value = fieldValue

         if selectedFieldSpecific?
            fieldParams.specific = selectedFieldSpecific
      ).bind(dataTable)

      ###*
      * Функция заполнения разрешенной для "жадной" загрузки сущности.
      *  Функция необходима для заполнения параметров внешней сущности для
      *  динамической формы параметрами связанных внешних сущностей. Поведение
      *  заполненния внешних сущностей управляется через параметр
      *  @props.dataManipulationParams.eagerlyLoadedReflections.
      *  TODO: В настоящий момент реализованы только самые простые случаи -
      *        один уровень вложенности (без учета полиморфности, и цепи связок),
      *        считываение записей и сохранение в параметр records в параметрах
      *        внешней сущности. В более сложных случаях нужна доработка.
      *
      * @param {Object} extEntities   - внешние связки.
      * @param {Object} eagerlyParams - параметры "жадно" считываемых связок.
      * @param {Object, Array<Object>}
      ###
      fillEagerlyEntities = ((extEntities, eagerlyParams, selectedRecord) ->
         return unless selectedRecord?
         selectedRecordReflections = selectedRecord.reflections

         for reflName, reflParams of eagerlyParams
            isReadOnlyRecords = false

            if reflParams?
               isReadOnlyRecords = reflParams.isReadOnlyRecords

            selectedRecordEagerlyRefl = selectedRecordReflections[reflName]
            extEntity = extEntities[ _.upperFirst(_.camelCase(pluralize(reflName, 1)))]

            if extEntity? and selectedRecordEagerlyRefl

               # Если задан флаг считывания только записей - добавляем в параметры
               #  связки полученные записи.
               # Иначе считываем и заполняем поля внешней связки.
               if isReadOnlyRecords
                  extEntity.records = selectedRecordEagerlyRefl.value
               else
                  extEntityFields = extEntity.fields

                  for fieldName, fieldParams of extEntityFields
                     selectedRecordValue = selectedRecordEagerlyRefl.value

                     # TODO: здесь скорее всего некорректно - пока не проверял.
                     if Array.isArray(selectedRecordValue)
                        for selectedRecord, idx in selectedRecordValue
                           recordKey = selectedRecord.key
                           fillFieldParams(fieldParams,
                                           selectedRecord,
                                           null,
                                           recordKey)
                     else
                        fillFieldParams(fieldParams, selectedRecordValue)
      ).bind(dataTable)

      ###*
      * Функция получения игнорируемого поля на динамической форме. Формируется
      *  из наименования предпоследней связки или наименования модели (если связка
      *  имеет единичную длинну).
      *
      * @param {Array} relations - цепь связок.
      * @return {String}
      ###
      getIgnoredFieldName = ((relations) ->
         idFieldName = @_ID_FIELD_NAME
         underscoreChar = @_CHARS.underscore
         modelParams = @props.modelParams

         return unless modelParams?

         modelRelations = modelParams.relations

         # Определяем наименование связки, игнорируемой на форме -
         #  Если цепь связок длиннее одного элемента - берем наименование предпоследней связи
         #  Если связка модели единичной длинны - то берем наименование корневой модели
         ignoredRelation =
            if relations? and relations.length > 1
               relationsCount = relations.length
               penultRelation = relations[relationsCount - 2]
               reflectionName = penultRelation.reflection
               polyName = penultRelation.polymorphicEntityName

               if polyName?
                  _.snakeCase(polyName)
               else
                  pluralize(reflectionName, 1)
            else
               modelParams.name

         [ignoredRelation, idFieldName].join underscoreChar
      ).bind(dataTable)

      ###*
      * Функция применения ограничений, заданным через параметры,
      *  к полям и внешним сущностям.
      *
      * @param {Object} constraints - параметры ограничений.
      * @param {Object} fields      - параметры полей.
      * @param {Object} extEntities - параметры внешних сущностей.
      * @return
      ###
      applyConstraintsToElements = ((constraints, fields, extEntities) ->
         fieldConstraints = constraints.fields
         reflectionConstraints = constraints.reflections

         ###*
         * Функция исключения лишнего из набора (поля, внешние сущности).
         *
         * @param {Object} objectCollection -  целевой ассоциативный массив коллекции объектов.
         * @param {Object} objectConstraints - набора ограничений для целевой коллекции.
         * @return
         ###
         excludeExcess = (objectCollection, objectConstraints) ->

            ###*
            * Функция для удаления элемента из коллекции по условию.
            *
            * @param {Object} collection      - целевая коллекция.
            * @param {String} objName         - имя проверяемого элемента.
            * @param {Object} checkCollection - контрольная коллекция (по которой проверяем).
            * @param {Boolean} isExcept       - флаг исключения (иначе включение в целевой коллекции)
            * @return
            ###
            excludeObjectWithCondition = (collection, objName, checkCollection, isExcept) ->
               isInCheckCollection = !!~_.indexOf(checkCollection, objName)
               if (isExcept and isInCheckCollection) or !isInCheckCollection
                  delete collection[objName]

            if objectConstraints? and !_.isEmpty(objectConstraints)
               onlyConstraints = objectConstraints.only
               exceptConstraints = objectConstraints.except
               isPurgedConstraint = objectConstraints.isPurged

               if onlyConstraints? or exceptConstraints?

                  if onlyConstraints?
                     for objectName, object of objectCollection
                        excludeObjectWithCondition(objectCollection,
                                                   objectName,
                                                   onlyConstraints,
                                                   false)

                  if exceptConstraints?
                     for objectName, object of objectCollection
                        excludeObjectWithCondition(objectCollection,
                                                   objectName,
                                                   exceptConstraints,
                                                   true)

               # Если задан флаг сброса коллекции - выполним полную очистку
               #  элементов коллекции.
               if isPurgedConstraint
                  _.forOwn(objectCollection, (value, key) ->
                     delete objectCollection[key]
                  )

         excludeExcess(fields, fieldConstraints)
         excludeExcess(extEntities, reflectionConstraints)
      ).bind(dataTable)

      methodParams = params.methodParams
      constraints = methodParams.constraints if methodParams?
      recordKey = params.recordKey
      reflectionsChain = params.reflectionsChain
      modelParams = @props.modelParams
      modelRelations = modelParams.relations if modelParams?
      entityParams = @_getEntityParamsByChain reflectionsChain: reflectionsChain
      clonedFields =  _.cloneDeep entityParams.fieldParams
      clonedExtEntities = _.cloneDeep entityParams.externalEntities
      ignoredField = getIgnoredFieldName(modelRelations)

      delete clonedFields[ignoredField] if ignoredField? and clonedFields?

      if constraints? and !_.isEmpty(constraints)
         applyConstraintsToElements(constraints, clonedFields, clonedExtEntities)

      # Если задан ключ записи - выполняем процедуру заполнения значениями параметров
      #  полей и параметров нетерпеливо подгружаемых связок.
      if recordKey?
         selectedRecord = @getRecord(recordKey)
         eagerlyLoadedReflections = if methodParams?
                                       methodParams.eagerlyLoadedReflections
         isHasEagerlyRefl = eagerlyLoadedReflections? and
                            !_.isEmpty(eagerlyLoadedReflections)

         # Заполняем поля.
         for fieldName, fieldParams of clonedFields
            fillFieldParams(fieldParams, selectedRecord)

         # Заполняем "жадно загружаемые" внешние связки.
         if isHasEagerlyRefl
            fillEagerlyEntities(clonedExtEntities,
                                eagerlyLoadedReflections,
                                selectedRecord)

      fields: clonedFields
      externalEntities: clonedExtEntities

   ###*
   * Универсальная функция обработки результата операций над фильтром.
   *  Обрабатывает ответы при различных операциях над фильтрами - создании,
   *  обновлении и удалении. Считывает результат, изменяет набор пользовательских
   *  фильтров и готовит параметры для всплывающего уведомления.
   *
   * @param {String} type - тип операции (create, update, delete).
   * @param {Object, String} params - параметры операции.
   * @return
   ###
   _executeUserFiltersOperation: (type, params) ->
      ###*
      * Функция поиска индекса фильтра в массиве записей пользовательских фильтров.
      *
      * @param {Array} filters - набор пользовательских фильтров.
      * @param {String} key    - искомый ключ записи.
      * @return {Number} - индекс записи.
      ###
      getFilterIndex = (filters, key) ->
         for filter, idx in filters
            if filter.key is key
               return idx

      userFilters = @state.userFilters
      isHasUserFilters = userFilters? and !_.isEmpty(userFilters)

      if params? and isHasUserFilters
         filterRecords = userFilters.records[..]
         filterOperations = @_RECORD_OPERATIONS
         popupParams = @_POPUP_CONTENT_DEFAULT
         popupUFParams = popupParams.userFilters
         popupFlashTypes = @refs.popupFlasher.getFlashTypes()
         popupType = popupFlashTypes.info
         isOperationSuccess = true

         # Если пользовательские фильтры ещё не были заданы - создадим
         #  хэш с пустыми записями.
         if !userFilters? or _.isEmpty(userFilters)
            userFilters =
               records: []

         userFilterRecords = userFilters.records

         # В зависимости от типа операции по-разному считывает параметры фильтров
         #  меняет набор фильтров и подготавливает парметры для всплывающего
         #  уведомления.
         switch type
            # Создание.
            when filterOperations.create
               userFilterRecords.push(params)
               popupIdentifier = params.fields.name.value
               popupText = popupUFParams.create.text
            # Обновление.
            when filterOperations.update
               updatedKey = params.key

               if updatedKey?
                  updatedIndex = getFilterIndex(userFilterRecords, updatedKey)

                  if updatedIndex?
                     userFilterRecords[updatedIndex] = params
                     popupText = popupUFParams.update.text
                     popupIdentifier = params.fields.name.value
                  else
                     isOperationSuccess = false
               else
                  isOperationSuccess = false
            # Удаление.
            when filterOperations.delete
               deletedKey = +params
               deletedIndex = getFilterIndex(userFilterRecords, deletedKey)

               if deletedIndex?
                  userFilterRecords.splice(deletedIndex, 1)
                  popupIdentifier = deletedKey
                  popupText = popupUFParams.delete.text
               else
                  isOperationSuccess = false

         # Если операция была успешна(возвращены корректные параметры), то
         #  записываем в параметры фильтра переформированные записи.
         # Иначе - готовим параметры для уведомления об ошибке.
         if isOperationSuccess
            userFilters.records = userFilterRecords
         else
            popupStandardErrorParams = popupParams.standardError
            popupText = popupStandardErrorParams.text
            popupType = popupStandardErrorParams.type
            popupIdentifier = @_CHARS.empty

         popupParams = @_getPopupParams(popupText, popupIdentifier, popupType)

         @setState
            userFilters: userFilters
            popupParams: popupParams

   ###*
   * Функция вставки новой записи в массив уже существующей иерархии записей.
   *  находит родительскую запись(если задан родитель) и вставляет новую запись
   *  в коллекцию дочерних элементов.
   *
   * @param {Array} records - набор записей.
   * @param {Object} newRecord - новая запись.
   * @return
   ###
   _insertRecordInHierarchy: (records, newRecord) ->
      newRecordFields = newRecord.fields
      newRecordParentID = newRecordFields.parent_id

      if newRecordParentID? and !_.isEmpty(newRecordParentID) and
      newRecordParentID.value?
         parent = @_getRecordInHierarchy(records, newRecordParentID.value)

         if parent?
            if parent.childs? and parent.childs.length
               parent.childs.push(newRecord)
            else
               parent.childs = [newRecord]
      else
         records.push newRecord

   ###*
   * Функция удаления записи из иерархии записей.
   *
   * @param {Array} records     - набор записей из которых удаляется запись.
   * @param {Number} deletedKey - ключ удаляемой записи.
   * @return
   ###
   _deleteRecordFromHierarchy: (records, deletedKey) ->
      deletedRecord = @_getRecordInHierarchy(records, deletedKey)
      deletedRecordFields = deletedRecord.fields
      parentFieldName = @_PARENT_FIELD_NAME
      isHasParent = deletedRecordFields.hasOwnProperty(parentFieldName) and
                    deletedRecordFields[parentFieldName].value?

      ###*
      * Функция удаления записи по ключу из набора записей.
      *
      * @param {Array} records - набор записей.
      * @param {Number} splicedKey - ключ удаляемой записи.
      ###
      spliceFromRecords = (records, splicedKey) ->
         # Удалим удалённую запись из клонированного(нового) массива записей комопнента
         for record, idx in records
            if record.key is splicedKey
               records.splice idx, 1
               break

      if isHasParent
         parentRecord =
            @_getRecordInHierarchy(records,
                                   deletedRecordFields[parentFieldName].value)
         parentChilds = parentRecord.childs

         spliceFromRecords(parentChilds, deletedKey)
      else
         spliceFromRecords(records, deletedKey)

   ###*
   * Функция поиска. Подготавливает и отправляет поисковый запрос в БЛ.
   *
   * @param {String} searchValue - подстрока поиска.
   * @return
   ###
   _doSearch: (searchValue) ->
      isSearchDoOnClient = @props.isSearchDoOnClient
      isFullyClientMode = @props.isFullyClientMode

      # Если заданы флаг поиска на клиенте или полностью ремима работы на клиенте.
      if isSearchDoOnClient or isFullyClientMode
         @setState @_searchInTableData searchValue
      else
         filterParams = @_constructSearchFilterParams searchValue
         paramsForInitRequest =
            activePage: @props.startPage
            newFilterParams: filterParams

         @_sendInitRequest paramsForInitRequest #@props.startPage, @state.perPage, filterParams, null

      @setState
         searchExpression: searchValue
         isFilterChanged: true

   ###*
   * Функция поиска записи в иераррхии записей(среди дочерних записей).
   *
   * @param {Object} params - параметры для функции. Вид:
   *        {String} key           - ключ записи.
   *        {Array} records        - набор записей среди которых производится поиск.
   *        {Boolean} isWithParent - флаг возврата записи вместе с родительской
   *                                 Если задан данный флаг, то возвращает хэш с
   *                                 2-мя параметрами - record, parent.
   *        {Object} parent        - родительская запись.
   *        {Array} targetKeyPath  - массив ключей по которой нужно извлечь запись.
   *      {Boolean} isRecursiveCall - флаг рекурсивного вызова.
   * @param {Object}  - найденная запись.
   ###
   _serachInHierarchy: (params) ->
      key = params.key
      records = params.records || @state.tableData
      isWithParent = params.isWithParent
      parent = params.parent
      targetKeyPath = params.targetKeyPath
      isRecursiveCall = params.isRecursiveCall

      # Функция нахождения записи итеративным перебором.
      findByIterates = ((records, key, findedRecords) ->
         findedRecords ||= []

         for record in records
            recordChilds = record.childs

            if record.key.toString() is key.toString()
               findedRecords.push record
               break
            else if recordChilds? and _.isEmpty(findedRecords)
               findByIterates(recordChilds, key, findedRecords)
         _.head(findedRecords)
      ).bind(this)

      # Функция нахождения записи по целевому пути ключей.
      findByKeyPath = ((records, targetKeyPath) ->
         currentRecords = records

         for targetKey, idx in targetKeyPath
            parent = record
            record = _.find(currentRecords, (record) ->
               record.key.toString() is targetKey.toString()
            )
            currentRecords = record.childs

         record: record
         parent: parent
      ).bind(this)


      if targetKeyPath? and !_.isEmpty targetKeyPath
         findedRecordParams = findByKeyPath(records, targetKeyPath)
         findedRecord = findedRecordParams.record
         parent = findedRecordParams.parent
      else
         findedRecord = findByIterates(records, key)

      if isWithParent and isRecursiveCall and findedRecord?
         parent: parent
         record: findedRecord
      else
         if isWithParent and (findedRecord? and !findedRecord.parent?)
            record: findedRecord
            parent: parent
         else
            findedRecord

   ###*
   * Функция отправки запроса на получение инициализационных данных для отображаемой
   *  страницы данных. Также устанавливает переданные параметры в состояние компонента.
   *
   * @param {Object} params - хэш параметров для отправки запроса. Вид:
   *        {Number, undefined} activePage         - текущая страница запроса.
   *        {Number, undefined} perPage            - кол-во записей на странице.
   *        {String, Number, undefined} instanceID - идентификатор экземпляра по которму строится
   *                                                 таблица.
   *        {Object, undefined} newFilterParams    - хэш с новыми параметрами фильтрации записей.
   *        {Boolean} isFilterConcat               - флаг объединения новых параметров фильтрации
   *                                                 с существующими
   * @return
   ###
   _sendInitRequest: (params) ->
      activePage = @state.activePage
      perPage = @state.perPage
      instanceID =  @props.instanceID
      modelParams = @props.modelParams
      fluxParams = @props.fluxParams
      isUseServiceInfrastructure = fluxParams.isUseServiceInfrastructure
      initFluxParams = fluxParams.init
      isFilterConcat = null
      newFilterParams = null

      if modelParams?
         modelRelations = modelParams.relations
         model = modelParams.name
         modelSubResource = modelParams.subResource

      if params?
         activePage = params.activePage if params.activePage?
         perPage = params.perPage if params.perPage?
         instanceID = params.instanceID if params.instanceID?
         newFilterParams = params.newFilterParams
         isFilterConcat = params.isFilterConcat
         modelRelations = params.modelRelations if params.modelRelations?
         model = params.model if params.model?
         modelSubResource = params.modelSubResource if params.modelSubResource?

      filterParams = @_constructFilterParams(newFilterParams, isFilterConcat)

      requestParams =
         page: activePage
         perPage: perPage
         filter: filterParams
         relations: modelRelations

      if isUseServiceInfrastructure
         paramsForServiceRequest =
            requestData: requestParams
            componentID: @_componentIdentifier
            instanceID: instanceID
            model: model
            subResource: modelSubResource
            APIMethod: ServiceFluxConstants.APIMethods.index

         ServiceActionCreators.dataRequest paramsForServiceRequest
      else
         requestParams.instanceID = instanceID
         initFluxParams.sendRequest requestParams,
                                    initFluxParams.requestUrl,
                                    initFluxParams.requestIdentifier

      @setState
         tableState: @_TABLE_STATES.requesting
         filterParams: filterParams
         activePage: activePage
         perPage: perPage
         recordOperation: @_RECORD_OPERATIONS.none

   ###*
   * Функция отправки запроса на получение инициализационных данных для отображаемой
   *  страницы данных. Также устанавливает переданные параметры в состояние компонента.
   *
   * @param {Object} exportParams - параметры серилизации. Вид:
   *        {String} format - выбранный формат экспорта.
   *        {Number} recordsOnFile - кол-во записей на файл.
   *        {Boolean} isLocalizeCaptions - флаг локализации наименований полей.
   *        {Boolean} isUseAppliedSerializer - флаг использования прикладного серилизатора.
   * @return
   ###
   _sendExportRequest: (exportParams) ->
      modelParams = @props.modelParams
      model = modelParams.name if modelParams?
      fluxParams = @props.fluxParams
      instanceID =  @props.instanceID
      isUseServiceInfrastructure = fluxParams.isUseServiceInfrastructure
      exportFluxParams = fluxParams.export

      basisParams =
         modelParams: @props.modelParams
         relations: modelParams.relations if modelParams?
         filter: @state.filterParams

      requestParams = _.merge(exportParams, basisParams)

      if isUseServiceInfrastructure
         paramsForServiceRequest =
            requestData: requestParams
            componentID: @_componentIdentifier
            instanceID: instanceID
            model: model
            APIMethod: ServiceFluxConstants.APIMethods.export

         ServiceActionCreators.dataRequest paramsForServiceRequest
      else
         requestParams.instanceID = instanceID
         exportFluxParams.sendRequest requestParams,
                                      exportFluxParams.requestUrl,
                                      exportFluxParams.requestIdentifier

   ###*
   * Функция конструирования новых параметров фильтрации на основе текущих параметров
   *  фильтрации и новых, переданных в параметре.
   *
   * @param {Object, undefined} newFilterParams - новые параметры фильтрации.
   * @param {Boolean} isFilterConcat - флаг объединения новых параметров с существующими.
   * @return {Object} - сформированные параметры фильтрации.
   ###
   _constructFilterParams: (newFilterParams, isFilterConcat) ->
      currentFilterParams = @state.filterParams

      # Если флаг объединения не задан - установим положительное значение
      #  по-умолчанию.
      isFilterConcat = true unless isFilterConcat?


      if newFilterParams and !_.isEmpty(newFilterParams)
         if isFilterConcat
            #$.extend(currentFilterParams, newFilterParams)

            for newParamName, newFilterParam of newFilterParams
               currentFilterParams[newParamName] = newFilterParam

               if !newFilterParam? and currentFilterParams.hasOwnProperty newParamName
                  delete currentFilterParams[newParamName]
         else
            currentFilterParams = newFilterParams

      currentFilterParams

   ###*
   * Метод конструирования параметров фильтра для поиска. Принимает на вход подстроку
   *  для поиска. Возвращает подготовленный объект для отправки в БЛ (для фильтра).
   *
   * @param {String} value - подстрока для поиска.
   * @return {Object} - параметры для отправки запроса на фильрацию в БЛ.
   ###
   _constructSearchFilterParams: (value) ->

      return unless value?

      searchFilterParamsDefault = @_SEARCH_FILTER_PARAMS
      fieldsKey = searchFilterParamsDefault.fieldsKey
      filterAdditionParams = @_readFilterAdditionParams()
      searchAdditionParams = filterAdditionParams.search if filterAdditionParams

      # Если параметры поиска заданы через доп. свойства фильтра - возьмем эти поля
      #  неглядя (на совесть прикладника), иначе берем поля по-умолчанию.
      fields =
         if searchAdditionParams? and searchAdditionParams.hasOwnProperty fieldsKey
            searchAdditionParams[fieldsKey]
         else
            searchFilterParamsDefault.defaultFields

      search:
         fields: fields
         expr: value

   ###*
   * Метод конструирования параметров фильтра для выборки отмеченных записей.
   *  Считывает флаг отметки всех записей, ранее примененного фильтра и хэша
   *  отмеченных строк или строк со снятой отметкой и на основе них подготавливает
   *  запрос в БЛ.
   *
   * @param {Boolean} isNeedMarkedTerm - флаг необходимости конструирования
   *                                     параметров выделенных записей.
   *                                     Если false - подготовит хэш для сброса
   *                                     фильтрации по выделенным записям.
   * @return {Object} - параметры для отправки запроса на фильрацию в БЛ.
   ###
   _constructMarkedFilterParams: (isNeedMarkedTerm) ->
      markedParams = @_getMarkedKeys()
      matchedTypes = @_FILTER_MATCH_TYPES
      markedTerm = null

      if isNeedMarkedTerm
         # Если были помечены все записи, то добавляем в условие фильтрации ключи
         # строк по которым не нужно делать выборку(если с них были сняты отметки
         # при уже помеченных всех записях).
         # Иначе добавляем условие фильтрации по ключам отмеченных записей.
         # В качестве выражения фильтрации передаем склеенную из массива строку,
         # обрамленную скобками (требуемый формат на БЛ для выборки из массива).
         markedTerm = if @state.isAllRowsMarked
                           unmarkedKeys = markedParams.unmarked

                           if unmarkedKeys.length
                              keys: unmarkedKeys #"(#{unmarkedKeys.join()})"
                              match: matchedTypes.not_in
                        else
                           markedKeys = markedParams.marked

                           if markedKeys.length
                              keys:  markedKeys #"(#{markedKeys.join()})"
                              match: matchedTypes.in

      marked: markedTerm

   ###*
   * Функция подготовки фильтра по отмеченным записям и отправки запроса на получение
   *  данных таблицы.
   *
   * @param {String} activePanel - наименование текущей активной панели операций.
   * @return
   ###
   _applyMarkedFilter: (activePanel) ->
      markedFilterParams =
         @_constructMarkedFilterParams(@_isActiveMassApplicationPanel(activePanel))

      # Если есть какие-либо параметры фильтрации и они отличны от предыдущих -
      #  запускаем фильтрацию.
      if @_isNeedSendInitRequestWithMarkedFilter(markedFilterParams)
         paramsForRequest =
            activePage: 1
            newFilterParams: markedFilterParams

         @_sendInitRequest paramsForRequest

   ###*
   * Функция получения из считанных данных массива отмеченных. У каждой записи в
   *  наборе считывается флаг selected и если он = true, и ранее он не был отмечен/
   *  снята отметка заносим данные по нему в состояние компонента.
   *
   * @param {Array} nextTableData - массив записей
   * @return
   ###
   _definedMarkedRows: (nextTableData) ->
      newMarkedRows = $.extend({}, @state.markedRows)

      if nextTableData? and nextTableData.length
         for row in nextTableData
            rowKey = row.key
            isSelected = row.selected

            if isSelected and !newMarkedRows[rowKey]?
               newMarkedRows[rowKey] = isSelected

         unless _.isEmpty(newMarkedRows)
            @setState markedRows: newMarkedRows

   ###*
   * Функция переустановки свойств реализации. Перечитывает свойства реализации
   *  из источника реализации и устанавливаем в состояние компонента.
   *
   * @param {Object} newProps - новые свойства компонента.
   * @return
   ###
   _rereadImplementationProps: (newProps) ->
      @setState implementationProps: @_getImplementationProps(newProps)

   ###*
   * Функция отправки запроса на перечитывания данных. Отправляет инициализационный
   *  запрос на считывание записей с параметрами по-умолчанию по таймауту т.к. напрямую
   *  нельзя отправить запрос, т.к. данный метод вызывается в середине разбора ответа из хранилища
   *  onChange.
   *
   * @return
   ###
   _rereadAfterOperation: ->
      setTimeout @_sendInitRequest, 4

   ###*
   * Функция сортировки массива данных таблицы. В зависимости от направления сортировки
   *  сортирует  массив.
   *
   * @param {String} columnName - наименование колонки по которой сортируем.
   * @param {Array} data        - набор данных для сортировки.
   * @return {Array} - отсортированный массив
   ###
   _orderColumns: (columnName, data) ->
      direction = @state.orderDirection
      dataArray = []

      if data.length

         data.sort (active, next) ->
            activeFieldParams = active.fields[columnName]
            nextFieldParams = next.fields[columnName]
            activeVal = activeFieldParams.value if activeFieldParams?
            nextVal = nextFieldParams.value if nextFieldParams?

            if activeVal < nextVal
               if direction is'DESC' then -1 else 1
            else if activeVal > nextVal
               if direction is 'DESC' then 1 else -1
            else
               0

###* Компонент: панель действия над таблицей: часть компонента DataTable
*
* @props:
*     {Object} createButtonParams - хэш параметров кнопки создания записи.
*     {Object} filterButtonParams - хэш параметров кнопки открытия панели фильтрации.
*     {Object} entityParams     - хэш с параметрами сущности. Вид:
*        {Object} externalEntities - хэш с параметрами внешних сущностей.
*        {Object} fieldParams      - хэш с параметрами полей таблицы.
*     {Object} markedRowsStatistic   - хэш с статистикой по отмеченным записям.
*                                      Вид:
*                                      {
*                                          {Number} marked:   - кол-во отмеченных,
*                                          {Number} unmarked: - кол-во строк с которых сняли отметку
*                                      }
*    {Object} reflectionRenderParams - хэш параметров рендера полей выборки.
*    {Object} dataManipulationParams - параметры манипуляции данными (для задания ограничений полей фильтра).
*    {Object} fluxParamsUserFilters  - хэш параметров flux-инфраструктуры для манипуляции
*                                      пользовательскими фильтрами.
*     {Object} massOperations        - хэш с параметрами массовых операций над записями.
*     {Object} recordsOperations     - хэш возможных массовых действий над записями.
*                                      (применяется для определения и задания текущей
*                                       активной панели действий над записями).
*     {Object} filterFlags           - флаг примененных фильтров. (true - применен, false - отменен).
*                                      Вид:
*                                      {Boolean} isComplex - сложный фильтр.
*                                      {Boolean} isMarked  - фильтр по отмеченным.
*                                      {Boolean} isSearch  - поисковый фильтр.
*                                      {Boolean} isUser    - пользовательский фильтр.
*     {Object} userFilterParams      - параметры пользовательских фильтров.
*     {Array} userFilters            - набор пользовательских фильтров (параметр необходим
*                                      для определения необходимости добавления кнопки
*                                      открытия/скрытия области пользовательских фильтров)
*     {Object} modelParams           - параметры модели таблицы.
*     {String} searchPlaceholder     - строка-приглашение ввода в поле поиска.
*     {Object} implementationStore   - хранилище реализаций.
*     {Boolean} isUseImplementation  - флаг использования хранилища реализаций.
*     {Boolean} isMergeImplementation- флаг слияния "реализуемых" свойств.
*     {Boolean} enableCreate         - флаг разрешения создания записей.
*     {Boolean} enableFilter         - флаг разрешения отбора записей.
*     {Boolean} enableUserFilters    - флаг разрешения пользовательских фильтров.
*     {Boolean} enableSettings       - флаг разрешения настроек таблицы.
*     {Boolean} enableSearch         - флаг разрешения поиска записей.
*     {Boolean} enableRowSelect      - флаг разрешения выбора записей.
*     {Boolean} enableColumnsHeader  - флаг показа заголовка колонок таблицы.
*   {Boolean} enablePerPageSelector  - флаг разрешения селектора записей на странице.
*{Boolean} isHierarchicallyViewTable - флаг ирерхического представления таблицы.
*     {Boolean} isAllRowsMarked      - флаг отмеченности всех строк.
*     {Boolean} isSuppressAllRecordsSelector - флаг запрета вывода селектора всех записей на странице.
*     {Boolean} isExportRequested    - флаг запрошенности файлов экспорта.
*     {Function} onChangePerPage     - обарботчик, запускаемый при выборе кол-ва записей
*                                      на странице.
*  {Function} onClickSettingsTrigger - обарботчик клика по кнопке показа панели настроек
*                                      таблицы.
*     {Function} onSearch            - обработчик, запускаемый при поиске.
*     {Function} onClearSearch       - обработчик на сбор значения в полей поиска.
*     {Function} onClickNewRecord    - обработчик на клик по кнопке создания записи.
*     {Function} onAfterTriggerPanel - обработчик после открытия/скрытия панели операций.
*     {Function} onApplyFilter       - обработчик на применение фильтра.
*     {Function} onClickOperation    - обработчик клика на кнопку массовых операций.
*     {Function} onClickSelectAll    - обработчик клика на селектор всех записей.
*     {Function} onClickUserFilter   - обработчик клика по кнопке пользовательского фильтра.
*   {Function} onAfterReceiveFilters - обработчик события после получения фильтров.
*     {Function} onAfterCreateFilter - обработчик после сохранения пользовательского фильтра.
*     {Function} onAfterUpdateFilter - обработчик после обновления пользовательского фильтра.
*     {Function} onAfterDeleteFilter - обработчик после удаления пользовательского фильтра.
*{Function} onClickDataExportTrigger - обработчик клика кнопки открытия/скрытия панели экспорта данных.
* {Function} onClickSettingsTrigger  - обработчик клика кнопки открытия/скрытия панели настроек.
* @state:
*     {Boolean} isOperationsPanelOpen - флаг показа панели операций (по-умолчанию =false).
*     {Boolean} isUserFiltersAreaOpen - флаг показа области пользовательских фильтров
*                                       (по-умолчанию =true).
*     {Boolean} isAllRowsMarked       - флаг выбранности всех строк.
*     {String} activePanel            - наименование активной панели. Варианты:
*                                        "massApplication" - панель массовых операций.
*                                        "filter"          - панель фильтра.
*                                        "none"            - активная панель отсутствует.
###
DataTableToolbar = React.createClass
   # @const {Object} - параметры для всплывашки-подсказки на поле поиска.
   _SEARCH_POPUP_PARAMS:
      popupContent: 'Нажмите клавишу Enter для поиска'
      typeEvent: 'onInputEnd'
      icon: icon:'keyboard-o'

   # @const {Object} - параметры для лидирующей иконки лейбла поля поиска.
   _SEARCH_LEAD_ICON_PARAMS:
      title: 'Нажмите для поиска'

   # @const {Object} - используемые ссылки.
   _REFS: keyMirror(
      exportButton: null
   )

   # @const {Object} - параметры кнопки создания новой записи.
   _BUTTON_NEW_RECORD_PARAMS:
      caption: 'Создать'
      title: 'Создать новую запись'
      icon: 'plus'
      isMain: true

   # @const - параметры для иконки кнопки открытия панели операций.
   _OPERATIONS_BUTTON_ICONS:
      open: 'arrow-down'
      close:'arrow-right'

   # @const - параметры для кнопки открытия панели фильтрации.
   _FILTER_BUTTON_PARAMS:
      ready:
         caption: 'Отобрать'
         icon: 'filter'
      applied:
         caption: 'Отобрано'
         icon: 'check'

   # @const {Object} - параметры объекта выбора кол-ва записей.
   _PER_PAGE_PARAMS:
      caption: 'показывать'
      title: 'Количество записей на странице'
      defaultKey: 15
      list:
         5: 5
         10: 10
         15: 15
         20: 20
         30: 30
         50: 50
         100: 100
         all: 'все'

   # @const {Object} - параметры для панели операций.
   _PANEL_AREA_PARAMS:
      animation: 'slideDown'
      anchor: 'stream'

   # @const {Object} - набор наименований панелей.
   _PANEL_NAMES: keyMirror(
      filter: null
      massApplication: null
      none: null
   )

   # @const {Object} - параметры
   _USER_FILTER_TRIGGER_PARAMS:
      opened:
         icon: 'caret-square-o-down'
         title: 'скрыть пользовательские фильтры'
      closed:
         icon: 'caret-square-o-up'
         title: 'пользовательские фильтры'

   # @const {Object} - параметры для кнопки открытия панели параметров экспорта данных.
   _DATA_EXPORT_BUTTON_PARAMS:
      icon: 'upload'
      title: 'Эксопрт данных'

   # @const {Object} - параметры для кнопки открытия панели настроек таблицы.
   _SETTINGS_BUTTON_PARAMS:
      icon: 'cog'
      title: 'Настройки'

   # @const {String} - идет экспорт данных.
   _EXPORT_LOADER_TITLE: 'Идет подготовка файлов экспорта...'

   # @const {String} - тип поля ввода - чекбокс.
   _INPUT_CHECKBOX_TYPE: 'checkbox'

   # @const {String} - надпись в пустом поле поиска.
   _SEARCH_PLACEHOLDER: 'Наберите и нажмите Enter'

   # @const {String} - всплывающий заголовок на селекторе всех записей.
   _SELECT_ALL_TITLE: 'Выбрать всё'

   # @const {String} - надпись на кнопке показа массовых операций по-умолчанию.
   _OPERATIONS_BUTTON_DEFAULT_CAPTION: 'Операции'

   # @const {String} - префикс для ссылки на кнопку выполнения массовых операций.
   _OPERATION_KEY_PREFIX: 'operation_'

   mixins: [HelpersMixin, AnimateMixin, AnimationsMixin.collapse]

   styles:
      common:
         width: '100%'
         whiteSpace: 'nowrap'
      selectAllCell:
         width: 28
      allSelector:
         outlineWidth: 1
         outlineStyle: 'solid'
         outlineColor: _COLORS.hierarchy3
         outlineOffset: 3
         marginRight: _COMMON_PADDING + 1
      searchCell:
         width: '80%'
         padding: _COMMON_PADDING
         paddingLeft: 2
      operationCell:
         padding: _COMMON_PADDING
         paddingLeft: 0
         width: '1%'
      cellWithLeftPadding:
         paddingLeft: _COMMON_PADDING
      userFiltersCell:
         paddingLeft: 2
         paddingRight: _COMMON_PADDING
      hiddenCell:
         display: 'none'
      shownCell:
         display: ''
      markedAsPanelCell:
         backgroundColor: _COLORS.hierarchy4
         paddingLeft: _COMMON_PADDING
      perPageCell:
         width: '10%'
         textAlign: 'right'
         whiteSpace: 'nowrap'
         fontSize: 12
         color: _COLORS.hierarchy2
      perPageCellCaption:
         padding: _COMMON_PADDING
      operationPanel:
         backgroundColor: _COLORS.hierarchy4
         padding: _COMMON_PADDING
         marginBottom: _COMMON_PADDING
      operationsButton:
         borderWidth: 2
      sparceMassOperationButton:
         marginRight: _COMMON_PADDING
      sparceMassOperationButtonLast:
         marginRight: 0

   getDefaultProps: ->
      markedRowsStatistic:
         marked: 0
         total: 0

   getInitialState: ->
      isOperationsPanelOpen: false
      isUserFiltersAreaOpen: true
      isAllRowsMarked: @props.isAllRowsMarked
      activePanel: @props.recordsOperations.none
      userFilters: []

   componentWillReceiveProps: (nextProps) ->
      nextMarkedStatistic = nextProps.markedRowsStatistic
      nextIsAllRowsMarked = nextProps.isAllRowsMarked

      if nextMarkedStatistic
         nextMarkedCount = nextMarkedStatistic.marked

         # Если в следующих значениях статистики по выделенным строкам
         #  нет выделенных строк, но ранее они были и показана панель операций
         #  - скроем панель.
         unless nextMarkedCount
            currentMarkedCount = @props.markedRowsStatistic.marked
            isOtherMarkedCount = currentMarkedCount isnt nextMarkedCount

            if isOtherMarkedCount and @state.isOperationsPanelOpen
               @setState activePanel: @props.recordsOperations.none

      if nextIsAllRowsMarked isnt @props.isAllRowsMarked
         @setState
            isAllRowsMarked: nextIsAllRowsMarked

   componentWillUpdate: (nextProps, nextState) ->
      nextActivePanel = nextState.activePanel
      isNextPanelNone = nextActivePanel is @props.recordsOperations.none
      isPanelOpen = @state.isOperationsPanelOpen
      isOtherPanel = nextActivePanel isnt @state.activePanel

      # Если следующая активная панель не "пусто" и панель операций открыта
      #  и было переключение на другую панель - нужно вызвать обработчик переключения
      #  состояния панели.
      if !isNextPanelNone and isPanelOpen and isOtherPanel
         @_fireOnAfterTriggerPanelHandler(nextActivePanel)

   render: ->
      panelParams = @_PANEL_AREA_PARAMS

      `(
         <div>
            {this._getUserFiltersArea()}
            <table style={this.styles.common}>
               <tbody>
                  <tr>
                     {this._getAllSelectorCell()}
                     {this._getUserFiltersTriggerCell()}
                     {this._getMassApplicationCell()}
                     {this._getFilterCell()}
                     {this._getCreateCell()}
                     {this._getSearchCell()}
                     {this._getPerPageSelectorCell()}
                     {this._getExportCell()}
                     {this._getSettingsTriggerCell()}
                  </tr>
               </tbody>
            </table>
            <ArbitraryArea content={this._getOperationPanelContent()}
                           isCloseOnBlur={false}
                           isCatchFocus={false}
                           target={this._isPanelShown()}
                           layoutAnchor={panelParams.anchor}
                           animation={panelParams.animation}
                           styleAddition={this.styles.operationPanel}
                           isHasBorder={false}
                           onShow={this._onTriggerPanel}
                           onHide={this._onTriggerPanel}
                        />

         </div>
       )`

   ###*
   * Функция формирования области пользовательских фильтров
   *
   * @return {React-element, undefined} - панель действий.
   ###
   _getUserFiltersArea: ->
      if @props.enableUserFilters
         fluxParamsUF = @props.fluxParamsUserFilters

         `(
            <DataTableUserFiltersArea modelParams={this.props.modelParams}
                                      fluxParams={fluxParamsUF}
                                      isOpened={this.state.isUserFiltersAreaOpen}
                                      isFilterReset={!this.props.filterFlags.isUser}
                                      onAfterInit={this.props.onAfterReceiveFilters}
                                      onSelectFilter={this.props.onClickUserFilter}
                                      onAfterCreate={this.props.onAfterCreateFilter}
                                      onAfterUpdate={this.props.onAfterUpdateFilter}
                                      onAfterDelete={this.props.onAfterDeleteFilter}
                                    />
          )`

   # onAfterInit={this._onAfterGetUserFilters}
   # onSelectFilter={this._onClickUserFilter}
   # onAfterCreate={this._onAfterCreateFilter}

   # onClickUserFilter={this._onClickUserFilter}
   # onAfterReceiveFilters={this._onAfterReceiveFilters}
   # onAfterCreateFilter={this._onAfterCreateFilter}

   ###*
   * Функция формирования ячейки с селектором всех записей.
   *
   * @return {React-element} - узел с ячейкой.
   ###
   _getAllSelectorCell: ->
      if @props.enableRowSelect and (
         @props.isHierarchicallyViewTable or !@props.enableColumnsHeader)
         `(
            <td style={this.styles.selectAllCell}>
               <input style={this.styles.allSelector}
                      type={this._INPUT_CHECKBOX_TYPE}
                      title={this._SELECT_ALL_TITLE}
                      onChange={this._onClickSelectAll}
                      checked={this.state.isAllRowsMarked} />
            </td>
          )`

   ###*
   * Функция формирования ячейки с элементами массовых операций. Получает либо кнопку
   *  открытия панели операций, либо непосредственного кнопки массовых операций, если
   *  задана опция isInPanel = false.
   *
   * @return {React-element} - целевой узел с кнопкой/кнопками массовых операций.
   ###
   _getMassApplicationCell: ->
      massOperations = @props.massOperations

      if massOperations? and !_.isEmpty massOperations
         isOperationInPanel = massOperations.isInPanel

         operationPanelContent =
            if isOperationInPanel
               `(
                  <Button caption={this._getMassOperationsButtonCaption()}
                          onClick={this._onClickOperationsOpen}
                          icon={this._getMassOperationOpenPanelButtonIcon()} />
                )`
            else
               @_getOperationsControls(isOperationInPanel)

         `(
            <td style={this._getMassApplicationCellStyle(isOperationInPanel)}>
               {operationPanelContent}
            </td>
         )`

   ###*
   * Функция формирования ячейки со строкой поиска по таблице.
   *
   * @return {React-element} - узел с ячейкой.
   ###
   _getSearchCell: ->
      if @props.enableSearch
         placeholder = @props.searchPlaceholder or @_SEARCH_PLACEHOLDER

         `(
            <td style={this.styles.searchCell}>
               <Input placeholder={placeholder}
                      popupParams={this._SEARCH_POPUP_PARAMS}
                      leadIcon={this._SEARCH_LEAD_ICON_PARAMS}
                      isSearch={true}
                      onChange={this._onSearchChange}
                      onEmitValue={this._onEmitValueSearch}
                      onClear={this.props.onClearSearch}
                   />
            </td>
          )`

   ###*
   * Функция формирования ячейки с кнопкой создания новой записи.
   *
   * @return {React-element} - узел с ячейкой.
   ###
   _getCreateCell: ->
      if @props.enableCreate
         createButtonParams = _.cloneDeep(@props.createButtonParams)
         buttonParams = _.merge({}, @_BUTTON_NEW_RECORD_PARAMS, createButtonParams)

         `(
            <td style={this._getCreateCellStyle()}>
               <Button onClick={this.props.onClickNewRecord}
                       {...buttonParams}
                     />
            </td>
         )`

   ###*
   * Функция формирования ячейки с кнопкой открытия панели фильтрации.
   *
   * @return {React-element} - узел с ячейкой.
   ###
   _getFilterCell: ->
      ###*
      * Функция формирования параметров для кнопки фильтра.
      *
      * @return {Object} - параметры кнопки.
      ###
      getFilterButtonParams = (->
         filterButtonParams = _.cloneDeep(@props.filterButtonParams)
         buttonParams = @_FILTER_BUTTON_PARAMS

         if filterButtonParams?
            customAppliedParams = filterButtonParams.applied
            customReadyParams = filterButtonParams.ready
            customCommonParams = filterButtonParams.common

         triggerParams =
            if @props.filterFlags.isComplex
               _.merge({}, buttonParams.applied, customAppliedParams)
            else
               _.merge({}, buttonParams.ready, customReadyParams)

         _.merge({}, triggerParams, customCommonParams)

      ).bind(this)

      if @props.enableFilter
         filterButtonParams = getFilterButtonParams()
         `(
            <td style={this._getFilterCellStyle()}>
               <Button onClick={this._onClickFilterOpen}
                       {...filterButtonParams}
                     />
            </td>
          )`


   ###*
   * Функция формирования ячейки переключателя видимости области пользовательских
   *  фильтров.
   *
   * @return {React-element} - ячейка с кнопкой переключателя.
   ###
   _getUserFiltersTriggerCell: ->
      if @props.enableUserFilters and @_isHasUserFilters()
         isUserFiltersAreaOpen = @state.isUserFiltersAreaOpen
         triggerParams = @_USER_FILTER_TRIGGER_PARAMS
         buttonParams = if isUserFiltersAreaOpen
                           triggerParams.opened
                        else
                           triggerParams.closed

         `(
            <td style={this.styles.userFiltersCell}>
               <Button icon={buttonParams.icon}
                       title={buttonParams.title}
                       onClick={this._onClickTriggerUserFilters}
                     />
            </td>
          )`

   ###*
   * Функция формирования ячейки с селектором выбора кол-ва записей на странице.
   *
   * @return {React-element} - узел с ячейкой.
   ###
   _getPerPageSelectorCell: ->
      if @props.enablePerPageSelector
         perPageParam = _.cloneDeep(@_PER_PAGE_PARAMS)
         perPageList = perPageParam.list
         isSuppressAllRecordsSelector = @props.isSuppressAllRecordsSelector

         if isSuppressAllRecordsSelector
            delete perPageList.all

         `(
           <td style={this.styles.perPageCell}>
               <span style={this.styles.perPageCellCaption}>
                  {perPageParam.caption}
               </span>
               <DropDown title={perPageParam.title}
                         initItem={
                           {
                              key: this._getInitPerPageKey()
                           }
                         }
                         list={perPageList}
                         isFatSelector={true}
                         onSelect={this._onSelectPerPage} />
            </td>
          )`

   ###*
   * Функция формирования ячейки кнопки открытия панели экспорта данных.
   *
   * @return {React-element}
   ###
   _getExportCell: ->
      if @props.enableExport
         dataExportButtonParams = @_DATA_EXPORT_BUTTON_PARAMS

         `(
            <td>
               <Button ref={this._REFS.exportButton}
                       icon={dataExportButtonParams.icon}
                       title={dataExportButtonParams.title}
                       onClick={this.props.onClickDataExportTrigger}
                     />
               <AjaxLoader target={this.refs[this._REFS.exportButton]}
                           title={this._EXPORT_LOADER_TITLE}
                           isAdaptive={true}
                           isShown={this.props.isExportRequested}
                        />
            </td>
          )`

   ###*
   * Функция формирования ячейки с переключателем панели настроек таблицы.
   *
   * @return {React-element}
   ###
   _getSettingsTriggerCell: ->
      if @props.enableSettings
         settingsButtonParams = @_SETTINGS_BUTTON_PARAMS

         `(
            <td>
               <Button icon={settingsButtonParams.icon}
                       title={settingsButtonParams.title}
                       onClick={this.props.onClickSettingsTrigger}
                     />
            </td>
          )`

   ###*
   * Функция формирования содержимого панели операций. В зависимости от того какая
   *  выбрана в данный момент активная панель формирует или содержимое для
   *  массовых операций либо содержимое фильтра таблицы.
   *
   * @return {React-element} - узел-содержимое для панели операций.
   ###
   _getOperationPanelContent: ->
      recordsOperations = @props.recordsOperations

      # switch @state.activePanel
      #    when recordsOperations.massApplication
      #       @_getOperationsControls()
      #    when recordsOperations.filter
      if @props.entityParams? #and @state.activePanel is recordsOperations.filter
         if @state.activePanel is recordsOperations.massApplication
            @_getOperationsControls()
         else
            fluxParamsUF = @props.fluxParamsUserFilters

            `(
               <DataTableFilter entityParams={this.props.entityParams}
                                filterParams={this.props.filterParams}
                                modelParams={this.props.modelParams}
                                userFilterParams={this.props.userFilterParams}
                                isFilterApply={this.props.filterFlags.isComplex}
                                enableUserFilters={this.props.enableUserFilters}
                                implementationStore={this.props.implementationStore}
                                isUseImplementation={this.props.isUseImplementation}
                                isMergeImplementation={this.props.isMergeImplementation}
                                fluxParamsUserFilters={fluxParamsUF}
                                reflectionRenderParams={this.props.reflectionRenderParams}
                                dataManipulationParams={this.props.dataManipulationParams}
                                onApplyFilter={this._onApplyFilter}
                              />
            )`

   ###*
   * Функция формирования узла компонентов для выполнения массовых операций над записями.
   *
   * @return {React-element}
   ###
   _getOperationsControls: ->
      massOperationsProp = @props.massOperations
      massOperations = massOperationsProp.operations
      isSparceButtons = massOperationsProp.isSparceButtons
      dataTableToolbar = this
      sparceButtonsStyle =
         if isSparceButtons
            @styles.sparceMassOperationButton
      massOperationsCount = massOperations.length
      lastSparceButtonStyle = @styles.sparceMassOperationButtonLast


      controls = massOperations.map (operation, idx) ->
         operationName = operation.name
         additionButtonParams = operation.additionButtonParams
         isLinkButton = !operation.isOrdinaryButton
         isLast = (idx + 1) is massOperationsCount

         styleAddition =
            dataTableToolbar.computeStyles sparceButtonsStyle,
               (isSparceButtons and isLast) and lastSparceButtonStyle,
               operation.styleAddition

         `(
            <Button key={dataTableToolbar._OPERATION_KEY_PREFIX + operationName}
                    caption={operation.caption}
                    title={operation.title}
                    icon={operation.icon}
                    isLink={isLinkButton}
                    styleAddition={styleAddition}
                    value={operationName}
                    onClick={dataTableToolbar.props.onClickOperation}
                    {...additionButtonParams}
                  />
          )`

   ###*
   * Функция формирования заголовка для кнопки открытия панели массовых операций.
   *
   * @return {String}
   ###
   _getMassOperationsButtonCaption: ->
      massOperationParams = @props.massOperations
      caption = massOperationParams? and
                massOperationParams.panelOpenButtonCaption or
                @_OPERATIONS_BUTTON_DEFAULT_CAPTION

      "#{caption} (#{@_getMarkedRowsCount()}) "

   ###*
   * Функция получения ключа из списка возможных вариантов вывода кол-ва записей
   *  на странице. Проверяет входит ли заданный ключ в список возможных, если входит
   *  - возвращает его, иначе возвращает ключ по-умолчанию.
   *
   * @return {Number, String}
   ###
   _getInitPerPageKey: ->
      perPageProp = @props.recordsPerPage
      perPageParams = @_PER_PAGE_PARAMS
      perPageList = perPageParams.list
      perPageListKeys = Object.keys(perPageList)

      if perPageProp? and perPageList.hasOwnProperty perPageProp
         perPageProp
      else
         perPageParams.defaultKey

   ###*
   * Функция получения следующего наименования активной панели. Проверяет
   *  является ли panelName текущей активной панелью. Если является, то скидывает
   *  активную панель. Иначе(если активная панель была другая) возвращает
   *  наименование, переданное через параметр.
   *
   * @param {String} panelName - наименование панели.
   * @return {String} - наименование следующей панели.
   ###
   _getTriggeredPanelName: (panelName) ->
      nonePanel = @props.recordsOperations.none
      isThisActivePanel = @state.activePanel is panelName

      if isThisActivePanel
         nonePanel
      else
         panelName

   ###*
   * Функция получения кол-ва выбранных в таблице строк.
   *
   * @return {Number} - кол-во выбранных строк.
   ###
   _getMarkedRowsCount: ->
      if @_isHasMarkedRows()
         @props.markedRowsStatistic.marked
      else
         0

   ###*
   * Функция получения стиля ячейки массовых операций.
   *
   * @return {Object} - скомпанованный стиль для ячейки.
   ###
   _getMassApplicationCellStyle: (isInPanel) ->
      @computeStyles isInPanel and @styles.hiddenCell,
                     @styles.operationCell,
                     @_isHasMarkedRows() and @styles.shownCell,
                     @_isActiveMassApplicationPanel() and @styles.markedAsPanelCell

   ###*
   * Функция получения стиля ячейки с кнопкой открытия фильтра.
   *
   * @return {Object} - скомпанованный стиль для ячейки.
   ###
   _getFilterCellStyle: ->
      @computeStyles @styles.operationCell,
                     @_isActiveFilterPanel() and @styles.markedAsPanelCell,
                     @_isActiveMassApplicationPanel() and @styles.cellWithLeftPadding

   ###*
   * Функция получения стиля ячейки создания записи. Если показана панель операций
   *  добавляет дополнительный отспут в ячейке.
   *
   * @return {Object} - скомпанованный стиль для ячейки массовых операций.
   ###
   _getCreateCellStyle: ->
      @computeStyles @styles.operationCell,
                     @_isActiveFilterPanel() and @styles.cellWithLeftPadding
   ###*
   * Функция получения иконки кнопки открытия панели массовых операций.
   *  Возвращает различную иконку в зависимости видимости панели операций.
   *
   * @return {String} - наименование иконки
   ###
   _getMassOperationOpenPanelButtonIcon: ->
      operationsButtonIcons = @_OPERATIONS_BUTTON_ICONS

      if @state.activePanel is @props.recordsOperations.massApplication
         operationsButtonIcons.open
      else
         operationsButtonIcons.close

   ###*
   * Обработчик клика по кнопке пользовательского фильтра.
   *
   * @param {Object} filterParams - параметры пользовательского фильтра.
   * @return
   ###
   _onClickUserFilter: (filterParams) ->
      onClickUserFilterHandler = @props.onClickUserFilter
      onClickUserFilterHandler filterParams if onClickUserFilterHandler?

   ###*
   * Обработчик клика по кнопке скрытия/показа панели массовых операций.
   *  Вызывает обработчик клика по кнопке показа/скрытия панели операций,
   *  передает состояние панели(скрыт, показан).
   *
   * @return
   ###
   _onClickOperationsOpen: ->
      @setState
         activePanel: @_getTriggeredPanelName(@props.recordsOperations.massApplication)

   ###*
   * Обработчик клика по кнопке скрытия/показа фильтра
   *
   * @return
   ###
   _onClickFilterOpen: ->
      @setState
         activePanel: @_getTriggeredPanelName(@props.recordsOperations.filter)

   ###*
   * Обработчик, запускаемый после скрытия/показа панели области действий.
   *  Запускает обработчик на скрытие.
   *
   * @return
   ###
   _onTriggerPanel: ->
      @_fireOnAfterTriggerPanelHandler()

      @setState isOperationsPanelOpen: !@state.isOperationsPanelOpen

   ###*
   * Обработчик клика по кнопке скрытия/показа области пользовательских фильтров.
   *
   * @return
   ###
   _onClickTriggerUserFilters: ->

      @setState isUserFiltersAreaOpen: !@state.isUserFiltersAreaOpen

   ###*
   * Обработчик на выбор значения в списке кол-ва записей на странице
   *
   * @param {Object} item - выбранное значение
   * @return
   ###
   _onSelectPerPage: (item) ->
      @props.onChangePerPage item.value

   ###*
   * Обработчик изменения текста в поле поиска.
   *
   * @param {String} searchValue - значение в поле ввода
   * @return
   ###
   _onSearchChange: (searchValue) ->
      # Запустим обработчик сброса значения поиска, если значение пустое.
      @props.onClearSearch() unless searchValue

   ###*
   * Обработчик нажатия на клавишу в поле поиска. Передает в обработчик
   *  поиска, заданный через параметры значение поиска.
   *
   * @param {Object} inputValue - объект события
   * @return
   ###
   _onEmitValueSearch: (searchValue) ->
      if searchValue?
         onSearchHandler = @props.onSearch
         onSearchHandler searchValue if onSearchHandler?

   ###*
   * Обработчик на применение фильтра. Устанавливает состояние флаг
   *  применен/отменен фильтр.
   *
   * @param {Object} filterParams - параметры фильтрации.
   * @return
   ###
   _onApplyFilter: (filterParams) ->
      onApplyFilterHandler = @props.onApplyFilter
      onApplyFilterHandler filterParams if onApplyFilterHandler?

   ###*
   * Обработчик клика по селектору выбора всех записей.
   *
   * @return
   ###
   _onClickSelectAll: (event) ->
      isAllSelected = event.target.checked

      onClickSelectAllHandler = @props.onClickSelectAll
      onClickSelectAllHandler isAllSelected if onClickSelectAllHandler

      @setState
         isAllRowsMarked: isAllSelected

   ###*
   * Функция-предикат для определения заданны ли пользовательские сфильтры.
   *
   * @return {Boolean}
   ###
   _isHasUserFilters: ->
      userFilters = @props.userFilters

      if userFilters? and !_.isEmpty userFilters
         filterRecords = userFilters.records

         return !!(filterRecords and filterRecords.length)

      false

   ###*
   * Функция-предикат для определения нужно ли показывать панель операций. Если
   *  наименование текущей активной панели не none - значит нужно показать панель.
   *
   * @return {Boolean} - флаг есть активная панель/нет активной панели.
   ###
   _isPanelShown: ->
      @state.activePanel isnt @props.recordsOperations.none

   ###*
   * Функция-предикат для определения активная ли панель фильтра.
   *
   * @return {Boolean} - флаг активна/неактивна
   ###
   _isActiveFilterPanel: ->
      @state.activePanel is @props.recordsOperations.filter

   ###*
   * Функция-предикат для определения активная ли панель массовых операций.
   *
   * @return {Boolean} - флаг активна/неактивна
   ###
   _isActiveMassApplicationPanel: ->
      @state.activePanel is @props.recordsOperations.massApplication

   ###*
   * Функция-предикат для определения наличия выделенных строк в таблице.
   *
   * @return {Boolean}
   ###
   _isHasMarkedRows: ->
      markedStatistic = @props.markedRowsStatistic
      isAllRowsMarked = @props.isAllRowsMarked

      isAllRowsMarked || !_.isEmpty(markedStatistic) and !!markedStatistic.marked

   ###*
   * Функция запуска обработчика после скрытия/показа панели операций
   *
   * @param {String} activePanel - наименование активной панели, если не передано,
   *                               инициализируется из текущего состояния.
   * @return
   ###
   _fireOnAfterTriggerPanelHandler: (activePanel) ->
      activePanel ||= @state.activePanel
      onAfterTriggerHandler = @props.onAfterTriggerPanel

      if onAfterTriggerHandler?
         onAfterTriggerHandler(activePanel)

###* Компонент: область пользовательских фильтров: часть компонента DataTable.
*
* @props:
*     {Object} modelParams      - параметры модели.
*     {Object} fluxParams       - параметры для запроса фильтров.
*     {Boolean} isOpened        - флаг того, что панель открыта.
*     {Boolean} isFilterReset   - флаг того, что фильтр сброшен.
*     {Function} onAfterInit    - обработчик после получения набора фильтров. Аргументы:
*                                 {Array} filters - набор фильтров.
*     {Function} onSelectFilter - обработчик выбора фильтра из набора. Аргументы:
*                                 {Object} filterParams - параметры фильтра.
*     {Function} onAfterCreate  - обработчик после создания фильтра. Аргументы:
*                                 {Object} newFilterParams - параметры нового фильтра.
*     {Function} onAfterUpdate  - обарботчик после обновления фильтра. Аргументы:
*                                 {Object} updatedFilterParams - параметры обновленного фильтра.
*     {Function} onAfterDelete  - обработчик после удаления фильтра. Аргументы:
*                                 {String} deletedKey - удаленный ключ.
* @state
*     {Array<Object>} filters     - набор параметров пользовательских фильтров.
*     {Boolean} isFiltersReceived - флаг того, что фильтры считаны.
*     {Boolean} isOtherFilterApplied - флаг того, что применен фильтр из списка
*                                      остальных (не основных).
*     {Boolean} isFiltersCountChanged - идентификатор того, что кол-во фильтров
*                                       изменилось и нужно произвести процедуры
*                                       адаптивности по-новой.
*     {React-element, undefined} loaderTarget - целевой узел для загрузчика.
*     {Number} buttonsMaxCount     - максимальное кол-во кнопок пользовательского
*                                   фильтра, умещающегося в одну строку.
*###
DataTableUserFiltersArea = React.createClass

   # @const {Object} - набор ключей для считывания параметров ответов из БЛ.
   _RESPONSE_KEYS: keyMirror(
      records: null
      create: null
      update: null
      deletedKey: null
   )

   # @const {Object} - параметры произвольной области
   _ARBITRARY_AREA_PARAMS:
      animation: 'slideUp'
      layoutAnchor: 'stream'
      isCloseOnBlur: false
      isCatchFocus: false

   # @const {Object} - набор наименований ссылок.
   _REFS:
      buttonGroup: 'filterButtons'
      buttonsContainer: 'buttonsContainer'
      area: 'filterArea'
      otherSelector: 'otherFilterSelector'

   # @const {Object} - параметры для кнопок применения неосновных фильтров.
   _OTHER_FILTER_BUTTONS_PARAMS:
      apply:
         title: 'Применить фильтр'
         icon: 'arrow-right'
      cancel:
         title: 'Отменить фильтр'
         icon: 'ban'

   mixins: [HelpersMixin]

   styles:
      common:
         padding: _COMMON_PADDING
      filterButton:
         color: _COLORS.hierarchy2
      otherSelectorDropDown:
         fontSize: 12
         color: _COLORS.hierarchy2
         marginTop: _COMMON_PADDING
      otherFilterButton:
         color: _COLORS.hierarchy2
         marginLeft: _COMMON_PADDING

   getInitialState: ->
      filters: []
      isFiltersReceived: false
      isOtherFilterApplied: false
      isFiltersCountChanged: false
      loaderTarget: undefined
      buttonsMaxCount: undefined

   # shouldComponentUpdate: (nextProps, nextState) ->
   #    if !@state.isFilterCountChanged and nextState.filters?
   #       @setState isFiltersCountChanged: @_isFilterCountChanged(nextState.filters)
   #    true

   render: ->
      areaParams = @_ARBITRARY_AREA_PARAMS
      filters = @state.filters
      isFiltersReceived = @state.isFiltersReceived

      if (isFiltersReceived and filters? and filters.length) or !isFiltersReceived
         `(
             <ArbitraryArea {...areaParams}
                            ref={this._REFS.area}
                            content={this._getAreaContent()}
                            target={this.props.isOpened}
                         />
          )`
      else
         null

   componentDidUpdate: (prevProps, prevState)->
      filters = @state.filters
      isFiltersReceived = !!(filters? and filters.length)
      isMaxButtonsCountNeedSet = !@state.buttonsMaxCount? and isFiltersReceived

      # console.log isMaxButtonsCountNeedSet

      # Если макс. кол-во кнопок в линию ещё не было установлено и это кол-во
      #  необходимо установить (фильтры считаны)
      #  или кол-во фильтров изменилось - считываем и устанавливаем макс. кол-во
      #  кнопок, умещающихся в одну линию.
      if isMaxButtonsCountNeedSet or @state.isFiltersCountChanged
         @_readAndSetMaxButtonCount()

   componentDidMount: ->
      fluxParams = @props.fluxParams

      if fluxParams?
         initParams = fluxParams.init
         fluxStore = fluxParams.store

         if initParams? and fluxStore?
            modelParams = @props.modelParams
            # Отправляем запрос на считывания пользовательских фильтров
            sendRequestHandler = initParams.sendRequest
            sendRequestHandler modelParams.name

            # Подписываемся на изменение хранилища flux.
            fluxStore.addChangeListener @_onChange

            @setState loaderTarget: ReactDOM.findDOMNode(this)

   ###*
   * Функция получения содержимого области произвольной области - пользоватлеьские
   *  фильтры и индикатор загрузки.
   *
   * @return {React-element} - содержимое области пользовательских фильтров.
   ###
   _getAreaContent: ->

      `(
         <div style={this.styles.common}
              ref={this._REFS.buttonsContainer}>
            {this._getFilterButtons()}
            {this._getFilterSelector()}
            <AjaxLoader isShown={!this.state.isFiltersReceived}
                        isAdaptive={true}
                        target={this.state.loaderTarget} />
         </div>
       )`

   ###*
   * Функция получения кнопок пользовательских фильтров.
   *
   * @return {React-element, undefined}
   ###
   _getFilterButtons: ->
      filters = @state.filters

      if filters? and filters.length
         paramsForButton = []
         buttonsMaxCount = @state.buttonsMaxCount
         isFiltersCountChanged = @state.isFiltersCountChanged
         filtersCount = filters.length
         iterateCount = if isFiltersCountChanged
                           filtersCount
                        else
                           buttonsMaxCount || filtersCount
         filterFlags = @props.filterFlags
         isOtherApplied = @state.isOtherFilterApplied
         isResetActivated = @props.isFilterReset or isOtherApplied
         idx = 0

         # Перебираем параметры считанных фильтров и подготавливаем параметры
         #  для каждой кнопки для дальнейшей передачи в компонент группы кнопок.
         #for filterParam in filters
         while idx < iterateCount
            filterParam = filters[idx]

            paramsForButton.push
               caption: filterParam.name
               title: filterParam.description
               value: JSON.parse(filterParam.filter)
               styleAddition: @styles.filterButton

            idx++

         `(
             <ButtonGroup ref={this._REFS.buttonGroup}
                          isResetActivated={isResetActivated}
                          buttons={paramsForButton}
                          enableDeactivating={true}
                          onClickButton={this._onClickSelectFilter} />
          )`

   ###*
   * Функция получения селектора вторичных пользовательских фильтров (которые
   *  не уместились в одну линию).
   *
   * @return {React-element}
   ###
   _getFilterSelector: ->
      filters = @state.filters
      buttonsMaxCount = @state.buttonsMaxCount

      if (filters? and filters.length) and buttonsMaxCount?
         startIdx = buttonsMaxCount
         filtersCount = filters.length
         otherFilterButtonParams = @_OTHER_FILTER_BUTTONS_PARAMS
         buttonApply = otherFilterButtonParams.apply
         buttonCancel = otherFilterButtonParams.cancel
         isOtherFilterApplied = @state.isOtherFilterApplied
         isFilterReset = @props.isFilterReset
         isNeedCancelButton = isOtherFilterApplied and !isFilterReset

         if startIdx and (startIdx < filtersCount)
            selectorItems = filters[startIdx..]
            processedItems = {}

            for item in selectorItems
               itemName = item.name

               processedItems[itemName] = item

            `(
               <div>
                  <DropDown ref={this._REFS.otherSelector}
                            list={processedItems}
                            isComplex={true}
                            isFatSelector={true}
                            styleAddition={
                              {
                                 selector: {
                                    common: this.styles.otherSelectorDropDown
                                 }
                              }
                            }
                         />
                  <Button title={buttonApply.title}
                          icon={buttonApply.icon}
                          styleAddition={this.styles.otherFilterButton}
                          onClick={this._onClickApplyOtherFilter}
                        />
                  {
                     isNeedCancelButton
                     ? <Button title={buttonCancel.title}
                              icon={buttonCancel.icon}
                              styleAddition={this.styles.otherFilterButton}
                              onClick={this._onClickCancelOtherFilter}
                            />
                     : ''
                  }
               </div>
             )`

   ###*
   * Функция получения ответа на начальный запрос фильтров.
   *
   * @param {Object} fluxParams - параметры flux.
   * @return
   ###
   _getInitResponse: (fluxParams) ->
      if @_isRequiredResponse(fluxParams)
         response = fluxParams.getResponse()
         filterParams = @_readResponseParams(response)
         filterRecords = filterParams[@_RESPONSE_KEYS.records] if filterParams?
         filters = @_readFilters(filterRecords) if filterRecords?
         onAfterInitHandler = @props.onAfterInit

         if onAfterInitHandler? and filters?
            onAfterInitHandler filterParams

         @setState
            isFiltersReceived: true
            filters: filters

   ###*
   * Функция получения ответа на запрос создания фильтра.
   *
   * @param {Object} fluxParams - параметры flux.
   * @return
   ###
   _getCreateResponse: (fluxParams) ->
      if @_isRequiredResponse(fluxParams)
         keys = @_RESPONSE_KEYS
         response = fluxParams.getResponse()
         createResponse = @_readResponseParams(response, keys.create)
         newFilterFields = createResponse.fields
         newFilter = @_simplifyFields(newFilterFields)
         stateFilters = @state.filters
         filters = if stateFilters?
                      stateFilters[..]
                   else
                      []

         onAfterCreateFilterHandler = @props.onAfterCreate

         # Если удалось считать параметры нового фильтра - продолжим.
         if newFilter?
            filters.push(newFilter)

            # Если задан обработчик после создания фильтра, то вызовем его
            #  с передачей парметров нового фильтра.
            if onAfterCreateFilterHandler?
               onAfterCreateFilterHandler createResponse

            @setState
               filters: filters
               isFiltersCountChanged: true

   ###*
   * Функция получения ответа на запрос обновления фильтра.
   *
   * @param {Object} fluxParams - параметры flux.
   * @return
   ###
   _getUpdateResponse: (fluxParams) ->
      if @_isRequiredResponse(fluxParams)
         keys = @_RESPONSE_KEYS
         response = fluxParams.getResponse()
         updateResponse = @_readResponseParams(response, keys.update)
         updatedFilterFields = updateResponse.fields
         updatedFilter = @_simplifyFields(updatedFilterFields)
         filters = @state.filters[..]
         onAfterUpdateFilterHandler = @props.onAfterUpdate
         updatedIndex = 0

         if updatedFilter?
            for filter, idx in filters
               if filter.id is updatedFilter.id
                  updatedIndex = idx
                  break

            filters[updatedIndex] = updatedFilter

            if onAfterUpdateFilterHandler?
               onAfterUpdateFilterHandler updateResponse

            @setState filters: filters

   ###*
   * Функция получения ответа на запрос удаления фильтра.
   *
   * @param {Object} fluxParams - параметры flux.
   * @return
   ###
   _getDeleteResponse: (fluxParams) ->
      if @_isRequiredResponse(fluxParams)
         keys = @_RESPONSE_KEYS
         response = fluxParams.getResponse()
         deletedKey = @_readResponseParams(response, keys.deletedKey)
         filters = @state.filters[..]
         onAfterDeleteFilterHandler = @props.onAfterDelete
         deletedIndex = null

         if deletedKey?
            for filter, idx in filters
               if filter.id.toString() is deletedKey
                  deletedIndex = idx
                  break

            if onAfterDeleteFilterHandler?
               onAfterDeleteFilterHandler deletedKey

            if deletedIndex?
               filters.splice deletedIndex, 1

               @setState
                  filters: filters
                  isFiltersCountChanged: true

   ###*
   * Обработчик клика на кнопку из группы кнопок основных пользовательских фильтров.
   *
   * @param {Object} filterParams - параметры фильтра.
   * @return
   ###
   _onClickSelectFilter: (filterParams) ->
      onSelectFilterHandler  = @props.onSelectFilter

      if onSelectFilterHandler?
         onSelectFilterHandler filterParams

      @setState isOtherFilterApplied: false

   ###*
   * Обработчик клика на кнопку применения прочего пользовательского фильтра.
   *
   * @return
   ###
   _onClickApplyOtherFilter: ->
      otherFilterSelector = @refs[@_REFS.otherSelector]

      if otherFilterSelector?
         selectedOtherFilter = otherFilterSelector.getSelectedItem()
         onSelectFilterHandler = @props.onSelectFilter

         if onSelectFilterHandler? and selectedOtherFilter?
            filterParams = selectedOtherFilter.value
            filterValue = JSON.parse(filterParams.filter) if filterParams?

            onSelectFilterHandler filterValue if filterValue?

            @setState isOtherFilterApplied: true

   ###*
   * Обработчик клика на кнопку отмены прочего пользовательского фильтра.
   *
   * @return
   ###
   _onClickCancelOtherFilter: ->
      onSelectFilterHandler = @props.onSelectFilter

      if onSelectFilterHandler?
         onSelectFilterHandler {}

      @setState isOtherFilterApplied: false

   ###*
   * Обработчик события на изменение состояния хранилища.
   *
   * @return
   ###
   _onChange: ->
      return unless @.isMounted()

      fluxParams = @props.fluxParams

      if fluxParams?
         initParams = fluxParams.init
         createParams = fluxParams.create
         updateParams = fluxParams.update
         deleteParams = fluxParams.delete

         # Параметры начального запроса.
         if initParams?
            @_getInitResponse(initParams)

         # Параметры создания.
         if createParams?
            @_getCreateResponse(createParams)

         # Параметры обновления.
         if updateParams?
            @_getUpdateResponse(updateParams)

         # Параметры удаления.
         if deleteParams
            @_getDeleteResponse(deleteParams)

   ###*
   * Функция-предикат для определения является последнее изменение в хранилище
   *  ожидаемым событием.
   *
   * @param {Object} fluxParams - параметры flux.
   * @return
   ###
   _isRequiredResponse: (fluxParams) ->
      store = fluxParams.store
      responseType = fluxParams.responseType
      lastInteraction = @props.fluxParams.store.getLastInteraction()

      lastInteraction is responseType

   ###*
   * Функция-предикат для определения изменилось ли кол-во пользовательских
   *  фильтров.
   *
   * @param {Array} otherFilters - массив фильтров, отличных от текущих.
   * @return {Boolean}
   ###
   _isFilterCountChanged: (otherFilters) ->
      currentFilters = @state.filters

      if otherFilters? and currentFilters?
         return otherFilters.length isnt currentFilters.length

      false

   ###*
   * Функция считывания параметров ответа. Ожидает стандартную структуру ответа
   *  (json, errors) и из json считывает результат по переданному ключу.
   *
   * @param {Object} response - хэш параметров ответа.
   * @param {String, undefined} readKey  - ключ считывания из параметров.
   ###
   _readResponseParams: (response, readKey) ->
      json = response.json if response?

      if json?  and readKey?
         json[readKey]
      else
         json

   ###*
   * Функция считывания параметров фильтра из возвращенных записей. Возвращенные
   *  записи преобразуются из формата для таблицы данных преобразуются в простой
   *  массив с элементами с парой ключ-значение.
   *
   * @param {Array<Object>} records - набор записей.
   * @return {Array<Object>}
   ###
   _readFilters: (records) ->
      filtersArea = this

      records.map (record) ->
         fields = record.fields
         simplifiedFields = filtersArea._simplifyFields(fields)

         simplifiedFields

   ###*
   * Функция упрощения значения полей. Преобразует вложенный хэш fieldName: {fieldParams...}
   *  в fieldName: fieldValue
   *
   * @param {Object} fields - набор полей.
   * @return {Object}
   ###
   _simplifyFields: (fields) ->
      simplifiedFields = {}

      for fieldName, field of fields
         simplifiedFields[fieldName] = field.value

      simplifiedFields

   ###*
   * Функция считывания и установки максимального кол-ва кнопок в одну линию.
   *  Получает элемент группы кнопок и перебирает все кнопки, входящие в компонент
   *  и считает сколько умещается в ширину области фильтров.
   *
   * @return
   ###
   _readAndSetMaxButtonCount: ->
      domNode = ReactDOM.findDOMNode(this)

      if domNode?
         areaClientRect = domNode.getBoundingClientRect()
         areaWidth = areaClientRect.width
         refs = @_REFS
         buttonGroup = @refs[refs.buttonGroup]

         if buttonGroup?
            buttonGroupRefs = buttonGroup.refs
            buttonsMaxCount = 0
            totalButtonsWidth = _COMMON_PADDING * 2

            for elementName, element of buttonGroupRefs
               continue unless buttonGroup.isThisButtonByRef(elementName)

               elementWidth = ReactDOM.findDOMNode(element)
                                      .getBoundingClientRect()
                                      .width
               totalButtonsWidth += elementWidth

               break if totalButtonsWidth >= areaWidth

               buttonsMaxCount++

            @setState
               buttonsMaxCount: buttonsMaxCount
               isFiltersCountChanged: false


###* Компонент: фильтр таблицы: часть компонента DataTable
*
* @props:
*     {Object} entityParams            - хэш с параметрами сущности. Вид:
*        {Object} externalEntities     - хэш с параметрами внешних сущностей.
*        {Object} fieldParams          - хэш с параметрами полей таблицы.
*     {Object} reflectionRenderParams  - хэш параметров рендера полей выборки.
*    {Object} dataManipulationParams   - параметры манипуляции данными (для задания
*                                        ограничений полей).
*     {Object} filterParams            - хэш параметров примененного фильтра.
*     {Object} fluxParamsUserFilters   - параметры flux-инфраструктуры для
*                                        пользовательских фильтров.
*     {Object} userFilterParams        - параметры для пользовательских фильтров.
*     {Object} modelParams             - параметры модели таблцы.
*     {Object} implementationStore     - хранилище реализаций.
*     {Boolean} isUseImplementation    - флаг использования хранилища реализаций.
*     {Boolean} isMergeImplementation  - флаг слияния "реализуемых" свойств.
*     {Boolean} isFilterApply          - флаг примененного фильтра.
*     {Boolean} enableUserFilters      - флаг разрешения пользовательских фильтров.
*     {Function} onApplyFilter         - обработчик на применение фильтра.
* @state
*     {Array<Object>} filterRowParams  - массив параметров для строк фильтра.
*     {Boolean} isDialogSaveFilterOpen - флаг открытого диалога сохранения фильтра.
###
DataTableFilter = React.createClass
   mixins: [PureRenderMixin]

   # @const {String} - строка для ссылки на набор полей фильтра.
   _FILTER_ROWS_REF: 'filterRowParams'

   # @const {String} - условие диапазона.
   _RANGE_CONDITION_NAME: 'between'

   # @const {String} - операнд объединения условий (используется при составлении
   #                   шаблонов в условиях диапазона).
   _AND_UNION: 'and'

   # @const - параметры для кнопок управления
   _OPERATION_BUTTON_PARAMS:
      addRow:
         caption: 'Добавить условие'
         icon: 'plus'
         title: 'Добавить новую строку условий фильтра'
      apply:
         caption: 'Применить'
         icon: 'check'
         title: 'Применить фильтр'
      cancel:
         caption: 'Отменить'
         icon: 'ban'
         title: 'Отменить примененный фильтр'
      delete:
         caption: 'Удалить условие'
         icon: 'trash-o'
         title: 'Удалить последнюю строку условий фильтра'
      createUserFilter:
         caption: 'Сохранить фильтр'
         icon: 'save'
         title: 'Сохранить параметры фильтра для быстрого доступа.'

   # @const {Object} - условия сравнения (используется для построения условий диапазона).
   _COMPARISON_CONDITIONS: keyMirror(
      less_or_eq: null
      greater_or_eq: null
   )

   #_NON_FIELD_CONDITION_COLLECTION: ['is_null', 'is_not_null']

   # @const {Object} - используемые символы.
   _CHARS:
      brStart: '('
      brEnd: ')'
      varFiller: '%s'
      empty: ''
      space: ' '

   styles:
      common:
         overflow: 'auto'
      filterRows:
         fontSize: 12
         width: '100%'
         whiteSpace: 'nowrap'
      operationContainer:
         marginTop: _COMMON_PADDING * 2
         padding: _COMMON_PADDING
         borderTopStyle: 'solid'
         borderTopColor: _COLORS.hierarchy3
         borderTopWidth: 1

   getInitialState: ->
      rows = []
      rows.push(@_newFilterRowParam(true))

      filterRowParams: rows
      isDialogSaveFilterOpen: false

   render: ->
      buttonParams = @_OPERATION_BUTTON_PARAMS
      buttonApplyParams = buttonParams.apply
      buttonAddRowParams = buttonParams.addRow

      `(
         <div style={this.styles.common}>
            <table style={this.styles.filterRows}
                   cellPadding={2}>
               <DataTableFilterRows ref={this._FILTER_ROWS_REF}
                                    isUseImplementation={this.props.isUseImplementation}
                                    isMergeImplementation={this.props.isMergeImplementation}
                                    implementationStore={this.props.implementationStore}
                                    filterRowParams={this.state.filterRowParams}
                                    reflectionRenderParams={this.props.reflectionRenderParams}
                                    dataManipulationParams={this.props.dataManipulationParams}
                                 />
            </table>
            <div style={this.styles.operationContainer}>
               <Button icon={buttonAddRowParams.icon}
                       title={buttonAddRowParams.caption}
                       caption={buttonAddRowParams.caption}
                       isLink={true}
                       onClick={this._onClickAddFilterRow} />
               {this._getDeleteRowButton()}
               <Button icon={buttonApplyParams.icon}
                       title={buttonApplyParams.caption}
                       caption={buttonApplyParams.caption}
                       isLink={true}
                       onClick={this._onClickApplyFilter} />
               {this._getCancelFilterButton()}
               {this._getCreateUserFilterButton()}
            </div>
            <Dialog isShown={this.state.isDialogSaveFilterOpen}
                    isModal={true}
                    isMovable={true}
                    caption={this.props.userFilterParams.dialogTitle}
                    content={this._getSaveFilterForm()}
                    onHide={this._onHideDialogSaveFilter} />
         </div>
      )`

   ###*
   * Функция создания кнопки удаления строки условия фильтра.
   *
   * @return {React-element, undefined}
   ###
   _getDeleteRowButton: ->
      filterRowParams = @state.filterRowParams

      if filterRowParams? and filterRowParams.length > 1
         buttonParams = @_OPERATION_BUTTON_PARAMS.delete

         `(
            <Button isLink={true}
                    caption={buttonParams.caption}
                    title={buttonParams.title}
                    icon={buttonParams.icon}
                    onClick={this._onRemoveFilterRow}
                  />
         )`

   ###*
   * Функция создания кнопки отмены примененного фильтра.
   *
   * @return {React-element, undefined}
   ###
   _getCancelFilterButton: ->

      if @props.isFilterApply
         buttonParams = @_OPERATION_BUTTON_PARAMS.cancel

         `(
            <Button isLink={true}
                    caption={buttonParams.caption}
                    title={buttonParams.title}
                    icon={buttonParams.icon}
                    onClick={this._onClickCancelFilter}
                  />
         )`

   ###*
   * Функция создания кнопки сохранения фильтра.
   *
   * @return {React-element, undefined}
   ###
   _getCreateUserFilterButton: ->
      if @props.enableUserFilters and @props.isFilterApply
         buttonParams = @_OPERATION_BUTTON_PARAMS.createUserFilter

         `(
            <Button isLink={true}
                    caption={buttonParams.caption}
                    title={buttonParams.title}
                    icon={buttonParams.icon}
                    onClick={this._onClickCreateUserFilter}
                  />
         )`

   ###*
   * Функция создания статической формы для сохранения параметров
   *  пользовательского фильтра.
   *
   * @return {React-element, undefined}
   ###
   _getSaveFilterForm: ->
      if @state.isDialogSaveFilterOpen
         filterSaveParams = @props.userFilterParams
         fieldConstraints = filterSaveParams.fieldConstraints
         modelParams = @props.modelParams
         fieldConstraints[0].strongValue = modelParams.name
         fieldConstraints[1].strongValue = JSON.stringify @props.filterParams
         fluxParams = @props.fluxParamsUserFilters
         fluxParamsCreate = fluxParams.create if fluxParams?

         if fluxParamsCreate?
            fluxParamsCreate.store = fluxParams.store

         `(
             <DynamicForm modelParams={
                            {
                               name: filterSaveParams.modelName
                            }
                          }
                          fluxParams={fluxParamsCreate}
                          fieldConstraints={
                             {
                                constraints: fieldConstraints
                             }
                          }
                          onAfterGetResponse={this._onSuccessUserFilterCreate}
                        />
          )`


   ###*
   * Функция получения массива параметров по строкам фильтра.
   *
   * @return {Array}
   ###
   _getFilterParams: ->
      rowValues = []
      for _key, ref of @refs.filterRowParams.refs
         rowValue = ref.getValue()

         if rowValue?
            rowValues.push rowValue
      rowValues

   ###*
   * Функция получения строки-шаблона для параметров фильтрации. Шаблон определяет
   *  по какому условию соединяются условия выборки и как группируются
   *
   * @param {Array} filterParams - массив параметров фильтра
   * @return {String}
   ###
   _getFilterTemplate: (filterParams) ->
      templateMembers = @_getFilterTemplateMembers(filterParams)
      chars = @_CHARS
      varFillerChar = chars.varFiller
      brStartChar = chars.brStart
      brEndChar = chars.brEnd
      spaceChar = chars.space
      emptyChar = chars.empty
      andUnionOperand = @_AND_UNION
      elements = []

      for member, idx in templateMembers
         unionOperand = member.unionOperand
         isHasCloseBracket = member.isHasCloseBracket
         isHasOpenBracket = member.isHasOpenBracket
         isRangeCondition = member.isRangeCondition

         # Подготовим содержимое элемента условия. Если это условие диапазона,
         #  то разобъем элемент шаблона на два, объединенных в скобки.
         memberValue =
            if isRangeCondition
               [
                  brStartChar
                  varFillerChar
                  spaceChar
                  andUnionOperand
                  spaceChar
                  varFillerChar
                  brEndChar
               ].join emptyChar
            else
               varFillerChar

         unionOperand =
            if unionOperand? and idx
               [
                  spaceChar
                  unionOperand
                  spaceChar
               ].join emptyChar

         elements.push unionOperand
         elements.push brStartChar if isHasOpenBracket
         elements.push memberValue
         elements.push brEndChar if isHasCloseBracket

      elements.join emptyChar

   ###*
   * Функция получения членов для формирования строки-шаблона для параметров фильтрации.
   *
   * @param {Array} filterParams - массив параметров фильтра
   * @return {String}
   ###
   _getFilterTemplateMembers: (filterParams) ->
      templateMembers = []

      for param, idx in filterParams
         isCombined = param.isCombined
         isRangeCondition = @_isRangeCondition(param.condition)

         # Если текущий пункт комбинируется с предыдущим - произведем манипуляции
         #  с параметрами шаблона предыдущего члена.
         if isCombined
            prevIdx = idx - 1
            prevParam = filterParams[prevIdx]
            prevMember = templateMembers[prevIdx]

            prevMember.isHasCloseBracket = false
            prevMember.isHasOpenBracket = !prevParam.isCombined

         #if !prevParam or prevParam.value?
         templateMembers.push
            isHasOpenBracket: false
            isHasCloseBracket: isCombined
            isRangeCondition: isRangeCondition
            unionOperand: param.union

      templateMembers

   ###*
   * Функция считывания имен связок из параметров модели.
   *
   * @return {Array<String>}
   ###
   _getModelRelationNames: ->
      modelParams = @props.modelParams

      if modelParams?
         modelRelations = modelParams.relations

         if modelRelations?
            modelRelations.map (relation) ->
               pluralize.singular(relation.reflection)

   ###*
   * Функция-предикат для определения является ли проверяемое условие условием
   *  диапазона.
   *
   * @param {String} condition
   * @return {Boolean}
   ###
   _isRangeCondition: (condition) ->
      condition is @_RANGE_CONDITION_NAME

   ###*
   * Обработчик клика по кнопке примения фильтра. Считывает параметры со строк фильтра,
   *  подготавливает необходимые параметры для фильтрации значений таблицы и оповещает
   *  подписанный обработчик.
   *
   * @return
   ###
   _onClickApplyFilter: ->
      formattedFilterParams = null

      filterParams = @_getFilterParams()
      filterTemplate = @_getFilterTemplate filterParams
      formattedFilterParams =
         @_convertFilterParamsToDataTableFormat filterParams, filterTemplate

      # Если не было параметров фильтрации - дальше не продолжаем (фильтр не
      #  применяем).
      return unless formattedFilterParams.filter.terms.length

      onApplyFilterHandler = @props.onApplyFilter
      if onApplyFilterHandler
         onApplyFilterHandler formattedFilterParams


   ###*
   * Обработчик клика по кнопке отмены фильтра. Сбрасывает параметры фильтрации
   *  и оповещает подписанный обработчик с передачей сброшенных параметров фильтра.
   *
   * @return
   ###
   _onClickCancelFilter: ->

      onApplyFilterHandler = @props.onApplyFilter

      if onApplyFilterHandler
         onApplyFilterHandler null

   ###*
   * Обработчик клика по кнопку добавления строки фильтра. Создает новую строку и
   *  добавляет в массив строк фильтра.
   *
   * @return
   ###
   _onClickAddFilterRow: ->
      newRows = @state.filterRowParams[..]
      newRows.push(@_newFilterRowParam(false))

      @setState filterRowParams: newRows

   ###*
   * Обработчик изменения значения флага "объединить". Меняет флаг комбинируемости
   *  со следующей строкой фильтра для предыдущей строки.
   *
   * @return
   ###
   _onChangeCombine: (key, isChecked) ->
      rows = @state.filterRowParams[..]
      prevRowKey = key - 1
      isPrevFirstRow = prevRowKey is 0
      rows[prevRowKey] = @_newFilterRowParam(isPrevFirstRow, prevRowKey, isChecked)

      @setState filterRowParams: rows

   ###*
   * Обработчик на удаление строки фильтра с условиями фильтрации.
   *
   * @param {Number} key - ключ строки (индекс в наборе)
   * @return
   ###
   _onRemoveFilterRow: (key) ->
      rows = @state.filterRowParams[..]
      rows.splice (rows.length - 1), 1

      @setState filterRowParams: rows

   ###*
   * Обработчик изменения значения флага "объединить". Меняет флаг комбинируемости
   *  со следующей строкой фильтра для предыдущей строки.
   *
   * @return
   ###
   _onClickCreateUserFilter: ->
      @setState
         isDialogSaveFilterOpen: true

   ###*
   * Обработчик успешного результата выполнения операции сохранения
   *  пользовательского фильтра.
   *
   * @param {Object} response - полученный ответ.
   * @param {String} message  - сообщение о успешном выполнении.
   * @return
   ###
   _onSuccessUserFilterCreate: (response, message) ->
      @setState isDialogSaveFilterOpen: false

   ###*
   * Обработчик скрытия диалога сохранения пользовательского фильтра.
   *
   * @return
   ###
   _onHideDialogSaveFilter: ->
      @setState isDialogSaveFilterOpen: false

   ###*
   * Функция для конвертирования параметров фильтра в формат, подходящий для отправки
   *  запроса с фильтрацией в таблице данных.
   *
   * @param {Array} filerParams    - параметры фильтрации.
   * @param {String} filerTemplate - шаблон составления запроса фильтра.
   * @return {Object} - хэш с параметрами фильтра, подготовленные для запроса в таблице данных.
   ###
   _convertFilterParamsToDataTableFormat: (filterParams, filterTemplate) ->
      ###*
      * Функция добавления форматированного условия в набор условий фильтра.
      *
      * @param {Object} params     - параметры для создания элемента коллекции. Вид:
      *        {String} fieldParams- параметры поля.
      *        {String} expression - значение выражения фильтрации.
      *        {String} condition  - условие сравнения.
      *        {Object} affilation - параметры принадлежности поля (в какой
      *                              связке находится поле).
      *        {Boolean} isNonFieldCondition - флаг условия без значения выражения.
      *        {Array} collection
      ###
      addCondition = (params) ->
         fieldParams = params.fieldParams
         expression = params.expression
         condition = params.condition
         affilation = params.affilation
         isNonFieldCondition = params.isNonFieldCondition
         paramsCollection = params.collection

         if expression? or isNonFieldCondition
            paramsCollection.push
               field: fieldParams
               expr: expression
               match: condition
               affilation: affilation

      ###*
      * Функция получения принадлежности поля (в какой связке необходимо искать
      *  поле).
      *
      * @param {Object} field - параметры поля, возвращенные из селектора полей.
      * @param {Array<String>} excludingRelations - имена исключаемых из цепи привязки
      *                                             связок.
      * @return {undefined, Array}
      ###
      getFieldAffilation = ((field, excludingRelations) ->
         fieldAddition = field.addition
         sectionParams = fieldAddition.sectionParams if fieldAddition?

         modelParams = @props.modelParams
         modelName = modelParams.name
         modelNameView = modelParams.view

         if sectionParams? and !_.isEmpty(sectionParams)
            sectionName = sectionParams.name
            sectionParents = sectionParams.parents
            sectionData = sectionParams.sectionData
            isPolyAssociationsSet = false
            fieldParents = []

            # Если заданы параметры секции.
            if sectionData?
               # Считываем наименование полиморфного типа для полиморфной связки
               polymorphicType = sectionData.polymorphicType
               # И полиморфных ассоциаций.
               polymorphicAssociations = sectionData.polymorphicAssociations
               isPolyAssociationsSet = polymorphicAssociations? and
                                       !_.isEmpty polymorphicAssociations

            if sectionParents?
               # Перебираем наименования родительских связок и добавляем их в набор
               #  родительских для поля, только если наименование не совпадает с наименованием
               #  модели(обычной) или модели вьюхи по которой создана таблица данных.
               for parentName, idx in sectionParents
                  isParentNotSelfModel = parentName isnt modelName
                  isParentNotSelfView = parentName isnt modelNameView
                  isParentNotExlcluding =
                     if excludingRelations?
                        !_.includes(excludingRelations, parentName)
                     else
                        true

                  if isParentNotSelfModel and isParentNotSelfView and isParentNotExlcluding
                     if isPolyAssociationsSet
                        polyType = polymorphicAssociations[parentName]

                     fieldParents.push
                        reflection: parentName
                        polyType: polyType

            # Последним наименованием родительских связок добавим наименование секции.
            fieldParents.push
               reflection: sectionName
               polyType: polymorphicType

            # parents: fieldParents
            # polymorphicType: polymorphicType
            # polymorphicAssociations: polymorphicAssociations
            fieldParents

      ).bind(this)

      comparisonConditions = @_COMPARISON_CONDITIONS
      excludingRelations = @_getModelRelationNames()
      formattedParams = []

      for param in filterParams
         formattedParam = {}
         filterValue = param.value
         filterCondition = param.condition
         filterFieldParams = param.field
         fieldParams = _.cloneDeep(filterFieldParams.value)
         fieldAffilation = getFieldAffilation(filterFieldParams,
                                              excludingRelations)
         isNonFieldCondition = param.isNonFieldCondition

         # Удалим параметры связки из параметров полей, т.к. они могут быть
         #  громоздкими и затруднить передачу параметров на БЛ.
         delete fieldParams.reflection

         # Если задано условие диапазона, то разбиваем значение по строке на
         #  2 условия - больше и меньше.
         if @_isRangeCondition(filterCondition)
            startValue = filterValue[0]
            endValue = filterValue[1]

            if startValue?
               params =
                  fieldParams: fieldParams
                  expression: startValue
                  condition: comparisonConditions.greater_or_eq
                  affilation: fieldAffilation
                  collection: formattedParams
                  isNonFieldCondition: isNonFieldCondition

               addCondition(params)

            if endValue?
               params =
                  fieldParams: fieldParams
                  expression: endValue
                  condition: comparisonConditions.less_or_eq
                  affilation: fieldAffilation
                  collection: formattedParams
                  isNonFieldCondition: isNonFieldCondition

               addCondition(params)
         else
            params =
               fieldParams: fieldParams
               expression: filterValue
               condition: filterCondition
               affilation: fieldAffilation
               collection: formattedParams
               isNonFieldCondition: isNonFieldCondition

            addCondition(params)

      filter:
         terms: formattedParams
         template: filterTemplate

   ###*
   * Функция генерации новой строки фильтра.
   *
   * @param {Boolean} isFirstRow   - флаг первой строки фильтра.
   * @param {Number} rowKey        - ключ-идентификатор строки фильтра.
   * @param {Boolean} isCombinable - флаг комбинации данной строки со следующей.
   * @return {Object} - строка с параметрами фильтра.
   ###
   _newFilterRowParam: (isFirstRow, rowKey, isCombinable) ->
      isNeedUnionConditions = if isFirstRow then false else true
      stateFilterRowParams = @state and @state.filterRowParams

      # unless rowKey?
      #    rowKey = if stateFilterRowParams then stateFilterRowParams.length else 0

      # rowKey: rowKey
      entityParams: @props.entityParams
      isNeedUnionConditions: isNeedUnionConditions
      onChangeCombine: @_onChangeCombine
      isCombinable: isCombinable


###* Компонент: набор строк фильтра таблицы: часть компонента DataTable
*
* @props:
*     {Array<Object>} filterRowParams - массив параметров для строк фильтра. Вид:
*        {Object} entityParams           - параметры сущности (параметры полей +
*                                          параметры внешних связок)
*        {Object} reflectionRenderParams - параметры рендера связок (для полей-селекторов).
*        {Object} dataManipulationParams - параметры манипуляции данными
*                                          (для задания ограничений полей фильтра).
*        {Object} implementationStore    - хранилище реализаций.
*        {Boolean} isUseImplementation   - флаг использования хранилища реализаций.
*        {Boolean} isMergeImplementation - флаг слияния "реализуемых".
*        {Boolean} isCombinable          - флаг комбинируемого условия.
*        {Boolean} isNeedUnionConditions - флаг необходимости объединяющего условия.
*        {Function} onChangeCombine      - обработчик на изменение состояния объединения строки.
###
DataTableFilterRows = React.createClass

   # @const {String} - cтрока-префикс для ссылки на строку фильтра.
   _FILTER_ROW_REF_PREFIX: 'filterRow_'

   render: ->
      `(
         <tbody>
            {this._getFilterRows()}
         </tbody>
       )`

   ###*
   * Функция получения массива строк фильтра.
   *
   * @return {Array<React-element>} - массив строк фильтра.
   ###
   _getFilterRows: ->
      rows =
         for rowParam, idx in @props.filterRowParams
           `(<DataTableFilterRow ref={this._FILTER_ROW_REF_PREFIX + idx}
                                 key={idx}
                                 rowKey={idx}
                                 entityParams={rowParam.entityParams}
                                 reflectionRenderParams={this.props.reflectionRenderParams}
                                 dataManipulationParams={this.props.dataManipulationParams}
                                 implementationStore={this.props.implementationStore}
                                 isUseImplementation={this.props.isUseImplementation}
                                 isMergeImplementation={this.props.isMergeImplementation}
                                 isNeedUnionConditions={rowParam.isNeedUnionConditions}
                                 onChangeCombine={rowParam.onChangeCombine}
                                 isCombinable={rowParam.isCombinable} />)`

###* Компонент: строка фильтра таблицы: часть компонента DataTable
*
* @props:
*     {Number} rowKey                 - ключ строки.
*     {Object} entityParams           - параметры сущности (параметры полей +
*                                       параметры внешних связок)
*     {Object} reflectionRenderParams - хэш параметров рендера полей выборки.
*     {Object} dataMaipulationParams  - хэш параметров манипуляции данными (для
*                                       считывания ограничений полей).
*     {Object} implementationStore    - хранилище реализаций.
*     {Boolean} isUseImplementation   - флаг использования хранилища реализаций.
*     {Boolean} isMergeImplementation - флаг слияния "реализуемых" свойств.
*     {Boolean} isNeedUnionConditions - флаг необходимости наличия условий объединения.
*     {Boolean} isCombinable          - флаг, того что данная строка фильтра объединяется со следующей.
*     {Function} onChangeCombine      - обработчик изменения отметки объединения условия.
* @state:
*     {Object} selectedField       - параметры выбранного поля.
*     {Object} selectedCondition   - параметры выбранного условия.
*     {Object} availableConditions - набор доступных для выбора условий фильтрации.
*                                    Параметр зависит от типа выбранного поля.
*     {Boolean} isCombined         - флаг объединения с предыдущей строкой условия.
###
DataTableFilterRow = React.createClass

   # @const {Object} - список возможных условий соответствий разбитых по группам.
   _CONDITION_PARAMS:
      equality:
         eq: 'равно'
         not: 'не равно'
      addition:
         less: 'меньше'
         greater: 'больше'
         less_or_eq: 'меньше или равно'
         greater_or_eq: 'больше или равно'
         is_not_null: 'задано'
         is_null: 'не задано'
         between: 'между'
      special:
         in: 'входит'
         'not_in': 'не входит'
      arbitrary:
         like: 'содержит'
         not_like: 'не содержит'

   # @const {String} - наименование условия диапазона (необходимо два поля ввода).
   _RANGE_CONDITION_NAME: 'between'

   # @const [Array] - список условий без полей ввода значения.
   _NON_FIELD_CONDITIONS: [
      'is_null'
      'is_not_null'
   ]

   # @const [Array] - список условий для которых необходим сброс типа поля (для
   #                  произвольного ввода).
   _RESET_TYPE_CONDITIONS: [
      'in'
      'not_in'
   ]

   # @const {Object} - список разных типов полей.
   _FIELD_TYPES: keyMirror(
      boolean: null
      integer: null
      date: null
      string: null
   )

   # @const {Object} - параметры для селекторов объединяющих условий.
   _UNIONS_PARAMS:
      and: 'И'
      or: 'ИЛИ'

   # @const {Object} - ссылки на элементы выпадающих списков фильтра.
   _DROPDOWN_REFS:
      field: 'fieldSelector'
      condition: 'conditionSelector'
      union: 'unionSelector'
      input: 'filterInput'

   # @const {String} - заголовок для опции объединения условий.
   _COMBINE_LABEL: 'объединить'

   # @const {String} - тип для чекбокса.
   _INPUT_CHECKBOX_TYPE:'checkbox'

   # @const {String} - заполнитель для поля поиска
   _SEARCH_FIELDS_PLACEHOLDER: 'Введите название поля'

   # @const {Object} - испольлзуемые символы.
   _CHARS:
      colon: ':'
      dash: '-'
      arrowLeft: '→'

   # @const {Object} - хэш значений плейсхолдеров полей ввода для условия диапазона.
   _RANGE_PLACEHOLDERS:
      start: 'от'
      end: 'до'

   # @const {Object} - параметры кнопки удаления условия.
   _REMOVE_BUTTON_PARAMS:
      icon: 'trash-o'
      title: 'удалить условие отбора'

   # @const {String} - строковый тип поля.
   _STRING_FIELD_TYPE: 'string'

   # @const {String} - наименование поля идентификатора модели.
   _ID_FIELD_NAME: 'id'

   mixins: [HelpersMixin]

   styles:
      common:
         padding: _COMMON_PADDING
         color: _COLORS.hierarchy2
         verticalAlign: 'top'
      combinedRow:
         backgroundColor: _COLORS.hierarchy3
      unionSelectorCell:
         backgroundColor: _COLORS.hierarchy4
      combinableCell:
         borderTopStyle: 'solid'
         borderTopColor: _COLORS.hierarchy4
         borderTopWidth: 1
      inputCell:
         width: '100%'
      fieldSelectorCell:
         textAlign: 'right'
      rangeFieldsContainer:
         display: 'inline-flex'
      rangeFieldContainer:
         display: 'inline-block'
         paddingRight: 2
         width: '50%'

   getDefaultProps: ->
      isNeedUnionConditions: true
      isCombinable: false

   getInitialState: ->
      initSelectedField = @_getInitSelectedField()
      availableConditions = @_getAvailableConditions(initSelectedField)
      initSelectedCondition = @_getSelectedCondition(availableConditions)

      isCombined: false
      availableConditions: availableConditions
      selectedField: initSelectedField
      selectedCondition: initSelectedCondition

   render: ->

      `(
         <tr style={this._getRowStyle()}>
            <td style={this._getSelectorUnionCellStyle()}>
               {this._getUnionConditionsSelector()}
            </td>
            <td style={this._getSelectorCellStyle()}>
               {this._getFieldSelector()}
            </td>
            <td style={this._getCellStyle()}>
               {this._getConditionSelector()}
            </td>
            <td style={this._getInputFieldCellStyle()}>
               {this._getInputField()}
            </td>
            <td style={this._getSelectorUnionCellStyle()}>
               {this._getCombineSelector()}
            </td>
         </tr>
      )`

   ###*
   * Функция получения значения параметров строки фильтра.
   *
   * @return {Object, undefined} - параметры фильтра. Вид:
   *                    {String, undefined} union - операнд соединения с предыдущим условием.
   *                    {String} field            - наименование поля.
   *                    {String} condition        - операнд условия сравнения.
   *                    {String} value            - значение в поле ввода фильтра.
   *                    {Boolean} isCombined      - флаг соединения со следующим условием.
   ###
   getValue: ->
      refs = @refs
      unionSelector = refs.unionSelector
      fieldSelector = refs.fieldSelector
      selectedField = @state.selectedField
      isRangeCondition = @_isSelectRangeCondition()

      # Если выбрано условие диапазона - то обработаем 2 поля ввода.
      # Иначе - обработаем только одно поле ввода.
      if isRangeCondition
         filterInput1 = refs.filterInput1
         filterInput2 = refs.filterInput2
         filterInput1Value = filterInput1.getValue()
         filterInput2Value = filterInput2.getValue()
         isField1Filled = filterInput1Value? and filterInput1Value isnt ''
         isField2Filled = filterInput2Value? and filterInput2Value isnt ''

         if isField1Filled? or isField2Filled?
            filterValue = [filterInput1Value, filterInput2Value]
      else
         filterInput = refs.filterInput
         filterValue = filterInput.getValue() if filterInput?

      # Определим флаг заполненности значения строки фильтра.
      isFillFilterValue = filterValue? and filterValue isnt ''

      # Формируем хэш значения по строке только если значение условия фильтрации
      #  заполнено или если выбрано условия без необходимости заполнения поля значения.
      if isFillFilterValue or @_isSelectNonFieldCondition()
         unionCondition = unionSelector.getSelectedKey() if unionSelector?
         fieldToSend = _.cloneDeep(selectedField)
         fieldValue = selectedField.value
         reflParams = fieldValue.reflection

         if reflParms?
            reflParams.name = fieldValue.reflectionName

         # Упрощаем параметры поля (чтобы не передавалось лишнее).
         fieldToSend.value =
            name: fieldValue.name
            type: fieldValue.type
            caption: fieldValue.caption
            enumValues: fieldValue.enumValues
            reflection: reflParams

         union: unionCondition
         field: fieldToSend
         condition: @state.selectedCondition.value
         value: filterValue
         isCombined: @state.isCombined
         isNonFieldCondition: @_isSelectNonFieldCondition()

   ###*
   * Функция создания ячейки с компонентом-выпадающего списка
   *  для условий соединения условий.
   *
   * @return {React-element} - селектор полей.
   ###
   _getUnionConditionsSelector: ->
      if @props.isNeedUnionConditions
         unionParams = @_UNIONS_PARAMS
         firstKey = _.first(_.keys(unionParams))
         `(
            <DropDown ref={this._DROPDOWN_REFS.union}
                      list={unionParams}
                      initItem={{key: firstKey}}
                  />
          )`

   ###*
   * Функция создания компонента-выпадающего списка для полей.
   *
   * @return {React-element} - селектор полей.
   ###
   _getFieldSelector: ->
      entityParams = @props.entityParams

      `(
         <DropDown ref={this._DROPDOWN_REFS.fields}
                   list={entityParams.fieldParams}
                   additionalList={this._getPreparedAdditionalFields(entityParams)}
                   initItem={this.state.selectedField}
                   searchPlaceholder={this._SEARCH_FIELDS_PLACEHOLDER}
                   isComplex={true}
                   onSelect={this._onSelectField}
               />
      )`

   ###*
   * Функция создания компонента-выпадающего списка для операторов соответсвия.
   *
   * @return {React-element} - селектор операторов.
   ###
   _getConditionSelector: ->
      `(
         <DropDown ref={this._DROPDOWN_REFS.condition}
                   list={this.state.availableConditions}
                   initItem={this.state.selectedCondition}
                   onSelect={this._onSelectCondition} />
       )`

   ###*
   * Функция создания компонента-поля ввода для значения строки фильтрации.
   *
   * @return {React-element} - поле(поля) ввода значения условия.
   ###
   _getInputField: ->
      selectedField = _.cloneDeep(@state.selectedField)

      ###*
      * Функция получения поля ввода.
      *
      * @param {Number} instanceNumber - номер экземпляра.
      * @param {Object} fieldParams    - параметры поля.
      * @param {String} placeholder    - плейсхолдер поля ввода.
      * @return {React-element} - поле ввода.
      ###
      getInput = ((fieldParams, instanceNumber, placeholder) ->
         defaultRef = this._DROPDOWN_REFS.input
         inputRef = if instanceNumber?
                       defaultRef + instanceNumber
                    else
                       defaultRef
         reflectionRenderParams = @props.reflectionRenderParams
         fieldReflection = fieldParams.reflection
         fieldName = fieldParams.name
         fieldConstraints = @_getFieldConstraints()

         # Если для поля задан флаг только для чтения - сбросим его, чтобы поле
         #  было доступно для ввода.
         if fieldParams.isReadOnly
            fieldParams.isReadOnly = false

         # Если заданы ограничения для поля - производим доп. обработку параметров
         #  полей.
         if fieldConstraints?
            fieldStrongValue = fieldConstraints.strongValue
            isFieldHidden = fieldConstraints.isHidden
            isFieldReadOnly = fieldConstraints.isReadOnly
            identifyingName = fieldConstraints.identifyingName

            # Обработаем ограничения поля:
            # "Жесткое" значение поля.
            if fieldStrongValue?
               fieldParams.value = fieldStrongValue
            # Флаг скрытого поля.
            if isFieldHidden
               fieldParams.isHidden = isFieldHidden
            # Флаг поля только для чтения.
            if isFieldReadOnly
               fieldParams.isReadOnly = isFieldReadOnly
            # Свойство "идентификационного имени" поля.
            if identifyingName?
               fieldParams.identifyingName = identifyingName

         isFieldHasReflectionName = fieldReflection? and
                                    !_.isEmpty(fieldReflection) and
                                    fieldReflection.name?
         isFieldIdentifier = fieldName is @_ID_FIELD_NAME

         # Если заданы параметры рендера для полей-селекторов связок, то пробуем
         #  получить параметры по различным параметрам:
         #  1. Если здано имя связки по полю и это поле идентификатора - пробуем
         #     получить параметры связки по имени связки.
         #  2. Если параметры связки не удалось получить - пробуем получить
         #     параметры по имени поля.
         if reflectionRenderParams?
            if isFieldHasReflectionName and isFieldIdentifier
               renderParams =
                  reflectionRenderParams[fieldReflection.name]

            unless renderParams?
               renderParams =
                  reflectionRenderParams[fieldParams.name]

         `(
            <FormInput ref={inputRef}
                       field={fieldParams}
                       placeholder={placeholder}
                       implementationStore={this.props.implementationStore}
                       isUseImplementation={this.props.isUseImplementation}
                       isMergeImplementation={this.props.isMergeImplementation}
                       isNeedValidation={false}
                       reflectionRenderParams={renderParams}
                    />
         )`
      ).bind(this)

      # Если выбрано поле.
      if selectedField? and selectedField.value?

         # И если выбрано условие, для которого требуется поле ввода.
         unless @_isSelectNonFieldCondition()
            fieldParams = selectedField.value

            # Если было выбрано условие при котором должено быть сброшен тип поля.
            #  установим тип поля в строковый.
            if @_isSelectResetTypeCondition()
               fieldParams.type = @_STRING_FIELD_TYPE

            # Если было задоно условие диапазона - создаем два экземпляра поля ввода.
            if @_isSelectRangeCondition()
               placeholders = @_RANGE_PLACEHOLDERS

               `(
                  <div style={this.styles.rangeFieldsContainer}>
                     <span style={this.styles.rangeFieldContainer}>
                        {getInput(fieldParams, 1, placeholders.start)}
                     </span>
                     <span style={this.styles.rangeFieldContainer}>
                        {getInput(fieldParams, 2, placeholders.end)}
                     </span>
                  </div>
               )`
            else
               getInput(fieldParams)

   ###*
   * Функция создания компонента-флаг выбора комбинации условия с предыдущей строкой.
   *
   * @return {React-element} - флаг объединения с предыдущим условием.
   ###
   _getCombineSelector: ->
      if @props.isNeedUnionConditions
         `(
            <label>
               <input type={this._INPUT_CHECKBOX_TYPE}
                      onChange={this._onChangeCombine} />
               {this._COMBINE_LABEL}
            </label>
          )`

   ###*
   * Функция получения ограничений по полю.
   *
   * @return {Object, undefined} - параметры ограничений по полю.
   ###
   _getFieldConstraints: ->
      selectedField = @state.selectedField
      dataManipulationParams = @props.dataManipulationParams

      return unless selectedField?

      if dataManipulationParams? and !_.isEmpty dataManipulationParams
         fieldConstraints = dataManipulationParams.fieldConstraints

         if fieldConstraints? and !_.isEmpty fieldConstraints
            selectedFieldValue = selectedField.value
            selectedFieldAddition = selectedField.addition
            sectionParams =
               if selectedFieldAddition?
                  selectedFieldAddition.sectionParams

            if selectedFieldValue?
               selectedFieldName = selectedFieldValue.name
               selectedFieldParents =
                  if sectionParams? and sectionParams.name?
                     sectionParents = _.cloneDeep(sectionParams.parents)
                     parents =
                        if sectionParents? and !_.isEmpty(sectionParents)
                           sectionParents
                        else
                           []

                     parents.push sectionParams.name
                     parents

            if selectedFieldName?
               isSetParents = !_.isEmpty selectedFieldParents
               constraints = fieldConstraints.constraints

               if constraints?
                  # Перебираем все заданные ограничения и ищем ограничение, совпадающее
                  #  с проверяемым полем по наименованию полю и по цепи родителей.
                  for constraint in constraints
                     constrParents = constraint.parents
                     constrFieldName = constraint.name
                     isSetConstrParents = !!(constrParents? and constrParents.length)
                     isNameMatches = selectedFieldName is constraint.name

                     isParentsMatches =
                        if isSetParents and isSetConstrParents
                           selectedFieldParents.join() is constrParents.join()
                        else if isSetParents is isSetConstrParents
                           true
                        else
                           false

                     if isNameMatches and isParentsMatches
                        return constraint

   ###*
   * Функция получения стиля для строки фильтра
   *
   * @return {Object} - скомпанованный стиль
   ###
   _getRowStyle: ->
      isCombine = @state.isCombined or @props.isCombinable

      @computeStyles @styles.common,
                     isCombine and @styles.combinedRow

   ###*
   * Функция получения стиля для ячейки строки фильтра.
   *
   * @return {Object} - скомпанованный стиль
   ###
   _getCellStyle: ->
      if @props.isCombinable and !@state.isCombined
         @styles.combinableCell

   ###*
   * Функция получения стиля для ячейки селектора.
   *
   * @return {Object} - скомпанованный стиль
   ###
   _getSelectorCellStyle: ->
      cellStyle = @_getCellStyle()
      @computeStyles cellStyle, @styles.fieldSelectorCell

   ###*
   * Функция получения стиля для ячейки селектора элемента объединения.
   *
   * @return {Object} - скомпанованный стиль
   ###
   _getSelectorUnionCellStyle: ->
      selectorCellStyle = @_getSelectorCellStyle()
      @computeStyles selectorCellStyle,
                    !@state.isCombined and @styles.unionSelectorCell

   ###*
   * Функция получения стиля для ячейки строки ввода.
   *
   * @return {Object} - скомпанованный стиль
   ###
   _getInputFieldCellStyle: ->
      cellStyle = @_getCellStyle()
      @computeStyles cellStyle, @styles.inputCell

   ###*
   * Функция отбора возможных для выбора условий на основе выбранного поля.
   *
   * @param {Object} selectedField - параметры выбранного поля.
   * @return {Object}
   ###
   _getAvailableConditions: (selectedField) ->
      if selectedField? and selectedField.value
         selectedFieldParams = selectedField.value
         selectedType = selectedFieldParams.type
         isSelectedFieldHasEnum = @_isFieldHasEnum(selectedField)
         isSelectedFieldHasReflection = @_isFieldHasReflection(selectedField)
         fieldTypes = @_FIELD_TYPES
         conditions = @_CONDITION_PARAMS
         isBooleanType = selectedType is fieldTypes.boolean
         isDateType = selectedType is fieldTypes.date
         isStringType = selectedType is fieldTypes.string


         # В зависимости от выбранного поля считаем различные возможные операнды
         #  соответствия.
         additionParams =
            if isDateType
               conditions.addition
            else if !isSelectedFieldHasEnum and
                    !isSelectedFieldHasReflection and
                    !isBooleanType
               @mergeObjects conditions.special, conditions.addition

         @mergeObjects isStringType and !isSelectedFieldHasEnum and conditions.arbitrary,
                       conditions.equality,
                       additionParams

   ###*
   * Функция получения начального выбранного значения в селекторе полей, по которым
   *  идет выборка. Если заданы параметры полей, берет первое поле в наборе.
   *
   * @return {Object, undefined}.
   ###
   _getInitSelectedField: (entityParams) ->
      entityParams = @props.entityParams

      if entityParams? and !_.isEmpty entityParams
         fieldParams = entityParams.fieldParams

         if fieldParams?
            firstKey = Object.keys(fieldParams)[0]

            key: firstKey
            value: _.cloneDeep(fieldParams[firstKey])

   ###*
   * Функция получения начального выбранного значения в селекторе условий.
   *
   * @return {Object}.
   ###
   _getSelectedCondition: (conditions) ->
      if conditions?
         firstConditionKey = Object.keys(conditions)[0]

         value: firstConditionKey
         caption: conditions[firstConditionKey]

   ###*
   * Функция формирования подготовленных в специфическом виде параметров для
   *  дополнительных секций выпадающего списка-селектора полей. Получает
   *  поля внутренних и внешних связок и формирует массив параметров для
   *  дополнительных секций выпадающего списка-селектора полей.
   *
   * @param {Object} entityParams - параметры сущности(поля и внешние связки).
   * @return {Array, undefined} - набор дополнительных секций.
   ###
   _getPreparedAdditionalFields: (entityParams)->

      ###*
      * Функция-предикат для определения является ли поле-связка полем считывания
      *  экземпляров.
      *
      * @param {Object} fieldParams - параметры поля.
      * @return {Boolean}
      ###
      isRequestedReflection = (fieldParams) ->
         reflection = fieldParams.reflection

         if reflection? and !_.isEmpty reflection
            dictionaryParams = reflection.dictionary

            if dictionaryParams? and !_.isEmpty dictionaryParams
               requestingParams = dictionaryParams.requestingParams
               return requestingParams? and !_.isEmpty(requestingParams)

         false

      ###*
      * Функция для получения параметров текущей связки. Если заданы параметры родительской
      *  связки - получает их и добавляет параметры текущей связки.
      *
      * @param {Object} parentParams - параметры родителя.
      * @param {String} caption - выводимый заголовок секции.
      * @param {String} name - имя секции.
      * @return {Object}
      ###
      getCurrentReflectionParams = (parentParams, caption, name) ->
         if parentParams?
            dashChar = @_CHARS.dash
            arrowLeftChar = @_CHARS.arrowLeft
            parentSubcaption = parentParams.subCaption
            parentCaption = parentParams.caption

            subCaption =
               if parentSubcaption?
                  [
                     parentSubcaption
                     parentCaption
                  ].join arrowLeftChar
               else
                  parentCaption

         subCaption: subCaption
         caption: caption
         name: name

      ###*
      * Функция получения параметров внутренний связки из параметров поля.
      *
      * @param {Object} fieldParam - параметры поля.
      * @return {Object} - параметры связки.
      ###
      getReflectionRelation = (fieldParam) ->
         reflectionParams = fieldParam.reflection

         if reflectionParams? and !_.isEmpty(reflectionParams)
            instanceParams = reflectionParams.instance

            if instanceParams? and !_.isEmpty(instanceParams)
               readingParams = instanceParams.readingParams

               if readingParams? and !_.isEmpty(readingParams)
                  relation = readingParams.relation

                  if relation? and !_.isEmpty relation

                     relation: relation
                     isPolymorphic: reflectionParams.isPolymorphic
                     caption: fieldParam.caption
                     name: reflectionParams.name
                     parents: reflectionParams.parentReflections

      ###*
      * Функция добавления секции в набор дополнительных разделов. Перебирает
      *  все параметры полей и добавляет необходимые параметры в набор элементов
      *  секции.
      *
      * @param {Object} params - хэш параметров для секции. Вид:
      *        {Object} fields - набор полей секции.
      *        {String} caption - заголовок секции.
      *        {String} subCaption - подзаголовок секции (второстепенная информация).
      *        {Array} parents - набор родительских связок.
      *        {Object} entityReflection - параметры связки для модели секции.
      *        {String} name - имя секции.
      *        {String} polymorphicType - наименование модели для полиморфной связки.
      *        {Array} sections - набор секций.
      * @return
      ###
      addSectionToAdditional = (params) ->
         fields = params.fields
         caption = params.caption
         subCaption = params.subCaption
         name = params.name
         parents = params.parents
         entityReflection = params.entityReflection
         sections = params.sections
         sectionData = params.sectionData

         if fields? and !_.isEmpty fields
            sectionItems = []

            for fieldName, field of fields

               if (fieldName is @_ID_FIELD_NAME) and entityReflection?
                  dictionaryParams = entityReflection.dictionary

                  if dictionaryParams?
                     field.reflection = $.extend field.reflection,
                                                 entityReflection

               sectionItems.push field

            sections.push
               caption: caption
               subCaption: subCaption
               name: name
               items: sectionItems
               parents: parents
               sectionData: sectionData

      ###*
      * Функция проверки набора полей на наличие внутренней связки и добавления
      *  параметров этой связки в набор секций доп. элементов.
      *
      * @param {Object} fieldParams - параметры полей.
      * @param {Array} sections - набор секций.
      * @param {Object} parentEntityParams - параметры родителя.
      * @return
      ###
      addInternalReflectionsToAdditional = (fieldParams, sections, parentEntityParams) ->

         # Если параметры полей заданы.
         if fieldParams? and !_.isEmpty(fieldParams)
            for _name, fieldParam of fieldParams

               # Не обрабатываем поле - если это поле выбора связки (выбор из справочника).
               continue if isRequestedReflection(fieldParam)

               fieldRelationParams = getReflectionRelation(fieldParam)

               # Продолжим только если это поле - внутренняя связка
               if fieldRelationParams?
                  fieldRelation = fieldRelationParams.relation
                  parentReflections = fieldRelationParams.parents

                  # Перебираем все связки(для полиморфных их может быть несколько).
                  for _reflName, relationParams of fieldRelation
                     fields = relationParams.fields

                     reflectionName = fieldRelationParams.name

                     reflectionCaption =
                        relationParams.entityCaption || fieldRelationParams.caption

                     currentRelationParams =
                        getCurrentReflectionParams.call(this,
                                                        parentEntityParams,
                                                        reflectionCaption,
                                                        reflectionName)

                     sectionCaption = currentRelationParams.caption
                     sectionSubcaption = currentRelationParams.subCaption
                     sectionName = currentRelationParams.name
                     reflection = fieldParams.reflection
                     polymorphicAssociations =
                        if reflection?
                           reflection.polymorphicAssociations

                     paramsForSection =
                        fields: fields
                        caption: sectionCaption
                        subCaption: sectionSubcaption
                        name: sectionName
                        sectionData:
                           polymorphicType: relationParams.entityName
                           polymorphicAssociations: polymorphicAssociations
                        parents: _.cloneDeep(parentReflections)
                        sections: sections

                     # Добавим секцию с доп. элементами полей внутренней связки.
                     addSectionToAdditional.call(this, paramsForSection)

                     # Получим параметры внешних связок и отправим на добавление.
                     externalEntities = relationParams.externalEntities

                     parentForExternal =
                        caption: sectionCaption
                        subCaption: sectionSubcaption
                        name: sectionName

                     addExternalReflectionsToAdditional.call(this,
                                                             externalEntities,
                                                             sections,
                                                             parentForExternal)

      ###*
      * Функция добавления параметров внешних связок сущности в набор секций доп.
      *  элементов. Может вызываться рекурсивно.
      *
      * @param {Object} externalEntities - набор внешних связок.
      * @param {Array} sections - набор секций доп. элементов.
      * @param {Object} parentEntityParams - параметры родителя.
      * @return
      ###
      addExternalReflectionsToAdditional = (externalEntities, sections, parentEntityParams) ->

         # Если внешние сущности заданы.
         if externalEntities? and !_.isEmpty(externalEntities)

            for _name, entityParams of externalEntities
               fields = entityParams.fields
               entityCaption = entityParams.entityCaption
               entityName = entityParams.reflectionName
               entityReflection = entityParams.reflection
               parentReflections = entityParams.parentReflections
               polymorphicAssociations = entityParams.polymorphicAssociations
               extExternalEntities = entityParams.externalEntities

               currentRelationParams =
                  getCurrentReflectionParams.call(this,
                                             parentEntityParams,
                                             entityCaption,
                                             entityName)
               sectionCaption = currentRelationParams.caption
               sectionSubcaption = currentRelationParams.subCaption
               sectionName = currentRelationParams.name

               paramsForSection =
                  fields: fields
                  caption: sectionCaption
                  subCaption: sectionSubcaption
                  entityReflection: entityReflection
                  sectionData:
                     polymorphicAssociations: polymorphicAssociations
                  name: sectionName
                  parents: parentReflections
                  sections: sections

               # Добавим доп. элементы по полям внутренней связки.
               addSectionToAdditional.call(this, paramsForSection)

               parentForReflections =
                  caption: sectionCaption
                  subCaption: sectionSubcaption
                  name: sectionName

               # Добавляем секции по параметрам внутренних связок.
               addInternalReflectionsToAdditional.call(this,
                                                       fields,
                                                       sections,
                                                       parentForReflections)

               # Добавляем секции по параметрам внешних связок.
               addExternalReflectionsToAdditional.call(this,
                                                       extExternalEntities,
                                                       sections,
                                                       parentForReflections)

      if entityParams?
         externalEntities = entityParams.externalEntities
         fieldParams = entityParams.fieldParams
         additionalSections = []

         addInternalReflectionsToAdditional.call(this,
                                                 fieldParams,
                                                 additionalSections)

         addExternalReflectionsToAdditional.call(this,
                                                 externalEntities,
                                                 additionalSections)

         # Вернем массив секций с доп. элементами, если массив не пустой.
         additionalSections if additionalSections.length

   ###*
   * Функция-предикат для определения является ли поле, переданное через параметры
   *  того же типа, что и текущее выбранное.
   *
   * @param {Object} field - поле для проверки совпадения типа с текущим.
   * @return {Boolean}
   ###
   _isFieldHasKindTypeAsCurrent: (field) ->
      selectedField = @state.selectedField

      if field? and field.value? and selectedField? and selectedField.value?
         isFieldTypesEquals = field.value.type is selectedField.value.type
         isFieldHasEnum = @_isFieldHasEnum field
         isFieldHasReflection = @_isFieldHasReflection field
         isSelectedFieldHasEnum = @_isFieldHasEnum selectedField
         isSelectedFieldHasReflection = @_isFieldHasReflection selectedField

         return isFieldTypesEquals and
                (isFieldHasEnum is isSelectedFieldHasEnum) and
                (isFieldHasReflection is isSelectedFieldHasReflection)
      else
         false

   ###*
   * Функция-предикат для определения того, что поле содержит параметры
   *  считывания связки (поле селектора из справочника).
   *
   * @param {Object} field - параметры поля.
   * @return {Boolean}
   ###
   _isFieldHasReflection: (field) ->
      if field?
         fieldParams = field.value
         fieldReflection = fieldParams.reflection

         if fieldReflection? and !_.isEmpty(fieldReflection)
            dictionaryParams = fieldReflection.dictionary

            return dictionaryParams? and !_.isEmpty dictionaryParams

      false

   ###*
   * Функция-предикат для определения того,
   *  что выбранное поле содержит перечисление.
   *
   * @param {Object} field - параметры поля.
   * @return {Boolean}
   ###
   _isFieldHasEnum: (field) ->
      if field?
         fieldParams = field.value
         fieldEnum = fieldParams.enumValues

         return fieldEnum? and !_.isEmpty(fieldEnum)

      false

   ###*
   * Функция-предикат для определения того,
   *  что выбранное условие не требует поля ввода.
   *
   * @return {Boolean}
   ###
   _isSelectNonFieldCondition: ->
      selectedCondition = @state.selectedCondition

      if selectedCondition?
         selectedCondition.value in @_NON_FIELD_CONDITIONS
      else
         false

   ###*
   * Функция-предикат для определения того,
   *  что выбранное условие не требует сброса типа поля.
   *
   * @return {Boolean}
   ###
   _isSelectResetTypeCondition: ->
      selectedCondition = @state.selectedCondition

      if selectedCondition?
         selectedCondition.value in @_RESET_TYPE_CONDITIONS
      else
         false

   ###*
   * Функция-предикат для определения выбрано ли условие диапазона - необходимо
   *  два поля ввода.
   *
   * @return {Boolean}
   ###
   _isSelectRangeCondition: ->
      selectedCondition = @state.selectedCondition

      if selectedCondition?
         selectedCondition.value is @_RANGE_CONDITION_NAME
      else
         false

   ###*
   * Обработчик выбора значения из списка полей.
   *
   * @param {Object} value - выбранное значение (хэш параметров поля).
   * @return
   ###
   _onSelectField: (field) ->
      fieldAddition = field.addition
      affilationParams = fieldAddition.sectionParams if fieldAddition?

      # Если для поля заданы параметры связки - добавим в параметры связки поля
      #  наименование родительской связки.
      if affilationParams?
         affilationName = affilationParams.name

         if affilationName?
            field.value.reflection =
               _.merge({}, field.value.reflection, {name: affilationName})

      newStateObject =
         selectedField: _.cloneDeep(field)

      # Если тип нового выбранного поля отличается от типа текущего выбранного
      #  поля - зададим новые параметры условий фильтрации.
      unless @_isFieldHasKindTypeAsCurrent(field)
         availableConditions = @_getAvailableConditions(field)

         newStateObject.availableConditions = availableConditions
         newStateObject.selectedCondition =
            @_getSelectedCondition(availableConditions)

      @setState newStateObject

   ###*
   * Обработчик выбора значения из списка условий.
   *
   * @param {Object} condition - выбранное значение.
   * @return
   ###
   _onSelectCondition: (condition) ->
      @setState selectedCondition: condition

   ###*
   * Обработчик изменения значения выбранности флага комбинирования с предыдущим
   *  условием.
   *
   * @param {Object} event - объект события.
   * @return
   ###
   _onChangeCombine: (event) ->
      isChecked = event.target.checked

      onChangeCombineHandler = @props.onChangeCombine
      if onChangeCombineHandler
         onChangeCombineHandler @props.rowKey, isChecked

      @setState isCombined: isChecked

###* Компонент: панель экспорта данных таблицы: часть компонента DataTable.
* @props
*     {React-element} target  - целевой узел к которому будет привязана панель
*                               настроек.
*     {Boolean} isRequested   - флаг запрошенности экспорта.
*     {Function} onHide       - обработчик, вызываемые по закрытию области настроек.
*     {Function} onExport     - обработчик на запуск экспорта файла.
* @state
*     {String} selectedFormat          - выбранный формат экспорта.
*     {Number} recordsOnFile           - кол-во записей на один файл.
*     {Boolean} isLocalizeCaptions     - флаг локализации заголовкой полей
*                                        экспортируемых записей.
*     {Boolean} isUseAppliedSerializer - флаг использования прикладного
*                                        серилизатора экспортируемых записей
*     {React-element} loaderTarget     - элемент области-цель для загрузчика.
###
DataTableExport = React.createClass

   # @const {Object} - параметры для произвольной области.
   _AREA_PARAMS:
      animation: 'fade'
      layoutAnchor: 'parent'
      isAdaptive: true
      isHasCloseButton: true
      isHasBorder: false
      isHasShadow: true
      isTriggerOnSameTarget: false
      position:
         vertical:
            top: 'bottom'
         horizontal:
            right: 'right'
      captionParams:
         text: 'Выгрузка данных'

   # @const {Object} - используемые ссылки
   _REFS: keyMirror(
      container: null
   )

   # @const {Object} - параметры кнопки отправки запроса на проведение экспорта данных.
   _SUBMIT_EXPORT_BUTTON_PARAMS:
      caption: 'Экспорт'
      title: 'Произвести экспорт данных'
      icon: 'upload'

   # @const {Array<Object>} - параметры форматов выгрузки.
   _FORMATS: [
      {
         format: 'xlsx'
         caption: 'Формат Excel 2007'
      },{
         format: 'csv'
         caption: 'Текстовый с разделителями'
      }
   ]

   # @const {Object} - используемые символы.
   _CHARS:
      empty: ''
      space: ' '
      brStart: '('
      brEnd: ')'

   # @const {Object} - параметры радио-кнопки.
   _RADIO_INPUT_PARAMS:
      type: 'radio'
      name: 'format'

   # @const {Object} - параметры поля ввода кол-ва записей на файл.
   _FILE_RECORDS_COUNT:
      caption: ' записей на файл'
      captionPosition: 'right'
      value: 10000
      type: 'number'
      title: 'Количество записей на файл'

   # @const {Object} - параметры поля-флага применения локализации к заголовкам.
   _LOCALIZE_CAPTIONS_CHECKBOX:
      caption: 'Локализовывать наименования полей'
      captionPosition: 'right'
      type: 'boolean'
      title: 'Выполнять перевод наименований полей'
      isNeedClearButton: false

   # @const {Object} - параметры поля-флага использования прикладного серилизатора.
   _APPLIED_SERIALIZER_CHECKBOX:
      caption: 'Производить сбор и обработку данных'
      captionPosition: 'right'
      type: 'boolean'
      title: 'Собирать каждой записи связанные данные, производить доп. обработку записей'
      isNeedClearButton: false

   # @const {String} - заголовок области выбора формата.
   _FORMAT_LEGEND: 'Формат'

   # @const {Object} - параметры пояснительного текста для индикатора загрузки.
   _LOADER_PARAMS:
      text: 'Идет формирование файлов экспорта...'
      title: 'Идет формирование файлов экспорта...'
      textSecondary: ['Процедура может занимать продолжительное время.'
                      'Продолжительность зависит от объема выборки.'].join "\n"

   # @const {String} - описание опции выгрузки связок.
   _APPLIED_SERIALIZER_INSCRIPTION: [
      'Использование опции сбора и обработки данных позволит дополнительно выгружать '
      'связанные записи а также дополнительно обрабатывать значения записи. '
      'Данная операция требует значительного времени. '
      'Не рекоммендуется использовать опцию для экспорта больших объемов данных.'
   ].join ''


   styles:
      container:
         padding: _COMMON_PADDING
      formatListContainer:
         padding: _COMMON_PADDING
         marginBottom: _COMMON_PADDING
         borderRadius: _COMMON_BORDER_RADIUS
         borderColor: _COLORS.hierarchy4
      formatList:
         listStyle: 'none'
         color: _COLORS.hierarchy2
         fontSize: 14
         padding: 0
         margin: 0
      exportButtonContainer:
         marginTop: _COMMON_PADDING
      inputCaption:
         fontSize: 12
         color: _COLORS.hierarchy2
         padding: 4
      appliedSerializerInscription:
         fontSize: 11
         color: _COLORS.exclamation
         maxWidth: 290
         marginTop: -8
         marginBottom: 10
         paddingRight: 10
         paddingLeft: 10

   getInitialState: ->
      selectedFormat: _.head(@_FORMATS).format
      recordsOnFile: @_FILE_RECORDS_COUNT.value
      isLocalizeCaptions: true
      isUseAppliedSerializer: false

   render: ->
      `(
         <ArbitraryArea {...this._AREA_PARAMS}
                        target={this.props.target}
                        content={this._getContent()}
                        onHide={this.props.onHide}
                     />
       )`

   componentDidMount: ->
      @setState loaderTarget: @refs[@_REFS.container]

   ###*
   * Функция формирования содержимого области экспорта данных.
   *
   * @return {React-element}
   ###
   _getContent: ->
      formatElements =
         @_FORMATS.map ((formatParams, idx) ->
            formatName = formatParams.format
            chars = @_CHARS

            formatCaption =
               [
                  formatParams.caption
                  chars.space
                  chars.brStart
                  formatName
                  chars.brEnd
               ].join chars.empty

            isSelected = @state.selectedFormat is formatName

            `(
               <li key={idx}>
                  <input value={formatName}
                         checked={isSelected}
                         onChange={this._onChangeFormatSelector}
                         {...this._RADIO_INPUT_PARAMS}
                       />
                  <span>{formatCaption}</span>
               </li>
             )`
         ).bind(this)

      styleAdditionForInput = caption: @styles.inputCaption

      `(
         <div style={this.styles.container}
              ref={this._REFS.container} >
            <fieldset style={this.styles.formatListContainer}>
               <legend>{this._FORMAT_LEGEND}</legend>
               <ul style={this.styles.formatList}>
                   {formatElements}
               </ul>
            </fieldset>
            <Input {...this._FILE_RECORDS_COUNT}
                   value={this.state.recordsOnFile}
                   styleAddition={styleAdditionForInput}
                   onChange={this._onChangeFileRecordsCount}
                />
            <div>
               <Input {...this._LOCALIZE_CAPTIONS_CHECKBOX}
                      value={this.state.isLocalizeCaptions}
                      styleAddition={styleAdditionForInput}
                      onChange={this._onChangeLocalizeCaptions}
                   />
            </div>
            <div>
               <Input {...this._APPLIED_SERIALIZER_CHECKBOX}
                      value={this.state.isUseAppliedSerializer}
                      styleAddition={styleAdditionForInput}
                      onChange={this._onChangeAppliedSerializer}
                   />
               {this._getAppliedSerializerInscription()}
            </div>
            <div style={this.styles.exportButtonContainer}>
               <Button {...this._SUBMIT_EXPORT_BUTTON_PARAMS}
                       onClick={this._onClickExport}
                   />
            </div>
            <AjaxLoader target={this.state.loaderTarget}
                        isShown={this.props.isRequested}
                        {...this._LOADER_PARAMS}
                     />
         </div>
       )`

   ###*
   * Функция формирования контейнера с пояснением к флагу использования
   *  прикладного серилизатора.
   *
   * @return
   ###
   _getAppliedSerializerInscription: ->
      if @state.isUseAppliedSerializer
         `(
            <div style={this.styles.appliedSerializerInscription}>
                 {this._APPLIED_SERIALIZER_INSCRIPTION}
            </div>
          )`

   ###*
   * Обработчик клика по кнопке экспорта данных.
   *
   * @return
   ###
   _onClickExport: ->
      exportParams =
         format: @state.selectedFormat
         recordsOnFile: @state.recordsOnFile
         isLocalizeCaptions: @state.isLocalizeCaptions
         isUseAppliedSerializer: @state.isUseAppliedSerializer

      @props.onExport(exportParams)

   ###*
   * Обработчик события изменения значения радиокнопки выбора формата.
   *
   * @param {Object} event - объект события.
   * @return
   ###
   _onChangeFormatSelector: (event) ->
      target = event.target
      @setState selectedFormat: target.value if target?

   ###*
   * Обработчик события изменения значения в поле ввода кол-ва записей на файл.
   *
   * @param {Number} value - кол-во записей на странице.
   * @return
   ###
   _onChangeFileRecordsCount: (value) ->
      @setState recordsOnFile: value

   ###*
   * Обработчик события изменения значения в поля-флага локализации заголовков.
   *
   * @param {Boolean} value - значение флага.
   * @return
   ###
   _onChangeLocalizeCaptions: (value) ->
      @setState isLocalizeCaptions: value

   ###*
   * Обработчик события изменения значения в поля-флага использования прикладного
   *  серилизатора.
   *
   * @param {Boolean} value - значение флага.
   * @return
   ###
   _onChangeAppliedSerializer: (value) ->
      @setState isUseAppliedSerializer: value


###* Компонент: панель настроек таблицы: часть компонента DataTable.
* @props
*     {React-element} target  - целевой узел к которому будет привязана панель
*                               настроек.
*   {Object} userFilterParams - параметры пользовательских фильтров.
*     {Object} userFilters    - набор пользовательских фильтров.
*     {Object} fluxParams     - параметры flux-инфраструктуры.
*     {Function} onHide       - обработчик, вызываемые по закрытию области настроек.
###
DataTableSettings = React.createClass

   # @const {Object} - шаблонные параметры для вкладок настроек.
   _TAB_SCAFFOLD:
      main:
         name: 'main'
         title: 'основные параметры таблицы'
         caption: 'Параметры'
         icon: 'table'
      filters:
         name: 'filters'
         title: 'настройка пользовательских фильтров'
         caption: 'Фильтры'
         icon: 'filter'

   # @const {Object} - параметры для произвольной области.
   _AREA_PARAMS:
      animation: 'slideLeft'
      layoutAnchor: 'parent'
      isAdaptive: true
      isHasCloseButton: true
      isCloseButtonOnArea: true
      isHasShadow: false
      isTriggerOnSameTarget: false
      position:
         vertical:
            top: 'top'
         horizontal:
            right: 'right'
      dockModeParams:
         position: 'right'

   styles:
      tabContainer:
         width: 500

   getInitialState: ->
      isAreaOpen: false

   componentWillReceiveProps: (nextProps) ->
      nextTarget = nextProps.target

      if nextTarget? and !_.isEmpty nextTarget
         @setState isAreaOpen: true

   render: ->
      `(
          <ArbitraryArea {...this._AREA_PARAMS}
                         target={this.props.target}
                         content={this._getContent()}
                         onShown={this._onAreaOpen}
                         onHide={this._onAreaHide}
                      />
       )`

   comonentWillUnmount: ->
      fluxParams = @props.fluxParams

      if fluxParams?
         store = fluxParams.store

         if store?
            store.removeChangeListener @_onChange

   ###*
   * Функция получения содержимого области настроек таблицы.
   *
   * @return {React-element}
   ###
   _getContent: ->
      if @state.isAreaOpen

         tabScaffold = @_TAB_SCAFFOLD
         mainTab = tabScaffold.main
         filtersTab = tabScaffold.filters
         mainTab.content = @_getMainTabContent()
         filtersTab.content = @_getFiltersTabContent()
         tabCollection = [
            mainTab
            filtersTab
         ]

         `(
             <Taber tabCollection={tabCollection}
                    activeIndex={1}
                    onClickTab={this._onClickTab}
                    styleAddition={{common: this.styles.tabContainer}}
                  />
          )`

   ###*
   * Функция получения содержимого вкладки основных настроек таблицы.
   *
   * @return {React-element}
   ###
   _getMainTabContent: ->
      `(
          <div>Параметры</div>
       )`

   ###*
   * Функция получения содержимого вкладки настройки пользовательских фильтров
   *  таблицы.
   *
   * @return {React-element}
   ###
   _getFiltersTabContent: ->
      userFilterParams = @props.userFilterParams
      dataTableParams = userFilterParams.dataTableParams
      filedConstraints = userFilterParams.fieldConstraints
      fluxParams = @props.fluxParams
      fluxParamsUF = fluxParams.userFilters if fluxParams?

      manipulationParams =
         edit:
            fieldConstraints:
               constraints: filedConstraints

      `(
          <DataTable fluxParams={fluxParamsUF}
                     initData={this.props.userFilters}
                     modelParams={
                        {
                           name: userFilterParams.modelName
                        }
                     }
                     isFitToContainer={true}
                     isSearchDoOnClient={true}
                     enableObjectCard={false}
                     enableCreate={false}
                     enableStatusBar={false}
                     enableFilter={false}
                     enablePerPageSelector={false}
                     enableRowSelect={false}
                     columnRenderParams={dataTableParams.columnRenderParams}
                     dataManipulationParams={manipulationParams}
                  />
       )`

   ###*
   * Обработчик на скрытие области.
   *
   * @return
   ###
   _onAreaHide: ->
      onHideHandler = @props.onHide
      onHideHandler() if onHideHandler

      @setState isAreaOpen: false

   ###*
   * Обработчик клика на вкладку.
   *
   * @param {Number} index - индекс выбранной вкладки.
   * @param {Object} tab  - параметры вкладки.
   * @return
   ###
   _onClickTab: (item, tab)->
      tabName = tab.name

   ###*
   * Обработчик на изменение состояния хранилища
   *
   * @return
   ###
   _onChange: ->
      fluxParams = @props.fluxParams
      storeLastInteraction = fluxParams.store.getLastInteraction()
      initResponse = fluxParams.init? and fluxParams.init.responseType
      updateResponse = fluxParams.update? and fluxParams.update.responseType
      deleteResponse = fluxParams.delete? and fluxParams.delete.responseType

      switch storeLastInteraction
         # ответ инициализационного запроса.
         when initResponse
            @_getResponseInit()
         # ответ запроса на обновление записи.
         when updateResponse
            @_getResponseUpdate()
         # ответ запроса на удаление записи.
         when deleteResponse
            @_getResponseDelete()

###* Компонент: статусная панель (подвал) таблицы: часть компонента DataTable
*
* @props:
*     {Function} onPageSelect   - обработчик выбора страницы в постраничной навигации.
*     {String} tableViewType    - тип таблицы. (для различного отображения статискики записей).
*     {Object} paginateParams   - хэш с параметрами постраничного вывода. Вид:
*           {Number} totalPages       - общее кол-во страниц.
*           {Object} entriesStatistic - параметры статистики по возвращенным записям. Вид:
*              {Number} start - с какой.
*              {Number} end   - по какую.
*              {Number} total - сколько всего.
*     {Number} activePage       - текущая активная страница в постраничной навигации.
*     {Boolean} enableLazyLoad  - флаг загрузки записей по запросу (селектор страниц не будет выведен).
*     {Boolean} isPageSelectorInLinkMode - флаг вывода селекторов страниц в виде кнопок-ссылок.
###
DataTableStatusBar = React.createClass
   # @const {Object} - шаблоны для вывода статистики по записям
   _ENTRIES_STATISTIC_TEMPLATES:
      flat: "Показано с {0} по {1}. Всего {2} записи(ей)"
      tree: "Показано корневых элементов: с {0} по {1} \n Всего {2} корневых элементов(а). {3} элементов на странице."
      hierarchy: "Элементов на текущем уровне: {0}.\nВсего элементов на странице {1}. \nВсего корневых элементов: {2}. "

   # @const {String} - ключ для доступа к общему кол-ву узлов в иерархически
   #                   упорядоченных наборах.
   _CHILDS_COUNT_KEY: 'childs_count'

   # @const {String} - символ для обозначения отсутствия значения.
   _EMPTY_CHAR: '-'

   # @const {Object} - ключи параметров постраничного вывода.
   _PAGINATE_PARAM_KEYS: keyMirror(
      entriesStatistic: null
      totalPages: null
   )

   styles:
      common:
         width: '100%'
         marginTop: _COMMON_PADDING
      pageNavagationCell:
         width: '80%'
         textAlign: 'left'
      entriesStatisticCell:
         width: '20%'
         textAlign: 'right'
         whiteSpace: 'nowrap'
         fontSize: 12
         color: _COLORS.hierarchy3
      entriesStatisticContainer:
         whiteSpace: 'pre'

   render: ->

      `(
         <table style={this.styles.common}>
            <tbody>
               {this._getStatusBarContent()}
            </tbody>
         </table>
      )`

   ###*
   * Функция получения содержимого статусной строки таблицы. Возвращает содержимое,
   *  если заданы параметры постраничного вывода.
   *
   * @return {React-element, undefined} - содержимое
   ###
   _getStatusBarContent: ->
      if @_isHasPaginateParams()
         `(
            <tr>
               <td style={this.styles.pageNavagationCell}>
                  <PageSelector pagesCount={this._getTotalPages()}
                                isInLinkMode={this.props.isPageSelectorInLinkMode}
                                onPageSelect={this.props.onPageSelect}
                                selectedPage={this.props.activePage} />
               </td>
               <td></td>
               <td style={this.styles.entriesStatisticCell}>
                  {this._getStatisticObject()}
               </td>
            </tr>
         )`

   ###*
   * Функция получения объекта со статистикой по отображаемым записям - с какой,
   *  по какую, сколько всего.
   *
   * @return {React-element} - объект со статистикой.
   ###
   _getStatisticObject: ->
      entriesStat = @props.paginateParams.entriesStatistic
      entriesStart = entriesStat.start
      entriesEnd = entriesStat.end
      entriesTotal = entriesStat.total
      entriesTemplates = @_ENTRIES_STATISTIC_TEMPLATES
      childsCountKey =  @_CHILDS_COUNT_KEY

      entriesContent =
         if @_isHierarchicallyViewTable()
            childsPerPageCount = if entriesStat.hasOwnProperty childsCountKey
                                    entriesStat[childsCountKey]
                                 else
                                    @_EMPTY_CHAR
            if @_isTree()
               format(entriesTemplates.tree,
                      [entriesStart, entriesEnd, entriesTotal, childsPerPageCount])
            else
               elementsCount = entriesEnd - (entriesStart - 1)

               format(entriesTemplates.hierarchy,
                     [elementsCount, childsPerPageCount, entriesTotal])
         else
            format(entriesTemplates.flat,
                   [entriesStart, entriesEnd, entriesTotal])

      if entriesTotal > 0
         `(
            <span style={this.styles.entriesStatisticContainer}>
               {entriesContent}
            </span>
          )`

   ###*
   * Функция получения общего кол-ва страниц.
   *
   * @return {Number} - общее кол-во страниц.
   ###
   _getTotalPages: ->
      @props.paginateParams.totalPages

   ###*
   * Функция-предикат для определения заданы ли параметры постраничного вывода.
   *
   * @return {Boolean} - флаг корректности параметров постраничного вывода.
   ###
   _isHasPaginateParams: ->
      paginateParams = @props.paginateParams
      isCorrectObject = paginateParams? and !_.isEmpty paginateParams

      if isCorrectObject
         isHasAllKeys = true
         paramKeys = @_PAGINATE_PARAM_KEYS

         for keyName of paramKeys
            unless paginateParams.hasOwnProperty keyName
               isHasAllKeys = false
               break

      isCorrectObject and isHasAllKeys

   ###*
   * Функция-предикат для определения является ли таблица иерархическим представлением.
   *
   * @return {Boolean}
   ###
   _isHierarchicallyViewTable: ->
      viewTypes = @props.tableViewTypes
      @props.tableViewType in [viewTypes.hierarchy, viewTypes.tree]

   ###*
   * Функция-предикат для определения является ли таблица иерархическим представлением
   *  в виде дерева.
   *
   * @return {Boolean}
   ###
   _isTree: ->
      if @_isHierarchicallyViewTable()
         @props.tableViewType is @props.tableViewTypes.tree
      else
         false


###* Компонент: иерархическое представление записей: часть компонента DataTable
*
* @props:
*     {Array<Object>} rowsData   - Набор данных строк. Вид члена массива:
*                                {Srting, Number} key  - ключ строки
*                                {Object} fields - хэш с набором данных полей. Вид:
*                                      {Object} [fieldName]: - хэш данных по полю:
*                                            {String} caption: - заголовок поля,
*                                            {String} type: - тип поля,
*                                            {String, Number, Object...}, value: - значения поля.
*                                {Array} childs - дочерние записи (формат дочерних записей,
*                                                 аналогичен корневым записям).
*     {String} type - тип иерархического представления
*     {Array} selectedNodePath  - массив-путь до текущего активированного узла.
*     {Object} mainDataParams  - параметры для формирования строки отображения основных данных
*     {Object} secondaryDataParams - параметры для формирования строки второстепенной информации.
*     {Object} titleDataParams - параметры для формирования строки всплывающей подсказки.
*     {Object} styleForAdditionCell - стиль для доп. ячейки, содержимое, которой отрисовывается
*                                     функцией onRenderNodeAddition.
*     {Function} onRenderNode - функция отрисовки отображаемого содержимого узла.
*     {Function} onRenderNodeAddition - функция отрисовки отображаемого доп. содержимого узла
*                                       (справа от основного содержимого).
*     {Number} activePage  - текущая активная страница. (параметр нужен для сброса текущего
*                            пути иерархии при переходе на другую страницу).
*     {String} matchExpression - поисковая подстрока.
*     {Object} markedNodes - хэш с параметрами отмеченных строк.
*     {Object} styleAddtion - доп. стили (использются не все).
*     {Boolean} isAllMarked - флаг отметки выбранными всех узлов.
*     {Boolean} isFilterApply - флаг примененного фильтра.
*     {Boolean} enableEdit:         - флаг разрешения обновления узла.
*     {Boolean} enableDelete:       - флаг разрешения удаления узла.
*     {Boolean} enableSelect - флаг возможности выбора конечных узлов. (по-умолчанию =false)
*     {Boolean} enableNodeOptions - флаг возможности вывода опций узла. (по-умолчанию =true)
*     {Boolean} enableViewChildsCounter - флаг возможности отображения счетчика дочерних узлов.
*                                         (по-умолчанию =false)
*     {Boolean} enableViewKey - флаг возможности отображения ключа узла. (по-умолчанию =false)
*     {Boolean} enableViewServiceDate - флаг возможности отображения дат создания и обновления записи.
*                                       (по-умолчанию =false)
*     {Boolean} enableLeafActivateMode           - флаг разрешения использования режима выбора только
*                                                  листовых узлов. В таком режиме при клике на не листовой узел
*                                                  происходит разворачивание/сворачивание или вход в
*                                                  содержимое узла, при клике на листовой узел происходит
*                                                  активация как обычно.
*                                                  (по-умолчанию =false)
*   {Boolean} enableSpecialActivateForInnerNodes - режим спец. активации внутренних узлов.
*                                                  (по-умолчанию =false)
*     {Boolean} enableCompetitiveRootSelectMode  - флаг разрешения выбора только одного корневого узла
*                                                  (у узла нет родительских). То есть при выборе определенного
*                                                  корневого узла все предыдущие отметки о выбранности других
*                                                  узлов сбрасываются. Данный режим корректно работает
*                                                  при одиночной вложенности, при более глубокой вложенности
*                                                  будет снимать все ранее выбранные узлы на уровнях ниже первого.
*                                                  (по-умолчанию = false).
*     {Boolean} enableSelectChildsOnSelectParent - флаг разрешения отметки всех дочерних узлов
*                                                  при отметке родительского. (по-умолчанию =false)
*     {Boolean} enableSelectParentOnSelectChild  - флаг разрешения отметки родительского узла
*                                                  при отметке любого дочернего. (по-умолчанию =false)
*     {Boolean} enableSelectRootOnActivateChild - флаг выбора корневого элемента при активации дочернего узла
*                                    (клик на узел). Параметр актуален для иерархического представления
*                                    данных и возвращает корневую запись при клике на дочернюю.
*                                    (по-умолчанию =false).
*     {Boolean} enableSelectParents - флаг возможности выбора родительских узлов. (по-умолчанию =false)
*     {Object} customNodeOptions - хэш параметров произвольных опций над узлом.
*     {Function} onNodeSelect    - обработчик отметки узла.
*     {Function} onClickNode     - обработчик клика по узлу.
*     {Function} onClickNodeOption - обработчик клика по опции узла.
*     {Function} onHierarchyNavigate - обработчик перемещения по иерархии (возвращает кол-во записей
*                                      на текущем уровне).
* @state
*     {Object} nodeStates  - хэш для хранения состояний узлов (развернут/свернут).
*     {Array} hierarchyPath - массив ключей записей, обозначающих текущий путь иерархии.
###
DataTableHierarchyView = React.createClass
   # @const {String} - префикс для формирования ссылки на узел
   _NODE_REF_PREFIX: 'node'

   # @const {Object} - хэш возможных видов иерархического представления.
   _HIERARCHY_VIEW_TYPES: keyMirror(
      hierarchy: null,
      tree: null
   )

   # @const {Object} - хэш параметров кнопок панели инструментов.
   _TOOLBAR_BUTTON_PARAMS:
      toUp:
         title: 'На уровень выше'
         icon: 'arrow-up'
      toRoot:
         title: 'Выйти в корень'
         icon: 'home'

   # @const {String} - ключ для доступа к дочерним записям.
   _CHILDS_KEY: 'childs'

   # @const {Object} - используемые символы.
   _CHARS:
      underscore: '_'
      dash: '-'

   mixins: [HelpersMixin]

   styles:
      common:
         paddingTop: _COMMON_PADDING
         paddingBottom: _COMMON_PADDING
      toolbar:
         verticalAlign: 'middle'
         minHeight: 25
         height: 25
         tableLayout: 'fixed'
         width: '100%'
      toolbarNavButtonCell:
         width: 25
      toolbarBreadNavigatorCell:
         whiteSpace: 'nowrap'
         overflow: 'auto'

   getDefaultProps: ->
      type: 'hierarchy'
      enableSelect: false
      enableViewChildsCounter: false
      enableNodeOptions: true
      enableViewKey: false
      enableViewServiceDate: false
      enableLeafActivateMode: false
      enableSpecialActivateForInnerNodes: false
      enableSelectParents: false
      enableSelectRootOnActivateChild: false
      isFilterApply: false

   getInitialState: ->
      nodeStates: {}
      hierarchyPath: []
      currentHierarchyParent: null

   render: ->
      `(
         <div style={this._getComputedStyle()}>
            {this._getHierarchyToolbar()}
            {this._getNodes(this.props.rowsData, 0, [])}
         </div>
       )`

   componentWillReceiveProps: (nextProps) ->
      isFilterApplyCurrent = @props.isFilterApply
      isFilterApplyNext = nextProps.isFilterApply

      # Если был применен фильтр и состояние отличается от предыдущего, то
      #  установим состояние развернутости для всех текущих узлов.
      if isFilterApplyNext and (isFilterApplyCurrent isnt isFilterApplyNext)
         @_setExpandAllCurrentNodes()

      # Если активная страница поменялась и это обычное иерархическое представление
      #  - сбросим путь иерархии.
      if nextProps.activePage isnt @props.activePage and !@_isTree()
         @setState hierarchyPath: []
   ###*
   * Функция получения панели действий над иерархией.
   *
   * @return {React-element} - панель действий.
   ###
   _getHierarchyToolbar: ->
      buttonParams = @_TOOLBAR_BUTTON_PARAMS

      unless @props.isFilterApply
         if @_isTree()
         else
            hierarchyPath = @state.hierarchyPath
            if hierarchyPath? and hierarchyPath.length
               `(
                  <table style={this.styles.toolbar}>
                     <tbody>
                        <tr>
                           <td style={this.styles.toolbarNavButtonCell}>
                              <Button title={buttonParams.toUp.title}
                                      icon={buttonParams.toUp.icon}
                                      isLink={true}
                                      isWithoutPadding={true}
                                      onClick={this._onClickLevelUp} />
                           </td>
                           <td style={this.styles.toolbarNavButtonCell}>
                              <Button title={buttonParams.toRoot.title}
                                      icon={buttonParams.toRoot.icon}
                                      isLink={true}
                                      isWithoutPadding={true}
                                      onClick={this._onClickToRoot} />
                           </td>
                           <td style={this.styles.toolbarBreadNavigatorCell}>
                              <BreadNavigator items={this.state.hierarchyPath}
                                              onClickItem={this._onClickNavigatorItem} />
                           </td>
                        </tr>
                     </tbody>
                  </table>
                )`

   ###*
   * Функция получения набора узлов в ирерахическом представлении.
   *
   * @param {Array} rowsData - набор строк.
   * @param {Number} level - уровень на котором находится узел.
   * @return {Array<React-element>} - набор узлов.
   ###
   _getNodes: (rowsData, level, parentKeys) ->
      nodeStates = @state.nodeStates
      isEnableSelect = @props.enableSelect
      isTree = @_isTree()
      level++
      rows = []

      return if @_isEmptyRecords()

      # Если это обычная иерархическая структура (по папкам) - получим узлы только
      #  на текущем уровне.
      unless isTree
         rowsData = @_getCurrentLevelNodes rowsData

      # Отсортируем узлы, чтобы сначала шли родительские узлы(папки).
      @_sortRows rowsData

      for record in rowsData
         childs = record.childs
         isHasChilds = childs? and childs.length
         recordKey = record.key
         foldingButton = null
         childRows = null
         checkBoxSelector = null

         isFilterApply =  @props.isFilterApply

         # В зависимости от типа иерархии по разному формируем путь иерархии до узла
         #  Если это дерево - используем накопительные массивы, передаваемые рекурсивно,
         #  затем клонируемые. Если обычная иерархия - извлечем ключи из текущего пути
         #  ирерахии.
         if @_isTree() or isFilterApply
            parentKeys = [] if level is 1

            hierarchyKeyPath = parentKeys[..]
         else
            hierarchyKeyPath =
               @state.hierarchyPath.map (item) ->
                  item.key
         hierarchyKeyPath.push record.key

         isMarkedProp = @props.markedNodes[hierarchyKeyPath.join()]
         isSelected = if isMarkedProp? then isMarkedProp else @props.isAllMarked
         isActive = _.isEqual(@props.selectedNodePath, hierarchyKeyPath)

         # Если у узла есть дочерние элементы - получим дочерние только если
         #  состояние дочерних узлов - развернуто.
         if isHasChilds
            nodeState = nodeStates[recordKey]

            # Получим дочерние объекты, если текущий узел развернут или применен фильтр.
            isChildNodesExpanded = if nodeState?
                                      !!nodeStates[recordKey]
                                   else
                                      isFilterApply
            childRows = @_getNodes childs, level, hierarchyKeyPath if isChildNodesExpanded

         rows.push(
            `(<DataTableHierarchyViewNode ref={this._getNodeRefName(hierarchyKeyPath)}
                                     key={recordKey}
                                     hierarchyKeyPath={hierarchyKeyPath}
                                     level={level}
                                     record={record}
                                     mainDataParams={this.props.mainDataParams}
                                     matchExpression={this.props.matchExpression}
                                     secondaryDataParams={this.props.secondaryDataParams}
                                     titleDataParams={this.props.titleDataParams}
                                     isTree={isTree}
                                     isChildNodesExpanded={isChildNodesExpanded}
                                     isActive={isActive}
                                     isSelected={isSelected}
                                     enableSelect={this.props.enableSelect}
                                     enableViewChildsCounter={this.props.enableViewChildsCounter}
                                     enableNodeOptions={this.props.enableNodeOptions}
                                     enableViewKey={this.props.enableViewKey}
                                     enableViewServiceDate={this.props.enableViewServiceDate}
                                     enableSelectParents={this.props.enableSelectParents}
                                     enableSpecialActivateForInnerNodes={this.props.enableSpecialActivateForInnerNodes}
                                     enableEdit={this.props.enableEdit}
                                     enableDelete={this.props.enableDelete}
                                     customNodeOptions={this.props.customNodeOptions}
                                     styleForAdditionCell={this.props.styleForAdditionCell}
                                     onRender={this.props.onRenderNode}
                                     onRenderAddition={this.props.onRenderNodeAddition}
                                     onClick={this._onClickNode}
                                     onClickActivate={this._onClickActivate}
                                     onSelectNode={this.props.onSelectNode}
                                     onClickFoldNode={this._onClickFold}
                                     onClickNodeOption={this.props.onClickNodeOption} />)`
          )

         rows.push childRows if childRows?

      rows

   ###*
   * Функция получения скомпанованных стилей для контейнера.
   *
   * @return {Object}
   ###
   _getComputedStyle: ->
      styleAddition = @props.styleAddition

      @computeStyles @styles.common,
                     styleAddition and styleAddition.dataTable

   ###*
   * Функция формирования наименования ссылки на узел по ключю записи.
   *
   * @param {Array} hierarchyKeyPath - путь ключей записи для иерархии.
   * @return {String}
   ###
   _getNodeRefName: (hierarchyKeyPath) ->
      chars = @_CHARS
      [
         @_NODE_REF_PREFIX,
         hierarchyKeyPath.join()
      ].join chars.underscore

   ###*
   * Функция получения узлов по текущему пути ирерархии.
   *
   * @param {Array} rows - массив записей.
   * @return {Array} - массив записей на текущем активном узле.
   ###
   _getCurrentLevelNodes: (rows)->
      hierarchyPath = @state.hierarchyPath
      childsKey = @_CHILDS_KEY

      if rows? and hierarchyPath? and hierarchyPath.length and !@props.isFilterApply
         for itemParam in hierarchyPath

            for row in rows
               break if row.key is itemParam.key
            if _.has(row, childsKey)
               rows = row[childsKey]
      rows

   ###*
   * Функция получения содержимого узла в зависимости от параметров, заданных
   *  в опциях компонента.
   *
   * @param {Object} record - запись.
   * @return {Object} - хэш с содержимым по узлу. Вид:
   *                    main - основное содержимое.
   *                    secondary - второстепенное содержимое.
   ###
   _getNavigationCaptionFromRecord: (record) ->
      mainDataParams = @props.mainDataParams
      recordFields = record.fields

      if mainDataParams? and !_.isEmpty mainDataParams
         mainDataTemplate = mainDataParams.template
         mainDataFields = mainDataParams.fields
         fieldsValues =
            mainDataFields.map (field) ->
               fieldFromRecord = recordFields[field]
               if fieldFromRecord?
                  fieldFromRecord.value

         format(mainDataTemplate, fieldsValues)
      else
         expectedField = recordFields.name || recordFields.description || recordFields.id

         if expectedField?
            expectedField.value
         else
            recordFields

   ###*
   * Функция получения корневой записи по ключу. Перебирает все корневые записи
   *  и ищет одну по переданному ключу.
   *
   * @param {Number} rootRecordKey - ключ искомой записи.
   * @return {Object} - запись
   ###
   _getRootRecord: (rootRecordKey) ->
      for record in @props.rowsData
         return record if record.key is rootRecordKey

   ###*
   * Функция установки всех узлов, имеющих текущее состояние (свернут/развернут)
   *  в состояние развернутости.
   *
   * @return
   ###
   _setExpandAllCurrentNodes: ->
      nodeStates = @state.nodeStates

      for nodeName, node of nodeStates
         nodeStates[nodeName] = true

      @setState nodeState: nodeStates

   ###*
   * Обработчик клика по кнопке возврата на уровень выше. Удаляет последний узел
   *  из пути иерархии.
   *
   * @param {Object} _value - значение.
   * @param {Object} event - объект события.
   * @return
   ###
   _onClickLevelUp: (_value, event) ->
      event.stopPropagation()

      hierarchyPath = @state.hierarchyPath
      hierarchyPath.pop()
      @setState hierarchyPath: hierarchyPath

      @_handleNavigateThroughTheHierarchy()

   ###*
   * Обработчик клика по кнопке возврата на корневой уровень. Очищает путь иерархии.
   *
   * @param {Object} _value - значение.
   * @param {Object} event - объект события.
   * @return
   ###
   _onClickToRoot: (_value, event)->
      event.stopPropagation()

      @setState hierarchyPath: []

      @_handleNavigateThroughTheHierarchy @props.rowsData

   ###*
   * Обработчик клика по элементы в "хлебном" навигаторе.
   *
   * @param {Object} navigatorItem - хэш параметров элемента навигатора.
   * @param {Object} event - объект события.
   * @return
   ###
   _onClickNavigatorItem: (navigatorItem, event) ->
      event.stopPropagation()

      hierarchyPath = @state.hierarchyPath
      itemPathIndex = hierarchyPath.indexOf navigatorItem
      hierarchyPath.splice itemPathIndex + 1

      @setState hierarchyPath: hierarchyPath

      @_handleNavigateThroughTheHierarchy()

   ###*
   * Обработчик клика по узлу. Запускает обработчик клика по узлу или обработчик
   *  раскрытия узла, если задан специфичный режим работы - режим .
   *
   * @param {Object} record - хэш с параметрами записи.
   * @param {Array} hierarchyPath - путь иерархии до записи.
   * @param {Object} event - объект события.
   * @return
   ###
   _onClickNode: (record, hierarchyPath, event) ->
      enableLeafActivateMode = @props.enableLeafActivateMode
      isRecordsHasChilds = !_.isEmpty(record.childs)
      isNeedChangeClickToFoldHandle =
         enableLeafActivateMode and isRecordsHasChilds

      if isNeedChangeClickToFoldHandle
         @_onClickFold(record, event)
      else
         @_handleNodeClick(record, hierarchyPath)

   ###*
   * Обработчик клика по кнопке активации узла.
   *
   * @param {Object} record - хэш с параметрами записи.
   * @param {Array} hierarchyPath - путь иерархии до записи.
   * @param {Object} event - объект события.
   * @return
   ###
   _onClickActivate: (record, hierarchyPath, event) ->
      event.stopPropagation()
      @_handleNodeClick(record, hierarchyPath)

   ###*
   * Обработчик клика на кнопку разворачивания/сворачивания узла. Устанавливает
   *  состояние развернутости/свернутости для узла.
   *
   * @param {Number} record - запись, по которой запускается сворачивание/разворачивание.
   * @param {Object} event - объект события.
   * @return
   ###
   _onClickFold: (record, event) ->
      event.stopPropagation()

      recordKey = record.key

      if @_isTree()
         nodeStates = @state.nodeStates
         nodeState = nodeStates[recordKey]

         unless nodeState?
            nodeState = @props.isFilterApply

         nodeState = !(!!nodeState)
         nodeStates[recordKey] = nodeState

         @setState nodeStates: nodeStates
      else
         hierarchyPath = @state.hierarchyPath

         hierarchyItemParams =
            key: recordKey
            caption: @_getNavigationCaptionFromRecord record

         hierarchyPath.push hierarchyItemParams

         @setState hierarchyPath: hierarchyPath

         @_handleNavigateThroughTheHierarchy record.childs

   ###*
   * Функция-предикат для есть ли в наборе данных записи.
   *
   * @return {Boolean}
   ###
   _isEmptyRecords: ->
      rowsData = @props.rowsData

      !(rowsData? and rowsData.length)

   ###*
   * Функция-предикат для определения является ли иерархическое представление
   *  деревом.
   *
   * @return {Boolean}
   ###
   _isTree: ->
      @props.type is @_HIERARCHY_VIEW_TYPES.tree

   ###*
   * Обработчик перемещения по иерархии. Если есть обработчик на перемещение
   *  по иерархии - вызывает его, передавая кол-во записей на текущем уровне.
   *
   * @param {Array} records - набор записей на текущем уровне.
   * @return
   ###
   _handleNavigateThroughTheHierarchy: (records) ->
      records ||= @_getCurrentLevelNodes(@props.rowsData)

      if !@_isTree() and records? and records.length
         onHierarchyNavigateHandler = @props.onHierarchyNavigate

         if onHierarchyNavigateHandler?
            onHierarchyNavigateHandler records.length

   ###*
   * Функция обработчки события активации узла. Запускает обработчик активации
   *  (клика) на узел
   *
   * @param {Object} record - хэш с параметрами записи.
   * @param {Array} hierarchyPath - путь иерархии до записи.
   * @return
   ###
   _handleNodeClick: (record, hierarchyPath) ->
      onClickNodeHandler = @props.onClickNode
      nodeRef = @refs[@_getNodeRefName(hierarchyPath)]
      enableSelectRootOnActivateChild = @props.enableSelectRootOnActivateChild

      respondParams =
         if enableSelectRootOnActivateChild
            rootKey = hierarchyPath[0]

            # Если ключ записи, по которой был клик совпадает с ключом корневой записи
            #  то в аргументах возврата будет один аргумент - запись, а если отличается
            #  - два аргумента - текущая запись и корневая.
            if rootKey is record.key
               record: record
            else
               rootRecord = @_getRootRecord rootKey

               record: record
               rootRecord: rootRecord
         else
            record

      if onClickNodeHandler?
         onClickNodeHandler respondParams, nodeRef, hierarchyPath


   ###*
   * Функция сортировки строк. Строки сортируются в порядке - узлы содержащие дочерние
   *  узлы (в порядке, возвращенном с БЛ) -> узлы без дочерних узлов.
   *
   * @param {Array} recordsArray - набор записей
   ###
   _sortRows: (recordsArray)->

      recordsArray.sort (curr, next) ->
         isHasCurrentChilds = !!curr.childs
         isHasNextChilds = !!next.childs

         if !isHasCurrentChilds and isHasNextChilds
            return 1
         else if isHasCurrentChilds and !isHasNextChilds
            return -1
         else
            return curr.key - next.key
         return 0

###* Компонент: узел иерархического представление записей: часть компонента DataTableHierarchyView
*
* @props:
*     {Object} record    - запись из набора, по которому создается узел.
*     {Number} level     - уровень иерархии на котором находится узел.
*     {String} matchExpression - поисковая подстрока.
*     {Object} mainDataParams  - параметры для формирования строки отображения основных данных
*     {Object} secondaryDataParams  - параметры для формирования строки отображения второстепенной
*                                    информации.
*     {Object} titleDataParams - параметры для формирования строки всплывающей подсказки.
*     {Array} hierarchyKeyPath - массив ключей щаписей - путь до текущего узла.
*     {Boolean} isChildNodesExpanded - флаг развернутости дочерних узлов текущего узла.
*     {Boolean} isActive  - флаг активен ли узел (если активен - помечает маркером).
*     {Boolean} isTree  - флаг древовидной иерархии.
*     {Boolean} enableSelect     - флаг возможности выбора конечных узлов. (по-умолчанию =false)
*     {Boolean} enableNodeOptions - флаг возможности вывода опций узла. (по-умолчанию =true)
*     {Boolean} enableViewChildsCounter - флаг возможности отображения счетчика дочерних узлов.
*                                         (по-умолчанию =false)
*     {Boolean} enableViewKey - флаг возможности отображения ключа узла. (по-умолчанию =false)
*     {Boolean} enableViewServiceDate - флаг возможности отображения дат создания и обновления записи.
*                                       (по-умолчанию =false)
*     {Boolean} enableSelectParents - флаг возможности выбора родительских узлов. (по-умолчанию =false)
*     {Boolean} enableSpecialActivateForInnerNodes - флаг возможности спец. активации внутреннего узла иерархии.
*     {Boolean} enableEdit:         - флаг разрешения обновления узла.
*     {Boolean} enableDelete:       - флаг разрешения удаления узла.
*     {Object} customNodeOptions - хэш параметров произвольных опций над узлом.
*     {Object} styleForAdditionCell - стиль для доп. ячейки, содержимое, которой отрисовывается
*                                     функцией onRenderNodeAddition.
*     {Function} onRender - функция отрисовки отображаемого содержимого узла.
*     {Function} onRenderAddition - функция отрисовки отображаемого доп. содержимого узла
*                                   (справа от основного содержимого).
*     {Function} onSelectNode    - обработчик отметки узла.
*     {Function} onClick     - обработчик клика по узлу.
*     {Function} onClickActivate - обработчик клика по кнопке активации узла (для внутренних узлов)
*     {Function} onClickFoldNode - обработчик клика по кнопке сворачинваия/разворачивания узла.
*     {Function} onClickNodeOption - обработчик клика по опции узла.
* @state
*     {Object} isHovered  - флаг нахождения курсора над узлом.
###
DataTableHierarchyViewNode = React.createClass

   # @const {String} - подсказка на лейбле кол-ва дочерних узлов.
   _CHILDS_COUNTER_TITLE: 'Количество дочерних узлов'

   # @const {String} - подсказка на лейбле вывода ключа записи.
   _KEY_TITLE: 'Идентификатор'

   # @const {Object} - хэш с иконками для кнопок отображения служебных дат записи.
   _RECORD_DATE_ICONS:
      updated: 'refresh'
      created: 'file-o'

   # @const {Object} - хэш с параметрами кнопок для сворачивания/разворачивания узлов.
   _HIERARCHY_BUTTON_PARAMS:
      tree:
         expanded:
            icon: 'minus-square-o'
            title: 'Свернуть'
         collapsed:
            icon: 'plus-square-o'
            title: 'Развернуть'
      hierarchy:
         expanded:
            icon: 'folder-open-o'
            title: 'Открыто'
         collapsed:
            icon: 'folder-o'
            title: 'Открыть'

   # @consts {Object} - ключи для доступа к хэшу кнопок перемещения по иерархии.
   _BUTTON_PARAM_KEYS: keyMirror(
      tree: null,
      hierarchy: null
   )

   # @const {Object} - параметры кнопки активации узла
   _ACTIVATE_BUTTON_PARAMS:
      title: 'Выбрать'
      icon: 'arrow-circle-right'
      isLink: true

   # @const {String} - тип поля ввода - чекбокса.
   _CHECKBOX_INPUT: 'checkbox'

   # @const {Number} - шаг единичного отступа.
   _SPACE_STEP: 20

   # @const {Number} - кол-во строк объединения для ячейки ключа.
   _KEY_CELL_ROWSPAN: 2

   mixins: [HelpersMixin, AnimateMixin, AnimationsMixin.highlightBack]

   styles:
      node:
         margin: _COMMON_PADDING
         display: 'inline-block'
         fontSize: 14
      nodeComplex:
         fontSize: 14
         padding: 2
         paddingLeft: _COMMON_PADDING
      nodeContainer:
         whiteSpace: 'nowrap'
         borderStyle: 'solid'
         borderWidth: 1
         borderColor: _COLORS.hierarchy4
         borderRightWidth: 0
         borderLeftWidth: 0
         backgroundColor: _COLORS.light
         color: _COLORS.hierarchy2
         marginTop: -1
         width: '100%'
         tableLayout: 'fixed'
         overflow: 'hidden'
      secondaryData:
         fontSize: 11
         color: _COLORS.hierarchy3
      hierarchyButton:
         fontSize: 19
      nodeContentAddition:
         width: '15%'
      cellSelectedMarker:
         minWidth: 1
         width: 1
      cellSelectedMarkerActive:
         backgroundColor: _COLORS.main
      nodeContainerHighlightBack:
         backgroundColor: _COLORS.highlight2
         color: _COLORS.dark
      actionCell:
         width: 20
         textAlign: 'center'
      serviceDateCell:
         fontSize: 12
         color: _COLORS.hierarchy3
         width: 170
      activateButtonCell:
         width: 30
      activateButton:
         fontSize: 19
      serviceDateButton:
         color: _COLORS.hierarchy3
      nodeContentCell:
         width: '100%'
         cursor: 'pointer'
         overflow: 'hidden'
         textOverflow: 'ellipsis'
      keyLabel:
         color: _COLORS.secondary
         marginLeft: 0
         marginRight: _COMMON_PADDING
         borderStyle: 'solid'
         borderWidth: 1
         borderColor: _COLORS.secondary
         padding: _COMMON_PADDING
         paddingTop: 0
         paddingBottom: 0
      childsCounter:
         borderStyle: 'solid'
         borderWidth: 1
         borderColor: _COLORS.hierarchy4
         borderRadius: 10
         marginLeft: _COMMON_PADDING
         color: _COLORS.hierarchy3
         padding: _COMMON_PADDING * 2
         paddingBottom: _COMMON_PADDING - 2
         paddingTop: _COMMON_PADDING - 2
         fontSize: 11

   getInitialState: ->
      isHovered: false
      isSelected: @props.isSelected

   componentWillReceiveProps: (nextProps) ->
      if nextProps.isSelected isnt @state.isSelected
         @setState isSelected: nextProps.isSelected

   render: ->
      record = @props.record
      childs = record.childs
      isParent = childs? and childs.length

      `(
         <table style={this._getNodeContainerStyle()}
                onMouseEnter={this._onMouseEnter}
                onMouseLeave={this._onMouseLeave}
                onClick={this._onClickNode}>
            <tbody>
               <tr>
                  <td style={this._getSelectedMarkerCellStyle()}></td>
                  <td style={this._getSpacerCellStyle()}>
                  </td>
                  <td style={this._getFoldingButtonCellStyle(isParent)}>
                     {this._getHierarchyButton(isParent)}
                  </td>
                  <td style={this._getSelectorCellStyle(isParent)}>
                     {this._getCheckBoxSelector(record, isParent)}
                  </td>
                  <td style={this.styles.nodeContentCell}>
                     {this._getNodeContent(record)}
                  </td>
                  {this._getAdditionContentCell(record)}
                  {this._getServiceDateCell(record)}
                  {this._getSpecialActivateCell(isParent)}
                  {this._getNodeOptionsCell(record)}
               </tr>
            </tbody>
         </table>
      )`

   ###*
   * Функция-предикат для оперделения является ли узел выбранным(отмеченным).
   *
   * @return {Boolean}
   ###
   isSelected: ->
      @state.isSelected

   ###*
   * Функция получения содержимого узла. Считывает параметры формирования содержимого
   *  узла(если) заданы. Если нет - пытается сформировать данные способом по-умолчанию.
   *  Если задан флаг отображения идентификатора узла - дополнительно формирует
   *  лейбл для отображения ключа.P
   *
   * @param {Object} record - запись.
   * @return {React-element} - содержимое узла .
   ###
   _getNodeContent: (record) ->
      keyElement = @_getNodeKeyElement()
      childsCounterElement = @_getChildsCounterElement()
      onRenderHandler = @props.onRender
      nodeRenderData = @_getRenderDataFromRecord(record)

      nodeMain =
         if onRenderHandler?
            onRenderHandler(record)
         else
            `(<AllocationContent content={nodeRenderData.main}
                                 expression={this.props.matchExpression} />)`

      nodeSecondary =
         if nodeRenderData.secondary? and !onRenderHandler?
            `(
               <div style={this.styles.secondaryData}>
                  {nodeRenderData.secondary}
               </div>
             )`

      nodeTitle = nodeRenderData.title or nodeRenderData.main

      nodeContent =
         if nodeSecondary?
            `(
               <table style={this.styles.nodeComplex}
                      title={nodeTitle} >
                  <tbody>
                     <tr>
                        <td rowSpan={this._KEY_CELL_ROWSPAN}>{keyElement}</td>
                        <td>
                           {nodeMain}
                           {childsCounterElement}
                        </td>
                     </tr>
                     <tr>
                        <td>{nodeSecondary}</td>
                     </tr>
                  </tbody>
               </table>
            )`
         else
            `(
               <span style={this.styles.node}
                     title={nodeTitle} >
                  {keyElement}
                  {nodeMain}
                  {childsCounterElement}
               </span>
            )`

   ###*
   * Функция рендера дополнительного содежимого узла. Если задан обработчик
   *  дополнительного рендера - создает новую ячейку с содержимым, который
   *  вовращает функция-обработчкик.
   *
   * @param {Object} record - запись узла.
   * @return {React-element, undefined}
   ###
   _getAdditionContentCell: (record) ->
      onRenderAdditionHandler = @props.onRenderAddition

      if onRenderAdditionHandler?
         additionCellContent = onRenderAdditionHandler(record)

         if additionCellContent?
            styleForAdditionCell = @props.styleForAdditionCell

            additionCellStyle =
               @computeStyles @styles.nodeContentAddition and
                              styleForAdditionCell

            `(
               <td style={additionCellStyle}>
                  {additionCellContent}
               </td>
             )`

   ###*
   * Функция получения селектора узла. Проверяет необходимо ли формировать селектор узла.
   *  Если необходимо - формирует селектор.
   *
   * @param {Object} record - запись.
   * @param {Boolean} isParent - флаг того, что это родительских узел(есть дочерние)
   * @return {React-element, undefined} - кнопка
   ###
   _getCheckBoxSelector: (record, isParent) ->

      if @_isNeedNodeSeletor isParent
         `(
             <input type={this._CHECKBOX_INPUT}
                    value={record.key}
                    onChange={this._onChangeSelect}
                    onClick={this._onClickNodeSelect}
                    checked={this.state.isSelected}/>
          )`

   ###*
   * Функция получения кнопки сворачивания/разворачивания дочерних узлов. Если
   *  узел не содержит дочерних - возвращается undefined.
   *
   * @param {Boolean} isParent - флаг того, что это родительских узел(есть дочерние)
   * @return {React-element, undefined} - кнопка
   ###
   _getHierarchyButton: (isParent) ->
      return unless isParent

      hierarchyButtonParams = @_HIERARCHY_BUTTON_PARAMS
      buttonParamKeys = @_BUTTON_PARAM_KEYS

      buttonParamKey = if @props.isTree
                          buttonParamKeys.tree
                       else
                          buttonParamKeys.hierarchy

      buttonParam =
         if @props.isChildNodesExpanded
            hierarchyButtonParams[buttonParamKey].expanded
         else
            hierarchyButtonParams[buttonParamKey].collapsed


      `(<Button icon={buttonParam.icon}
                title={buttonParam.title}
                value={this.props.record}
                styleAddition={this.styles.hierarchyButton}
                isLink={true}
                isWithoutPadding={true}
                onClick={this.props.onClickFoldNode} />)`


   ###*
   * Функция получения элемента отображения ключа узла.
   *
   * @return {React-element}
   ###
   _getNodeKeyElement: ->
      record = @props.record

      if @props.enableViewKey and record?

         `(
            <span style={this.styles.keyLabel}
                  title={this._KEY_TITLE}>
               {record.key}
            </span>
          )`

   ###*
   * Функция получения счетчика дочерних узлов для узла. Формирует счетчик для
   *  родительских узлов и только если зада флаг разрешающий отображение кол-ва
   *  дочерних узлов.
   *
   * @return {React-element} - счетчик дочерних узлов.
   ###
   _getChildsCounterElement: ->
      if @props.enableViewChildsCounter
         childs = @props.record.childs
         childsCount =
            if childs? and childs.length
               childs.length

         if childsCount
            `(
               <span style={this.styles.childsCounter}
                     title={this._CHILDS_COUNTER_TITLE}>
                  {childsCount}
               </span>
            )`

   ###*
   * Функция получения ячейки с сервисными датами - датой создания и датой
   *  обновления записи. Ячейка формируется только если задана опция отображения
   *  сервисных дат.
   *
   * @param {Object} record - запись.
   * @return {React-element} - ячейка с сервисными датами.
   ###
   _getServiceDateCell: (record) ->
      if @props.enableViewServiceDate
         fields = record.fields
         recordDateIcons = @_RECORD_DATE_ICONS
         createdAt = fields.created_at
         updatedAt = fields.updated_at

         if createdAt?
            createdDate = @convertToHumanDateTime(createdAt.value)
            createdDateObject =
               `(
                  <div>
                     <Button title={createdAt.caption}
                             caption={createdDate}
                             icon={recordDateIcons.created}
                             isLink={true}
                             styleAddition={this.styles.serviceDateButton} />
                  </div>
               )`

         if updatedAt?
            updatedDate =  @convertToHumanDateTime(updatedAt.value)
            updatedDateObject =
               `(
                  <div>
                     <Button title={updatedAt.caption}
                             caption={updatedDate}
                             icon={recordDateIcons.updated}
                             isLink={true}
                             styleAddition={this.styles.serviceDateButton} />
                  </div>
               )`

         `(
            <td style={this.styles.serviceDateCell}>
               {createdDateObject}
               {updatedDateObject}
            </td>
          )`

   ###*
   * Функция получения ячейки с кнопкой спец активации узла .
   *
   * @param {Boolean} isParent - флаг родительского узла.
   * @return {React-element}
   ###
   _getSpecialActivateCell: (isParent) ->
      if @props.enableSpecialActivateForInnerNodes and isParent
         `(
            <td style={this.styles.activateButtonCell}>
               <Button {...this._ACTIVATE_BUTTON_PARAMS}
                       styleAddition={this.styles.activateButton}
                       onClick={this._onClickActivate}
                     />
            </td>
          )`

   ###*
   * Функция получения ячейки с опциями узла. Формирует ячейку только если
   *  задана опция, разрешающая опции узла.
   *
   * @param {Object} record - запись.
   * @return {React-element} - ячейка с опциями узла.
   ###
   _getNodeOptionsCell: (record)->
      if @props.enableNodeOptions
         recordKey = record.key

         `(<DataTableRowOptionsCell rowData={record}
                                    isShown={this.state.isHovered}
                                    customRowOptions={this.props.customNodeOptions}
                                    enableEdit={this.props.enableEdit}
                                    enableDelete={this.props.enableDelete}
                                    rowKey={recordKey}
                                    onOptionClick={this.props.onClickNodeOption} />)`

   ###*
   * Функция получения стиля для ячейки с кнопкой сворачивания/разворачивания
   *  дочерних узлов.
   *
   * @param {Boolean} isParent - флаг того, что это родительский узел
   * @return {Object} - скомпанованный стиль.
   ###
   _getFoldingButtonCellStyle: (isParent) ->
      @styles.actionCell if isParent

   ###*
   * Функция получения стиля для ячейки с селектором узла.
   *
   * @param {Boolean} isParent - флаг того, что это родительский узел
   * @return {Object} - скомпанованный стиль.
   ###
   _getSelectorCellStyle: (isParent) ->
      if @_isNeedNodeSeletor isParent
         @styles.actionCell

   ###*
   * Функция получения скомпанованного стиля для ячейки-маркера активного узла.
   *
   * @return {Object} - скомпанованный стиль.
   ###
   _getSelectedMarkerCellStyle: ->
      @computeStyles @styles.cellSelectedMarker,
                     @props.isActive and @styles.cellSelectedMarkerActive

   ###*
   * Функция получения скомпанованного стиля для таблицы-контейнера узла.
   *
   * @return {Object} - скомпанованный стиль.
   ###
   _getNodeContainerStyle: ->
      @computeStyles @styles.nodeContainer,
                     @state.isHovered and @styles.nodeContainerHighlightBack

   ###*
   * Функция получения стиля для ячейки отступа для визуального
   *  упорядочивания иерархии.
   *
   * @return {Object} - стиль ячейки отступа.
   ###
   _getSpacerCellStyle: ->
      level = @props.level

      if level > 1
         {width: (level - 1) * @_SPACE_STEP}

   ###*
   * Функция получения содержимого узла в зависимости от параметров, заданных
   *  в опциях компонента.
   *
   * @param {Object} record - запись.
   * @return {Object} - хэш с содержимым по узлу. Вид:
   *                    main      - основное содержимое.
   *                    secondary - второстепенное содержимое.
   *                    title     - содержимое всплывающей подсказки.
   ###
   _getRenderDataFromRecord: (record) ->
      mainDataParams = @props.mainDataParams
      secondaryDataParams = @props.secondaryDataParams
      titleDataParams = @props.titleDataParams
      recordFields = record.fields

      getValuesForFields = (fields, record) ->
         recordFeilds =  record.fields
         if recordFeilds?
            fields.map (field) ->
               fieldFromRecord = recordFields[field]
               fieldFromRecord.value if fieldFromRecord?

      formatTemplateFields = (dataParams, record) ->
         dataTemplate = dataParams.template
         dataFields = dataParams.fields
         fieldValues = getValuesForFields(dataFields, record)

         format(dataTemplate, fieldValues)

      mainData =
         if mainDataParams? and !_.isEmpty mainDataParams
            formatTemplateFields(mainDataParams, record)
         else
            expectedField = recordFields.name or
                            recordFields.description or
                            recordFields.id

            if expectedField?
               expectedField.value
            else
               recordFields
      secondaryData =
         if secondaryDataParams? and !_.isEmpty(secondaryDataParams)
            formatTemplateFields(secondaryDataParams, record)

      titleData =
         if titleDataParams? and !_.isEmpty(titleDataParams)
            formatTemplateFields(titleDataParams, record)

      main: mainData
      secondary: secondaryData
      title: titleData

   ###*
   * Функция-предикат для определения необходимости создания селектора узла.
   *
   * @param {Boolean} isParent - флаг родительского узла.
   * @return {Boolean}
   ###
   _isNeedNodeSeletor: (isParent) ->
      if @props.enableSelect
         return !isParent or (isParent and @props.enableSelectParents)
      false

   ###*
   * Обработчик наведения курсора на узел. Устанавливает состояние
   *  наведения курсора на узел.
   *
   * @return
   ###
   _onMouseEnter: ->
      @setState isHovered: true

   ###*
   * Обработчик ухода курсора с узла. Убирает состояние нахождения курсора на узле
   *
   * @return
   ###
   _onMouseLeave: ->
      @setState isHovered: false

   ###*
   * Обработчик клика по узлу. Запускает обработчик клика по узлу. Передает
   *  текущую запись и путь ключей иерархии до текущей записи.
   *
   * @param {Event-obj} - объект события.
   * @return
   ###
   _onClickNode: (event) ->
      @props.onClick @props.record, @props.hierarchyKeyPath, event

   ###*
   * Обработчик клика на кнопку активации. Запускает обработчик активации.
   *
   * @param {Null} _value - значение кнопки.
   * @param {Event-obj} - объект события.
   * @return
   ###
   _onClickActivate: (_value, event) ->
      @props.onClickActivate @props.record, @props.hierarchyKeyPath, event

   ###*
   * Обработчик клика по селектору узла. Останавливает проброс события клика.
   *
   * @param {Event-object} event     - объект события.
   * @return
   ###
   _onClickNodeSelect: (event) ->
      event.stopPropagation()

   ###*
   * Обработчик изменения селектора выбора записи.
   *
   * @param {Event-object} event     - объект события.
   * @return
   ###
   _onChangeSelect: (event) ->
      isChecked = event.currentTarget.checked
      @props.onSelectNode(
         event,
         @props.record.key,
         isChecked,
         @props.hierarchyKeyPath
      )

      @setState isSelected: isChecked


###* Компонент: Заголовок таблицы: часть компонента DataTable
*
* @props:
*     {Object} columns           - хэш с параметрами колонок:
*                        name:       - имя колонки,
*                           type:    - тип колонки,
*                           caption: - выводимый заголовок.
*     {Function} onColumnHeaderClick - обработчик клика по заголовку колонки.
*     {Object} orderParams - хэш с параметрами упорядочивания:
*                            column:    - имя колонки
*                            direction: - направление упорядочивания (ACS, DESC)
*     {Object} columnRenderParams - хэш с параметрами отображения колонок.
*     {Boolean} enableRowSelect   - флаг разрешения выбора строк.
*     {Boolean} enableRowOptions  - флаг разрешения опций строк.
*     {Boolean} isAllRowsMarked   - флаг отмеченности всех строк.
*     {Function} onClickSelectAll - обработчик, запускаемый по клику на чекбокс выбора всех
*                                   записей.
* @state
*     {Boolean} isNoColumns       - флаг для хранения отсутствие/наличие колонок
###
DataTableHeader = React.createClass
   # @const {String} - подсказка на селекторе всех записей.
   _SELECT_ALL_TITLE: 'Выбрать все'

   # @const {String} - ключ для доступа к параметрам стиля ячейки таблицы.
   _RENDER_KEYS:
      columns: 'columns'
      alignRules: 'alignRules'
      alignRuleKeys:
         vertical: 'vertical'
         horizontal: 'horizontal'
      columnKeys:
         style: 'style'
         isHidden: 'isHidden'

   mixins: [HelpersMixin]

   styles:
      columnSelectHeader:
         width: 25
         textAlign: 'center'
         backgroundColor: _COLORS.hierarchy3
      columnOptionsHeader:
         width: 1
      hidden:
         display: 'none'

   getInitialState: ->
      isNoColumns: true
      isAllRowsMarked: @props.isAllRowsMarked

   componentWillReceiveProps: (nextProps) ->
      isNextAllRowsMarked = nextProps.isAllRowsMarked
      isCurrentAllRowsMarked = @props.isAllRowsMarked

      if isNextAllRowsMarked isnt isCurrentAllRowsMarked
         @setState isAllRowsMarked: isNextAllRowsMarked

   componentWillUpdate: (nextProps, nextState) ->

      isNoColumns = _.isEmpty nextProps.columns

      if @state.isNoColumns isnt isNoColumns
         @setState
            isNoColumns: isNoColumns

   render: ->
      isHasColumns = !@state.isNoColumns

      headerContent =
         if isHasColumns
           `(<tr>
               {this._getRowSelectHeaderCell()}
               {this._getHeaderCells()}
               {this._getRowOptionsHeaderCell()}
            </tr>)`

      `(
         <thead>
            {headerContent}
         </thead>
       )`

   ###*
   * Функция формирования ячейки для колонки выбора записей.
   *
   * @return {React-element, undefined} - ячейка заголовка для колонки выбора строк.
   ###
   _getRowSelectHeaderCell: ->
      if @props.enableRowSelect
         `(<th style={this.styles.columnSelectHeader}>
              <input type='checkbox'
                     title={this._SELECT_ALL_TITLE}
                     onChange={this._onClickSelectAll}
                     checked={this.state.isAllRowsMarked}/>
           </th>)`

   ###*
   * Функция формирования ячейки для колонки опций записи.
   *
   * @return {React-element, undefined} - ячейка заголовка для колонки выбора строк.
   ###
   _getRowOptionsHeaderCell: ->
      if @props.enableRowOptions
         `(<th style={this.styles.columnOptionsHeader}></th>)`

   ###*
   * Функция формирования массива ячеек заголовка таблицы.
   *
   * @return {Array<React-element>} - массив ячеек
   ###
   _getHeaderCells: ->
      columns = _.cloneDeep @props.columns
      columnRenderParams = @props.columnRenderParams
      orderParams = @props.orderParams
      isStrongRenderRule = false
      renderColumns = {}
      headerCells = []

      if columnRenderParams?
         isStrongRenderRule = columnRenderParams.isStrongRenderRule
         renderColumns = columnRenderParams.columns

      ###*
      * Функция получения параметров упорядоченности записей по данному столбцу.
      *
      * @param {String} columnName - имя колонки.
      * @param {Object} orderParams - параметры упорядочивания.
      * @return {Object} - параметры упорядочивания по колонке.
      ###
      getOrderedColumnParams = (columnName, orderParams) ->
         isOrdered = false
         orderDirection = ''

         unless _.isEmpty(orderParams)
            isOrdered = orderParams.column is columnName
            orderDirection = orderParams.direction

         isOrdered: isOrdered
         direction: orderDirection

      ###*
      * Функция формирования ячейки заголовка таблицы.
      *
      * @param {String} columnName   - имя колонки.
      * @param {Object} columnParams - параметры колонки.
      * @param {Object} orderParams  - параметры упорядоченности колонки.
      * @return {React-element} - ячейка заголовка таблицы.
      ###
      getHeaderCell = (columnName, columnParams, columnOrderedParams) ->
         `(
            <DataTableHeaderCell key={columnName}
                                 columnName={columnName}
                                 columnParams={columnParams}
                                 renderStyle={this._getCellRenderStyle(columnName)}
                                 isOrdered={columnOrderedParams.isOrdered}
                                 orderDirection={columnOrderedParams.direction}
                                 onClick={this.props.onColumnHeaderClick} />
         )`

      ###*
      * Функция-предикат для определения является ли колонка "визуализуруемой".
      *  Используется замыкание для доступа к параметрам рендера.
      *
      * @return {Boolean}
      ###
      isRendered = (columnName) ->
         !isStrongRenderRule or
         (isStrongRenderRule and
          renderColumns.hasOwnProperty(columnName))

      # Если заданы параметры рендера колонок.
      if columnRenderParams?
         columnsOrder = columnRenderParams.columnsOrder

         # Перебираем упорядоченные колонки, если они были заданы.
         if columnsOrder?

            for orderedColName in columnsOrder
               orderedColumnParams = columns[orderedColName]
               orderedColumnRenderParams = renderColumns[orderedColName]

               if isRendered(orderedColName) and orderedColumnParams?
                  if orderedColumnRenderParams? and orderedColumnRenderParams.caption?
                     orderedColumnParams.caption = orderedColumnRenderParams.caption

                  args = [
                     orderedColName
                     orderedColumnParams
                     getOrderedColumnParams(orderedColName, orderParams)
                  ]

                  headerCells.push(getHeaderCell.apply(this, args))

                  delete columns[orderedColName]

      # Перебираем оставшиеся, неупорядоченные колонки.
      for colName, colParams of columns

         if isRendered(colName)
            columnRenderParams = renderColumns[colName] if renderColumns?

            if columnRenderParams? and columnRenderParams.caption?
               colParams.caption = columnRenderParams.caption

            args = [
               colName
               colParams
               getOrderedColumnParams(colName, orderParams)
            ]

            headerCells.push(getHeaderCell.apply(this, args))

      headerCells

   ###*
   * Метод получения кастомного стиля рендера ячейки таблицы.
   *
   * @param {String} columnName - имя колонки.
   * @return {Object, undefined} - стиль рендера.
   ###
   _getCellRenderStyle: (columnName) ->
      renderKeys = @_RENDER_KEYS
      columnsKey = renderKeys.columns
      columnsKeys = renderKeys.columnKeys
      alignRulesKey = renderKeys.alignRules
      alignRuleKeys = renderKeys.alignRuleKeys
      alignVerticalKey = alignRuleKeys.vertical
      alignHorizontalKey = alignRuleKeys.horizontal
      styleKey = columnsKeys.style
      isHiddenKey = columnsKeys.isHidden
      columnRenderParams = @props.columnRenderParams
      renderStyle = undefined

      if columnRenderParams?
         columns = if _.has(columnRenderParams, columnsKey)
                      columnRenderParams[columnsKey]
         alignRules = if _.has(columnRenderParams, alignRulesKey)
                         columnRenderParams[alignRulesKey]
         alignRulesColumns = if alignRules? and _.has(alignRules, columnsKey)
                                alignRules[columnsKey]
      # Определим
      if alignRulesColumns?
         horizontalAlign = alignRulesColumns[alignHorizontalKey]
         verticalAlign = alignRulesColumns[alignVerticalKey]

         alignStyle = @computeStyles horizontalAlign and { textAlign: horizontalAlign },
                                     verticalAlign and { verticalAlign: verticalAlign }

      unless _.isEmpty columns
         if _.has(columns, columnName)
            renderParams = columns[columnName]

            if _.isPlainObject(renderParams)

               if _.has(renderParams, styleKey)
                  renderStyle = renderParams[styleKey]

               if _.has(renderParams, isHiddenKey) and renderParams[isHiddenKey]
                  hiddenStyle = @styles.hidden

      @computeStyles renderStyle, alignStyle, hiddenStyle

   ###*
   * Обработчик клика на селекторе всех записей.
   *
   * @param {Event-Object} event - объект события.
   * @return
   ###
   _onClickSelectAll: (event) ->
      isAllRowsMarked = event.target.checked

      onClickSelectAllHandler = @props.onClickSelectAll
      onClickSelectAllHandler(isAllRowsMarked) if onClickSelectAllHandler?

      @setState isAllRowsMarked: isAllRowsMarked


###* Компонент: Ячейка заголовка колонки: часть компонента DataTable
*
* @props :
*     {String} columnName     - имя колонки.
*     {Object} columnParams   - параметры колонки:
*                               type:    - тип колонки,
*                               caption: - выводимый заголовок.
*     {Function} onClick      - обработчик клика по заголовку колонки.
*     {Boolean} isOrdered     - флаг упорядоченности колонки.
*     {String} orderDirection - направление упорядочивания (по возрастанию, по убыванию).
*     {Object} renderStyle    - дополнительный стиль рендеринга ячейки.
###
DataTableHeaderCell = React.createClass
   # @const - иконки сортировки.
   _ORDER_ICONS:
      DESC: 'sort-desc'
      ASC: 'sort-asc'

   mixins: [HelpersMixin, BehaviorsMixin.resize.width]

   styles:
      common:
         textOverflow: 'ellipsis'
         overflow: 'hidden'
         # borderBottomStyle: 'solid'
         # borderBottomColor: _COLORS.light
         # borderBottomWidth: 2
         cursor: 'pointer'
         whiteSpace: 'nowrap'
         fontSize: 14
         fontWeight: 'normal'
         width: '100%'
         backgroundColor: _COLORS.hierarchy3
         color: _COLORS.light
         padding: 2
      cellOrderIcon:
         width: 8
      cellTableRuler:
         tableLayout: 'fixed'
         width: '100%'
         minHeight: 25
      orderIcon:
         float: 'right'
      cellResizer:
         width: 1
         cursor: 'col-resize'
         borderRightStyle: 'solid'
         borderRightWidth: 1
         borderRightColor: _COLORS.hierarchy4

   render: ->
      columnCaption = @props.columnParams.caption

      computeStyle = @computeStyles @styles.common,
                                    @props.renderStyle,
                                    @_getResizeWidth()

      orderIconParams = @_getOrderIconParams()

      `(
         <th style={computeStyle}
             title={columnCaption}
             onClick={this._onClick}>
            <table style={this.styles.cellTableRuler}>
               <tbody>
                  <tr>
                     <td style={this.styles.common}>
                         {columnCaption}
                     </td>
                     <td style={orderIconParams.style}>
                        {orderIconParams.icon}
                     </td>
                     <td style={this.styles.cellResizer}
                          onMouseDown={this._onMouseDownResizer}></td>
                  </tr>
               </tbody>
            </table>
         </th>
       )`

   ###*
   * Функция получения параметров ячейки с иконкой сортировки. Возвращает элемент
   *  иконки и стиль для ячейки с иконкой.
   *
   * @return {Object} - хэш параметров ячейки с иконкой. Вид:
   *              {React-element} icon - элемент-иконка
   *              {Object} style        - стиль ячейки
   ###
   _getOrderIconParams: ->
      if @props.isOrdered
         orderIcon = @_ORDER_ICONS[@props.orderDirection]

         iconElement = `(<i className={'fa fa-' + orderIcon}></i>)`
         cellStyle = @styles.cellOrderIcon

      icon: iconElement
      style: cellStyle

   ###*
   * Функция на нажатие клавиши мыши на объекте изменения размеров. Запускает
   *  изменение размеров (модуль BehaviorsMixin).
   *
   * @return
   ###
   _onMouseDownResizer: ->
      positionParams = ReactDOM.findDOMNode(this).getBoundingClientRect()
      cellElementLeft = positionParams.left
      cellElementWidth = positionParams.width

      @_initResizeWidth(cellElementWidth, cellElementLeft)

   ###*
   * Обработчик клика по ячейки заголовка. Пробрасывает имя колонки на обработчик.
   *
   * @return
   ###
   _onClick: ->
      onClickHandler = @props.onClick

      if onClickHandler?
         onClickHandler @props.columnName


###* Компонент: Набор строк таблицы данных: часть компонента DataTable
*
* @props:
*     {Array<Object>} rowsData      - Набор данных строк. Вид члена массива:
*                                {Srting, Number} key  - ключ строки
*                                {Object} fields - хэш с набором данных полей. Вид:
*                                      {Object} [fieldName]: - хэш данных по полю:
*                                            {String} caption: - заголовок поля,
*                                            {String} type: - тип поля,
*                                            {String, Number, Object...}, value: - значения поля.
* {Number, String} selectedRecordID - идентификатор выбранной записи.
*     {String} matchExpression      - подстрока для поиска значений в ячейках.
*     {Object} columnRenderParams   - хэш с параметрами отображения колонок.
*     {Object} styleAddition        - параметры дополнительных стилей.
*     {Array} customRowOptions      - массив кастомных опций.
*     {Boolean} enableRowOptions    - флаг разрешения опции для строк.
*     {Boolean} enableSelect        - флаг разрешения выбора строк.
*     {Boolean} enableDragAndDrop   - флаг разрешения перемещения строк.
*     {Boolean} enableEdit          - флаг разрешения редактирования записей.
*     {Boolean} enableDelete        - флаг разрешения удаления записей.
*     {Boolean} isAllMarked         - флаг выбора всех записей.
*     {Boolean} isHasStripFarming   - флаг наличия черезполосицы.
*     {Boolean} isNeedFormatterRow  - флаг того что нужна строка форматирования.
*                                     (пустая строка необходимая для соблюдения
*                                      форматирования таблицы, если отсутствует заголоовок)
*     {Object} markedRows           - хэш помечаемых записей.
*     {Object} recordOperations     - хэш возможных операций над записью.
*     {Object} recordKeys           - хэш ключей элементов записи.
*     {Object} renderRuleKeys       - хэш ключей параметров рендера.
*     {Function} getEntityParams    - функция получения параметров сущности-связки
*                                     для построения формы.
*     {Function} getModelParams     - функция получения параметров модели.
*{Function} getRecordReflectionParams- функция получения параметров сущности записи по
*                                     переданной последовательности-цепи связок.
*     {Function} getInstance        - функция получения экземпляра записи в различных форматах
*                                     (с отправкой запроса в API).
*     {Function} onRefreshRecord    - обработчик на обновление записи по строке.
*                                     отправляет новые обновленные данные записи.
*     {Function} onClick            - обработчик клика по строке.
*     {Function} onRowOptionClick   - обработчик клика по опции строки.
*     {Function} onRowSelect        - обработчик выбора строки.
* {Function} onRowDragAndDropTerminate - обработчик на окончание drag-and-drop строки.
###
DataTableRows = React.createClass

   # @const {Array} - сбрасываемые стили для строки форматирования таблицы.
   _RESETED_FORMATTER_STYLE: [
      'padding'
      'margin'
      'height'
      'minHeight'
   ]

   # @const {Object} - префиксы для элементов компонента.
   _REF_PREFIXES:
      formatter: 'formatterRow'

   # @const {Object} - наименования элементов для формирования ссылок на элементы.
   _ELEMENT_NAMES: keyMirror(
      selector: null
      row: null
      rows: null
   )

   # @const {Object} - используемые символы.
   _CHARS:
      empty: ''
      underscore: '_'

   styles:
      formatterSelectCell:
         width: 25
      formatterCommonCell:
         width: '100%'

   render: ->
      rowsData = @props.rowsData
      chars = @_CHARS
      elementNames = @_ELEMENT_NAMES
      underscoreChar = chars.underscore
      rows = []

      for rowData, idx in rowsData
         isEven = idx % 2 == 0

         rowKey = rowData.key
         isMarkedProp = @props.markedRows[rowKey]
         isSelected = if isMarkedProp? then isMarkedProp else @props.isAllMarked

         rowIndex = [
            rowKey
            idx
         ].join underscoreChar

         rowRef = [
            elementNames.row
            rowKey
         ].join underscoreChar

         rows.push(
            `(
               <DataTableRow key={rowIndex}
                             ref={rowRef}
                             isEven={isEven}
                             rowData={rowData}
                             selectedRecordID={this.props.selectedRecordID}
                             matchExpression={this.props.matchExpression}
                             columnRenderParams={this.props.columnRenderParams}
                             recordOperations={this.props.recordOperations}
                             recordKeys={this.props.recordKeys}
                             renderRuleKeys={this.props.renderRuleKeys}
                             styleAddition={this.props.styleAddition}
                             enableRowOptions={this.props.enableRowOptions}
                             enableDragAndDrop={this.props.enableDragAndDrop}
                             enableSelect={this.props.enableSelect}
                             enableEdit={this.props.enableEdit}
                             enableDelete={this.props.enableDelete}
                             customRowOptions={this.props.customRowOptions}
                             isSelected={isSelected}
                             isHasStripFarming={this.props.isHasStripFarming}
                             enableSelect={this.props.enableSelect}
                             getModelParams={this.props.getModelParams}
                             getEntityParams={this.props.getEntityParams}
                             getInstance={this.props.getInstance}
                             getRecordReflectionParams={this.props.getRecordReflectionParams}
                             onClick={this.props.onClick}
                             onRefreshRecord={this.props.onRefreshRecord}
                             onOptionClick={this.props.onRowOptionClick}
                             onSelect={this.props.onRowSelect}
                             onDragAndDropTerminate={this.props.onRowDragAndDropTerminate}
                           />
             )`
         )

      `(
         <tbody ref={this._ELEMENT_NAMES.rows}>
            {this._getFormatterRow()}
            {rows}
         </tbody>
       )`

   ###*
   * Функция получения строки форматирования таблицы. Данная строка нужна для поддержания
   *  форматирования, если в таблице отсутствует заголовок (сделана для того чтобы
   *  не ехал форматировани таблице при drag-and-drop первой строки).
   *
   * @return {React-element} - строка форматирования.
   ###
   _getFormatterRow: ->
      if @props.isNeedFormatterRow
         rowsData = @props.rowsData

         if rowsData? and rowsData.length
            rowsKeys = Object.keys(rowsData)
            firstRow = rowsData[rowsKeys[0]]
            renderParams = @props.columnRenderParams
            isStrongRenderRule = renderParams.isStrongRenderRule if renderParams?
            renderParamColumns = renderParams.columns if renderParams?
            resetedStyle = @_RESETED_FORMATTER_STYLE
            refPrefixes = @_REF_PREFIXES
            elementNames = @_ELEMENT_NAMES
            formatterRowPrefix = refPrefixes.formatter
            chars = @_CHARS
            underscoreChar = chars.underscore
            cells = []

            if @props.enableSelect
               selectorKey=
                  [
                     formatterRowPrefix
                     elementNames.selector
                  ].join underscoreChar

               cells.push `( <td key={selectorKey}
                                 style={this.styles.formatterSelectCell}>
                             </td> )`

            for field of firstRow.fields
               isRendered = true

               # Проверим параметры рендера и получим необходимые для формирования
               #  ячеек строки параметры.
               if renderParams? and renderParamColumns?
                  renderFieldParams = renderParamColumns[field]
                  isRendered = renderFieldParams? if isStrongRenderRule
                  columnRenderStyle =
                     if renderFieldParams? and renderFieldParams.hasOwnProperty('style')
                        renderStyle = renderFieldParams.style

                        # Сбросим ненужные стили размерности
                        for resetStyle in resetedStyle
                           _.unset(renderStyle, resetStyle)

                        renderStyle
                     else
                        @styles.formatterCommonCell

               if isRendered
                  cellKey =
                     [
                        formatterRowPrefix
                        field
                     ].join underscoreChar

                  cells.push `( <td key={cellKey}
                                    style={columnRenderStyle}></td> )`

            `(
               <tr>
                  {cells}
               </tr>
            )`

###* Компонент: Строка таблицы данных: часть компонента DataTable
*
* @props:
*     {Object} rowData              - данные по строке.
*     {Boolean} isEven              - флаг того, что это четная строка.
* {String, Number} selectedRecordID - идентификатор выбранной записи.
*     {String} matchExpression      - подстрока для поиска значений в ячейках.
*     {Object} columnRenderParams   - хэш с параметрами отображения колонок.
*     {Object} recordOperations     - хэш возможных операций над записью.
*     {Object} recordKeys           - хэш ключей элементов записи.
*     {Object} renderRuleKeys       - хэш ключей параметров рендера.
*     {Object} styleAddition        - параметры дополнительных стилей.
*     {Boolean} enableRowOptions    - флаг разрешения опции для строк.
*     {Boolean} enableSelect        - флаг разрешения выбора строк.
*     {Boolean} enableDragAndDrop   - флаг разрешения перемещения.
*     {Boolean} enableEdit          - флаг разрешения редактирования записей
*     {Boolean} enableDelete        - флаг разрешения удаления записей.
*     {Array} customRowOptions      - массив кастомных опций строки.
*     {Boolean} isSelected          - флаг выбранности данной строки (выбрана галочкой).
*     {Boolean} isHasStripFarming   - флаг наличия черезполосицы.
*{Function} getRecordReflectionParams- функция получения параметров сущности записи по
*                                     переданной последовательности-цепи связок.
*     {Function} getInstance        - функция получения экземпляра записи в различных форматах
*                                     (с отправкой запроса в API).
*     {Function} getModelParams     - функция получения параметров модели.
*     {Function} getEntityParams    - функция получения параметров сущности-связки для
*                                     формирования формы.
*     {Function} onRefreshRecord    - обработчик на обновление записи по строке.
*                                     отправляет новые обновленные данные записи.
*     {Function} onClick            - обработчик клика по строке. Возврат
*                                     {Object} record - параметры записи.
*                                     {React-element-ref} row - ссылка на строку.
*     {Function} onOptionClick      - обработчик клика по опции строки.
*     {Function} onSelect           - выбора строки.
* {Function} onDragAndDropTerminate - обработчик на окончание drag-and-drop строки.
* @state:
*     {Boolean} isHovered       - флаг, того что строка в фокусе курсора(наведен курсор).
*     {Boolean} isSelected      - флаг выбора строки (строка активна ).
*     {Boolean} isInDragAndDrop - флаг нахождения в перемещении.
*     {Array<React-element>} rowCells - набор элементов-ячеек.
* @functions: TODO: расписать:
*     getFieldValue
*     isFieldHidden
*     isSelected
*     refreshRecord
*     editRecord
*     deleteRecord
*     getInstanceFile
*     getEntityParams
*     getModelParams
###
DataTableRow = React.createClass

   # @const {String} - вывод маркера отстутствующего поля при форматировании значения в ячейке.
   _MISSING_FIELD_MARKER: 'поле не задано'

   # @const {Object} - параметры для вывода метаданных по значению поля.
   _SERVICE_INFO_PART_PARAMS:
      keys: keyMirror(
         name: null
         caption: null
         type: null
      )
      titles:
         name: 'Имя поля'
         caption: 'Название'
         type: 'Тип поля'
      order: [
         'name'
         'caption'
         'type'
      ]

   # @const {Object} - варианты расположения частей с сервисными метаданными по полю.
   _PART_POSITIONS: keyMirror(
      bottom: null
      top: null
   )

   # @const {String} - ключ для доступа к параметрам стиля ячейки таблицы.
   _RENDER_KEYS:
      cells: 'cells'
      columns: 'columns'
      alignRules: 'alignRules'
      alignRuleKeys:
         vertical: 'vertical'
         horizontal: 'horizontal'
      columnKeys:
         style: 'style'
         isHidden: 'isHidden'

   # @const {Object} - возможные типы отображаемого значения.
   _TYPES: keyMirror(
      datetime: null
      date: null
      string: null
      flaot: null
      integer: null
      boolean: null
      date: null
   )

   # @const {Object} - возможные значения булева типа.
   _BOOL_VALUES: keyMirror(
      true: null
      false: null
   )

   # @const {Object} - используемые символы.
   _CHARS:
      underscore: '_'

   # @const {String} - тип поля ввода - чекбокс.
   _CHECKBOX_INPUT: 'checkbox'

   # @const {String} - маркер отмеченности чекбокса.
   _CHECKED_MARKER: 'checked'

   mixins: [
      HelpersMixin
      AnimateMixin
      MoneyFormatterMixin
      AnimationsMixin.highlightBack
      BehaviorsMixin.dragAndDrop
   ]

   styles:
      common:
         cursor: 'pointer'
         color: _COLORS.hierarchy2
         whiteSpace: 'nowrap'
         backgroundColor: _COLORS.light
      selectedRow:
         borderLeftStyle: 'solid'
         borderLeftWidth: 3
         borderLeftColor: _COLORS.main
      hidden:
         display: 'none'
      draggableRow:
         cursor: '-webkit-grab'
      inDragRow:
         position: 'fixed'
         display: 'inline-block'
         cursor: 'move'
      selectCell:
         width: 25
         textAlign: 'center'
      serviceInfo:
         color: _COLORS.hierarchy3
         fontSize: 12
      serviceInfoPart:
         paddingRight: _COMMON_PADDING
      highlightBack:
         color: _COLORS.dark
         backgroundColor: _COLORS.highlight2
      evenRow:
         backgroundColor: _COLORS.hierarchy4
         color: _COLORS.hierarchy2
      rowTopBorder:
         borderTopWidth: 1
         borderTopStyle: 'solid'
         borderTopColor: _COLORS.hierarchy4

   getInitialState: ->
      isHovered: false
      isSelected: @props.isSelected
      isInDragAndDrop: false
      rowCells: @_getInitRowCells()

   componentWillReceiveProps: (nextProps) ->
      nextRowData = nextProps.rowData
      nextMatchExpression = nextProps.matchExpression

      if nextRowData? and !_.isEmpty(nextRowData)
         @setState rowCells: @_getRowCells(nextRowData, nextMatchExpression)

      if nextProps.isSelected isnt @props.isSelected
         @setState isSelected: nextProps.isSelected

   render: ->
      `(
         <tr style={this._getComputedRowStyle()}
             onClick={this._onRowClick}
             onMouseDown={this._onMouseDown}
             onMouseUp={this._onMouseUp}
             onMouseEnter={this._onMouseEnter}
             onMouseLeave={this._onMouseLeave}
           >
              {this._getSelectCell()}
              {this.state.rowCells}
              {this._getRowOptionsCell()}
         </tr>
       )`

   ###*
   * Функция получения значения поля для внешнего использования (например, карточка объекта).
   *
   * @param {String} fieldName - имя поля.
   * @param {Object} field     - параметры поля.
   * @return {String, React-element}
   ###
   getFieldValue: (fieldName, field) ->
      @_getProcessedValue(fieldName, field)

   ###*
   * Функция определения является ли поле скрываемым (заданным через параметры
   *  рендера колонок).
   *
   * @param {String} fieldName - имя поля.
   * @return {Boolean}
   ###
   isFieldHidden: (fieldName) ->
      renderKeys = @_RENDER_KEYS
      columnsKey = renderKeys.columns
      columnKeys = renderKeys.columnKeys
      isHiddenKey = columnKeys.isHidden
      columnRenderParams = @props.columnRenderParams

      if columnRenderParams? and _.has(columnRenderParams, columnsKey)
         columnsParams = columnRenderParams[columnsKey]

         if columnsParams?
            columnParams = columnsParams[fieldName]

            if columnParams? and _.has(columnParams, isHiddenKey)
               return columnParams[isHiddenKey]

      false

   ###*
   * Функция-предикат для определения является ли текущая строка выбранной.
   *
   * @return {Boolean}
   ###
   isSelected: ->
      @state.isSelected

   ###*
   * Функция обновления данных по записи. Вызывает обработчик обновления, который
   *  задается в корневом элементе.
   *
   * @param {Object} newRowData - новые данные по строке.
   * @return
   ###
   refreshRecord: (newRowData) ->
      if newRowData? and !_.isEmpty newRowData
         @props.onRefreshRecord(newRowData)

   ###*
   * Функция запуска операции редактирования записи, по которой построена строка
   *  таблицы. Вызывает эмуляцию запуска опции строки - редактирование.
   *
   * @return
   ###
   editRecord: ->
      @props.onOptionClick @props.rowData.key, @props.recordOperations.update

   ###*
   * Функция запуска операции удаления записи, по которой построена строка
   *  таблицы. Вызывает эмуляцию запуска опции строки - удаление.
   *
   * @return
   ###
   deleteRecord: ->
      @props.onOptionClick @props.rowData.key, @props.recordOperations.delete

   ###*
   * Функция получения экземпляра в виде файла. Вызывает обработчик показа
   *  экземпляра из flux
   *
   * @param {Array<Object>} relations - набор присоединямых связок к основным
   *                                    параметрам экземпляра.
   * @return
   ###
   getInstanceFile: (relations) ->
      @props.getInstance(@props.rowData.key, relations)

   ###*
   * Функция получения параметров сущности, находящуюся в связках
   *  сущности, по которой построена таблица.
   *
   * @param {Array<String>} reflectionsChain - массив связок.
   * @return {Object}
   ###
   getEntityParams: (reflectionsChain) ->
      @props.getEntityParams(reflectionsChain)

   ###*
   * Функция получения параметров модели сущности, находящуюся в связках
   *  сущности, по которой построена таблица.
   *
   * @param {Array<String>} reflectionsChain - массив связок.
   * @return {Object}
   ###
   getModelParams: (reflectionsChain) ->
      @props.getModelParams(reflectionsChain)

   ###*
   * Функция формирования ячейки выбора строки. Если задан свойство возможности
   *  выбора строк - сформируем ячейку с элементом для выбора.
   *
   * @return {React-element, undefined}
   ###
   _getSelectCell: ->
      if @props.enableSelect
         `(
            <td style={this.styles.selectCell}>
               <input className={this._UNDRAGGABLE_CLASS_NAME}
                      type={this._CHECKBOX_INPUT}
                      onClick={this._onClickSelect}
                      onChange={this._onChangeSelect}
                      checked={this.state.isSelected}/>
            </td>
          )`

   ###*
   * Функция ячейки с опциями строки. Если разрешены опции для строки - формирует
   *  ячейку опций.
   *
   * @return {React-element} - ячейка опций.
   ###
   _getRowOptionsCell: ->
      if @props.enableRowOptions
         `(<DataTableRowOptionsCell rowData={this.props.rowData}
                                    isShown={this.state.isHovered}
                                    enableEdit={this.props.enableEdit}
                                    enableDelete={this.props.enableDelete}
                                    customRowOptions={this.props.customRowOptions}
                                    rowKey={this.props.rowData.key}
                                    onOptionClick={this.props.onOptionClick} />)`

   ###*
   * Функция получения массива ячеек строки.
   *
   * @param {Object} rowData         - запись по строке.
   * @param {Object} matchExpression - поисковая подстрока.
   * @return {Array<React-element>} - массив ячеек.
   ###
   _getRowCells: (rowData, matchExpression) ->
      fields = _.cloneDeep(rowData.fields)
      columnRenderParams = @props.columnRenderParams
      matchExpression = @props.matchExpression unless matchExpression?
      cellKey = 0
      rowCells = []

      ###*
      * Функция получения набора параметров для произвольных полей(то есть тех,
      *  которые не заданы явно в полях, а только в параметрах рендера
      *  columnRenderParams -> columns)
      *
      * @param {Object} fields - набор полей.
      * @param {Object} columnRenderParams - параметры рендера.
      * @return {Array, null}
      ###
      getArbitraryFields = ((fields, columnRenderParams) ->
         if columnRenderParams? and !_.isEmpty columnRenderParams
            renderedColumns = columnRenderParams.columns

            if renderedColumns?
               fieldNames = _.keys(fields)

               arbitraryColumns =
                  _.omit(renderedColumns, fieldNames)

               if arbitraryColumns? and !_.isEmpty(arbitraryColumns)
                  virtualColumns = []

                  for colName, colParams of arbitraryColumns
                     virtualColumns.push(colName) if colParams.isVirtual

               # _.remove(columnNames, (colName) ->
               #    _.includes(fieldNames, colName)
               # )

                  if virtualColumns? and !_.isEmpty(virtualColumns)
                     virtualColumns
      ).bind(this)

      ###*
      * Функция создания экземпляра компонента - ячейки по переданным параметрам.
      *
      * @param {Object} params - параметры для элемента. Вид:
      *     {Object} rowData - ключ экземпляра.
      *     {Number} key - ключ экземпляра.
      *     {String} value - значение, выводимое в ячейке.
      *     {String} fieldName - значение, выводимое в ячейке.
      *     {Object, undefined} renderParams - параметры рендера ячейки.
      *     {String} matchExpression - поисковая подстрока.
      * @return {React-element} - ячейка строки таблицы.
      ###
      getRowCell = ((params) ->
         key = params.key
         value = params.value
         fieldName = params.fieldName
         matchExpression = params.matchExpression

         `(<DataTableCell key={key}
                          value={value}
                          matchExpression={matchExpression}
                          renderStyle={this._getCellRenderStyle(fieldName)} />)`
      ).bind(this)

      ###*
      * Функция подготовки параметров по ячейке таблицы и вызова функции
      *  формирования элемента ячейки и добавления ячейки в коллекцию.
      *
      * @param {Object} params - параметры для элемента. Вид:
      *     {String} fieldName    - имя поля.
      *     {Object} sourceFields - коллекция полей.
      *     {Boolean} isDeleteFromSource - флаг удаления из целевого набора полей.
      *     {Number} cellKey - уникальный ключ для элемента ячейки.
      *     {Object} columnRenderParams - параметры рендера колонки.
      *     {String} matchExpression - подстрока соответсвия.
      *     {Object} rowData данные по строке.
      * @return {React-element} - ячейка строки таблицы.
      ###
      processFieldToRow = ((params) ->
         fieldName = params.fieldName
         sourceFields =  params.sourceFields
         isDeleteFromSource =  params.isDeleteFromSource
         cellKey = params.cellKey
         columnRenderParams = params.columnRenderParams
         matchExpression = params.matchExpression
         rowData = params.rowData
         field = sourceFields[fieldName]
         cellRenderParams = @_getCellRenderParams(fieldName)

         if cellRenderParams.isRendered and (field? or cellRenderParams.isVirtual)
            processedValue = @_getProcessedValue(fieldName,
                                                 field,
                                                 columnRenderParams,
                                                 rowData)
            rowCells.push(
               getRowCell(
                  rowData: rowData
                  key: cellKey
                  value: processedValue
                  fieldName: fieldName
                  renderParams: cellRenderParams
                  matchExpression: matchExpression
               )
            )

            # Удаляем поле из дальнейшей обработки.
            delete fields[fieldName] if isDeleteFromSource

      ).bind(this)

      arbitraryFields = getArbitraryFields(fields, columnRenderParams)


      # TODO - этот блок нужен для повышения производительности, но не получилось
      #  пока чтобы с ним корректно работало
      # isOtherRowData = JSON.stringify(rowData) isnt JSON.stringify(@props.rowData)
      # isOtherMatchExpression = nextProps.matchExpression isnt @props.matchExpression
      # isNeedReadCellCollection = !rowCells? or
      #                            _.isEmpty(rowCells) or
      #                            isOtherRowData or
      #                            isOtherMatchExpression
      # if isNeedReadCellCollection

      # Если заданы параметры рендера колонок.
      if columnRenderParams?
         columnsOrder = columnRenderParams.columnsOrder
         @_supplementFieldsByRenderRules(fields, rowData, columnRenderParams)

         # Если заданы упорядочиваемые поля - продолжим.
         if columnsOrder?

            # Перебираем упорядочиваемые поля и добавляем их в начало массива
            #  ячеек строки таблицы.
            for orderedFieldName in columnsOrder
               processFieldToRow(
                  fieldName: orderedFieldName
                  sourceFields: fields
                  isDeleteFromSource: true
                  rowData: rowData
                  cellKey: ++cellKey
                  columnRenderParams: columnRenderParams
                  matchExpression: matchExpression
               )

      # Перебираем оставшиеся неупорядоченные поля строки.
      for fieldName, field of fields
         processFieldToRow(
            fieldName: fieldName
            sourceFields: fields
            rowData: rowData
            cellKey: ++cellKey
            columnRenderParams: columnRenderParams
            matchExpression: matchExpression
         )

      # Если остались произвольные поля - перебираем их.
      if arbitraryFields?
         for arbitraryField in arbitraryFields
               processFieldToRow(
                  fieldName: arbitraryField
                  sourceFields: fields
                  rowData: rowData
                  cellKey: ++cellKey
                  columnRenderParams: columnRenderParams
                  matchExpression: matchExpression
               )

      rowCells

   ###*
   * Функция получения простого выводимого значения, если не заданы специфичные
   *  обработчики значений. Выполняет для некоторых типов полей преобразования.
   *
   * @param {Object} fieldParams - параметры поля.
   * @param {String} fieldName - имя поля.
   * @return {String, React-element}
   ###
   _getSimpleValue: (fieldParams, fieldName)->
      return unless fieldParams?

      types = @_TYPES
      value = fieldParams.value
      type = fieldParams.type
      isMoney = @_isMoneyField(fieldName)

      return unless value?

      # Поле, хранящее денежный формат
      if isMoney
         @formatMoney(value, type)
      else
         switch type
            when types.datetime
               @convertToHumanDateTime(value)
            when types.boolean
               @_getFlagValue(value)
            else
               value
   ###*
   * Функция формирования элемента для отображения флага.
   *
   * @param {String, Boolean} value - значения поля-флага.
   * @return {String, React-element}
   ###
   _getFlagValue: (value) ->
      boolValues = @_BOOL_VALUES
      isStringTrue = _.isString(value) and (value is boolValues.true)
      isBooleanTrue = _.isBoolean(value) and value

      checked = @_CHECKED_MARKER if isStringTrue or isBooleanTrue

      `(
         <input type={this._CHECKBOX_INPUT}
                checked={checked}
                disabled={true}
              />
       )`

   ###*
   * Функция обработки значения в ячейке строки таблицы. Если заданы правила формирования
   *  значения в ячейке - прогоняет по этим правилам и возвращает значение.
   *
   * @param {String} fieldName - имя поля.
   * @param {Object} field - данные по значению поля.
   * @param {Object} columnRenderParams - параметры рендера.
   * @param {Object} rowData - данные по записи.
   * @return {String, Object, React-element} - отформатированный результат вывода в ячейке.
   ###
   _getProcessedValue: (fieldName, field, columnRenderParams, rowData) ->
      ###*
      * Функция получения набора элементов мета-информации.
      *
      * @param {Array} parts - набор секций метаданных, которых нужно обработать.
      * @param {Object} keys - ключи доступа к элементам коллекции метаданных.
      * @param {Object} titles - набор локализованных заголовков для различной метаинформации.
      * @param {Boolean} enableCaption - флаг разрешенного заголовка.
      * @param {Boolean} enableName - флаг разрешенного имени поля.
      * @param {Boolean} enableType - флаг разрешенного типа поля.
      * @return {Array} - набор элементов метаданных.
      ###
      getCellParts = (parts, keys, titles, field, enableCaption, enableName, enableType) ->

         ###*
         * Функция оборачивания метаинформации в контейнер.
         *
         * @param {String} content - значение метаданных.
         * @param {String} title - всплывающая подсказка.
         * @param {String} key - ключ элемента в коллекции.
         * @return {React-element}
         ###
         wrapContent = (content, title, key) ->
            `(
                <span key={key}
                      title={title}
                      style={this.styles.serviceInfoPart}  >
                  {content}
                </span>
             )`

         nameKey = keys.name
         captionKey = keys.caption
         typeKey = keys.type
         nameTitle = titles.name
         captionTitle = titles.caption
         typeTitle = titles.type

         result = []

         for orderedPart, idx in parts
            switch orderedPart
               when nameKey
                  if enableName
                     args = [
                        fieldName
                        nameTitle
                        idx
                     ]

                     result.push(
                        wrapContent.apply(this, args)
                     )
               when captionKey
                  if enableCaption and field?
                     args = [
                        field.caption
                        captionTitle
                        idx
                     ]

                     result.push(
                        wrapContent.apply(this, args)
                     )
               when typeKey
                  if enableType and field?
                     args = [
                        field.type
                        typeTitle
                        idx
                     ]

                     result.push(
                        wrapContent.apply(this, args)
                     )
         result

      rowData ||= @props.rowData
      columnRenderParams ||= @props.columnRenderParams
      processedValue = field.value if field?

      # Если заданы правила рендера значений - продолжим.
      if columnRenderParams?
         cellRules = columnRenderParams.cells
         columnRules = columnRenderParams.columns
         cellRule = cellRules[fieldName] if cellRules?
         columnRule = columnRules[fieldName] if columnRules?

         if columnRule? and !field?
            reflectionFieldParams =
               @_getReflectionFieldByRenderRules(fieldName, columnRule)

            if reflectionFieldParams
               field = reflectionFieldParams.field

         if cellRule?
            if field?
               cellCaption = field.caption
               cellType = field.type
               cellValue = field.value

            cellHandler = cellRule.handler
            cellFormat = cellRule.format
            enableCaption = cellRule.enableCaption
            enableType = cellRule.enableName
            enableName = cellRule.enableType

            # Если задан формат значения в ячейки - прогоним через него.
            if cellFormat? and !_.isEmpty cellFormat
               formatTemplate = cellFormat.template
               formatFields = cellFormat.fields
               formatArbitrary = cellFormat.arbitrary

               if formatTemplate?
                  processedValue =
                     if formatFields?
                        fieldValues = []

                        for fieldName in formatFields
                           fieldData = rowData.fields[fieldName]

                           val =  if fieldData?
                                     fieldData.value
                                  else
                                     @_MISSING_FIELD_MARKER
                           fieldValues.push val

                        if _.isEmpty(arbitraryValues)
                           cellValue
                        else
                           format(formatTemplate, fieldValues)
                     else if formatArbitrary?

                        ###* Функция для обработки параметра произвольного доступа.
                        *  Вызывается для каждого элемента в наборе произвольных
                        *  параметров выбора, а также рекурсивно для каждой из альтернатив, если
                        *  не было найдено значение.
                        *
                        * @param {Object} atbitraryParams - параметры произвольног выбора.
                        * @return {String, undefined}     - выбранное значение.
                        ###
                        processArbitrary = (arbitraryParams) ->
                           arbitraryChain = arbitraryParams.chain
                           arbitraryTemplate = arbitraryParams.template
                           arbitraryValue = _.get(rowData, arbitraryChain)
                           arbitraryAlternatives = arbitraryParams.alternatives

                           if arbitraryValue?
                              if arbitraryTemplate?
                                 format(arbitraryTemplate, arbitraryValue)
                              else
                                 arbitraryValue
                           else if arbitraryAlternatives? and !_.isEmpty(arbitraryAlternatives)
                              for alternative in arbitraryAlternatives
                                 altValue = processArbitrary(alternative)

                                 break if altValue?
                              altValue

                        arbitraryValues = formatArbitrary.map processArbitrary

                        if _.isEmpty(arbitraryValues)
                           cellValue
                        else
                           format(formatTemplate, arbitraryValues)


            # Если задан обработчик значения - прогоним значение через обработчик.
            if cellHandler? and _.isFunction cellHandler
               processedValue = cellHandler field, processedValue

            # Если заданы флаги вывода служебной информации - выводим по определенным правилам.
            if enableCaption or enableName or enableType
               defaultPartParams = @_SERVICE_INFO_PART_PARAMS
               defaultPartOrder = defaultPartParams.order[..]
               partsOrder = cellRule.partsOrder
               partsPosition = cellRule.partsPosition
               partsAlign = cellRule.partsAlign
               partPositions = @_PART_POSITIONS
               partKeys = defaultPartParams.keys
               partTitles = defaultPartParams.titles
               parts = []

               if partsOrder?
                  args = [
                     partsOrder
                     partKeys
                     partTitles
                     field
                     enableCaption
                     enableName
                     enableType
                  ]

                  parts = getCellParts.apply(this, args)

                  for orderedPart in partsOrder
                     defaultPartOrder.splice(
                        defaultPartOrder.indexOf(orderedPart), 1
                     )

               args = [
                  defaultPartOrder
                  partKeys
                  partTitles
                  field
                  enableCaption
                  enableName
                  enableType
               ]

               defaultParts = getCellParts.apply(this, args)

               parts = _.concat(parts, defaultParts)

               if parts? and parts.length
                  partsContainerStyle =
                     if partsAlign?
                        @computeStyles @styles.serviceInfo,
                                       textAlign: partsAlign
                     else
                        @styles.serviceInfo


                  serviceElement = `(<div style={partsContainerStyle}>
                                       {parts}
                                     </div>)`
                  valueElement = `(<span>{processedValue}</span>)`


                  if partsPosition? and partsPosition is partPositions.bottom
                     topElement = valueElement
                     bottomElement = serviceElement
                  else
                     topElement = serviceElement
                     bottomElement = valueElement


                  processedValue =
                     `(
                         <div>
                           {topElement}
                           {bottomElement}
                         </div>
                      )`
         else if columnRule? and columnRule.onRenderCell?
            processedValue = columnRule.onRenderCell(this, rowData)
         else
            processedValue = @_getSimpleValue field, fieldName
      else
         processedValue = @_getSimpleValue field, fieldName

      processedValue

   ###*
   * Метод получения кастомного стиля рендера ячейки таблицы.
   *
   * @param {String} columnName  - имя колонки.
   * @return {Object, undefined} - стиль рендера.
   ###
   _getCellRenderStyle: (columnName) ->
      renderKeys = @_RENDER_KEYS
      columnsKey = renderKeys.columns
      cellsKey = renderKeys.cells
      alignRulesKey = renderKeys.alignRules
      alignRuleKeys = renderKeys.alignRuleKeys
      columnKeys = renderKeys.columnKeys
      styleKey = columnKeys.style
      isHiddenKey = columnKeys.isHidden
      alignVerticalKey = alignRuleKeys.vertical
      alignHorizontalKey = alignRuleKeys.horizontal
      styleAddition = @props.styleAddition
      styleAdditionCell = styleAddition.cell if styleAddition?

      columnRenderParams = @props.columnRenderParams
      renderStyle = undefined

      if columnRenderParams?
         columns = if _.has(columnRenderParams, columnsKey)
                      columnRenderParams[columnsKey]
         alignRules = if _.has(columnRenderParams, alignRulesKey)
                         columnRenderParams[alignRulesKey]
         alignRulesCells = if alignRules? and _.has(alignRules, cellsKey)
                              alignRules[cellsKey]
      # Определим заданы ли правила выравнивания для ячеек.
      if alignRulesCells?
         horizontalAlign = alignRulesCells[alignHorizontalKey]
         verticalAlign = alignRulesCells[alignVerticalKey]

         alignStyle = @computeStyles horizontalAlign and { textAlign: horizontalAlign },
                                     verticalAlign and { verticalAlign: verticalAlign }

      unless _.isEmpty columns
         if _.has(columns, columnName)
            renderParams = columns[columnName]

            if _.isPlainObject(renderParams)

               if _.has(renderParams, styleKey)
                  renderStyle = renderParams[styleKey]

               if _.has(renderParams, isHiddenKey) and renderParams[isHiddenKey]
                  hiddenStyle = @styles.hidden

      @computeStyles alignStyle, renderStyle, styleAdditionCell, hiddenStyle

   ###*
   * Фукнция получения скомпанованного стиля строки.
   *
   * @return {Object} - скомпанованный стиль.
   ###
   _getComputedRowStyle: ->
      isNeedEvenBacklight = @_isNeedEvenBacklight()
      isNeedTopBorder = !isNeedEvenBacklight
      isSelectedRow = @props.rowData.key is @props.selectedRecordID
      isInDragAndDrop = @state.isInDragAndDrop
      isFailed = @props.rowData.isFailed
      styleAddition = @props.styleAddition

      if styleAddition? and !_.isEmpty styleAddition
         ordinaryStyleAddition = styleAddition.row
         selectedStyleAddition = styleAddition.rowSelected
         failedStyleAddition = styleAddition.rowFailed

      @computeStyles @styles.common,
                     ordinaryStyleAddition,
                     isNeedEvenBacklight and @styles.evenRow,
                     isNeedTopBorder and @styles.rowTopBorder,
                     isSelectedRow and @styles.selectedRow,
                     @props.isSelected and selectedStyleAddition,
                     isFailed and failedStyleAddition
                     @props.enableDragAndDrop and @styles.draggableRow,
                     isInDragAndDrop and @styles.inDragRow,
                     isInDragAndDrop and @_getDragAndDropPosition(),
                     @state.isHovered and @getAnimatedStyle('animate-highlight-back')

   ###*
   * Функция для получения начального массива ячеек таблицы. Если в свойствах задан
   *  набор полей со значениями - вызываем метод формирования ячеек, иначе возвращаем
   *  пустой массив.
   *
   * @return {Array}
   ###
   _getInitRowCells: ->
      propRowData = @props.rowData

      if propRowData? and !_.isEmpty(propRowData)
         @_getRowCells(propRowData)
      else
         []

   ###*
   * Функция проверки является ли переданное наименование колонки отображаемым.
   *  Проверяется входит ли наименование колонки в массив отображаемых наименований
   *  (если он задан).
   *
   * @param {String} columnName - наименование колонки.
   * @return {Object} - параметры рендера колонки. Вид:
   *                    {Boolean} isRendered    - колонка отрисовывается.
   *                    {Function} onRenderCell - фукнция рендера ячейки.
   *                    {Array} columnsOrder - массив имен упорядочиваемых имен полей.
   ###
   _getCellRenderParams: (columnName)->
      columnRenderParams = @props.columnRenderParams
      isRendered = true
      onRenderCell = null

      # Если задан массив имен отображаемых колонок, то проверим входит ли
      #  переданное имя колонки в данный массив.
      if columnRenderParams? and !_.isEmpty(columnRenderParams)
         columns = columnRenderParams.columns
         isStrongRenderRule = columnRenderParams.isStrongRenderRule
         renderedColumn = columns[columnName] if columns?

         if renderedColumn?
            onRenderCell = renderedColumn.onRenderCell
            isVirtual = renderedColumn.isVirtual

         if isStrongRenderRule
            isRendered =
               if _.isArray columns
                  columnName in columns
               else
                  renderedColumn? or _.has(columns, columnName)

      isRendered: isRendered
      isVirtual: isVirtual
      onRenderCell: onRenderCell

   ###*
   * Функция получения поля связки по параметрам правил рендера колонки.
   *
   * @param {String} fieldName        - имя поля.
   * @param {Object} columnRenderRule - правила рендера поля.
   * @param {Object} fields           - набор полей.
   * @return {Object} - параметры поля:
   *         {String} name  - наименование поля.
   *         {String} field - параметры поля.
   ###
   _getReflectionFieldByRenderRules: (fieldName, columnRenderRule, fields) ->
      recordKeys = @props.recordKeys
      getRecordReflectionParamsHandler =
      fieldsKey = recordKeys.fields
      reflectionsKey = recordKeys.reflections
      record = @props.rowData
      fields ||= record.fields
      underscoreChar = @_CHARS.underscore
      isRuleHasReflections = _.has(columnRenderRule, reflectionsKey)
      isAbsentDirectField = !_.has(fields, fieldName)

      # Если в правиле рендера задан параметр связок (reflections),
      #  то пробуем получить параметры поля из связок и
      #  добавить их в набор выводимых полей.
      if isRuleHasReflections
         reflectionsChain = columnRenderRule[reflectionsKey]
         reflectionParams =
            @props.getRecordReflectionParams(record, reflectionsChain)
         reflectionFields =
            if reflectionParams
               reflectionParams[fieldsKey]

         if reflectionFields?
            targetReflectionField = reflectionFields[fieldName]

            # Определяем имя нового поля в наборе - если такое имя уже
            #  присутсвует в наборе - генерируем уникальное имя по связкам.
            newFieldName =
               if isAbsentDirectField
                  fieldName
               else
                  nameElements = reflectionsChain
                  nameElements.push(fieldName)
                  nameElements.join(underscoreChar)

      if targetReflectionField?
         name: newFieldName
         field: targetReflectionField

   ###*
   * Обработчик на нажатие кнопки мыши на строке.
   *
   * @param {Event-obj} - объект события.
   * @return
   ###
   _onMouseDown: (event)->
      event.preventDefault();
      if @_isDraggableAction(event.target)

         @_dragAndDropInit event

         @setState isInDragAndDrop: true

   ###*
   * Обработчик на отпускание кнопки мыши на строке.
   *
   * @param {Event-obj} - объект события.
   * @return
   ###
   _onMouseUp: (event) ->

      if @_isDraggableAction(event.target)

         @_dragAndDropTerminate event

         @props.onDragAndDropTerminate(@props.rowData.key, @_getDragAndDropPosition())

         @setState isInDragAndDrop: false

   ###*
   * Обработчик на фокус курсора на строке. Запускает анимацию выделения
   *  строки, устанавливает флаг нахождения в фокусе курсора.
   *
   * @return
   ###
   _onMouseEnter: (event) ->
      styleRow = if @_isNeedEvenBacklight() then @styles.evenRow else @styles.common
      @_animationHighlightBackIn(styleRow)
      @setState isHovered: true

   ###*
   * Обработчик на уход фокуса курсора со строки. Запускает анимацию снятия выделения
   *  строки, устанавливает флаг нахождения вне фокуса курсора.
   *
   * @return
   ###
   _onMouseLeave: (event) ->
      styleRow = if @_isNeedEvenBacklight() then @styles.evenRow else @styles.common
      @_animationHighlightBackOut(styleRow)
      @setState isHovered: false

   ###*
   * Обработчик на клик по строке таблицы. Вызывает обработчик, переданный через props,
   *  передает данные по данной строке в обработчик
   *
   * @return
   ###
   _onRowClick: (event) ->
      @props.onClick @props.rowData, this

   ###*
   * Обработчик клика по селектору выбора записи. Останавливает проброс клика, для
   *  того, чтобы не вызывался обработчик клика по строке.
   *
   * @param {Event-object} event     - объект события.
   * @return
   ###
   _onClickSelect: (event) ->
      event.stopPropagation()

   ###*
   * Обработчик изменения селектора выбора записи.
   *
   * @param {Event-object} event     - объект события.
   * @return
   ###
   _onChangeSelect: (event) ->
      isChecked = event.currentTarget.checked

      @props.onSelect(event, @props.rowData.key, isChecked)
      @setState
         isSelected: isChecked

   ###*
   * Функция-предикат для определения является ли текущее поле - полем для
   *  хранения денежного формата.
   *
   * @param {String} fieldName - имя поля.
   * @return {Boolean}
   ###
   _isMoneyField: (fieldName) ->
      entityParams = @props.getEntityParams()

      if entityParams? and !_.isEmpty entityParams
         fieldParams = entityParams.fields

         if fieldParams? and !_.isEmpty fieldParams
            fieldFullParams = fieldParams[fieldName]

            return fieldFullParams? and fieldFullParams.isMoney

      false

   ###*
   * Функция-предикат для определия возможности перемещения данной строки.
   *
   * @param {DOM-Element} - DOM-узел.
   * @return {Boolean} - флаг возможности перемещения.
   ###
   _isDraggableAction: (target) ->
      @props.enableDragAndDrop and target.className isnt @_UNDRAGGABLE_CLASS_NAME

   ###*
   * Функция-предикат для определения необходимости выделения четной строки
   *  цветом.
   *
   * @return {Boolean}
   ###
   _isNeedEvenBacklight: ->
      @props.isHasStripFarming and @props.isEven

   ###*
   * Функция для дополнения параметров выводимых полей через параметры, заданные
   *  правилами отображения колонок(производит добавление в параметры полей поля
   *  связки, если таковые были найдены в параметрах связок записи).
   *
   * @param {Object} fields      - набор полей записи (целевой выходной параметр).
   * @param {Object} renderRules - правила отображения.
   * @return
   ###
   _supplementFieldsByRenderRules: (fields, record, renderRules) ->
      columnsRenderRule = renderRules.columns
      renderRuleKeys = @props.renderRuleKeys

      if columnsRenderRule? and !_.isEmpty columnsRenderRule
         # Переберем все колонки заданные в правилах рендера колонок -
         #  для выявления специально настраиваемых колонок
         #  (колонка для вывода поля связки).
         for fieldName, ruleParams of columnsRenderRule
            isHasOnRenderHandler = _.has(ruleParams, renderRuleKeys.onRenderCell)
            reflectionFieldParams =
               @_getReflectionFieldByRenderRules(fieldName, ruleParams, fields)

            if reflectionFieldParams?
               fields[reflectionFieldParams.name] = reflectionFieldParams.field
            else if isHasOnRenderHandler
               fields[fieldName] =
                  caption: ruleParams.caption || fieldName


###* Компонент: Ячейка строка таблицы данных: часть компонента DataTable
*
* @props:
*     {String} value           - значение, выводимое в ячейке.
*     {String} matchExpression - подстрока для поиска значений в ячейке
*     {Object} renderStyle     - дополнительный стиль рендеринга ячейки.
###
DataTableCell = React.createClass

   mixins: [HelpersMixin]

   styles:
      common:
         textOverflow: 'ellipsis'
         overflow: 'hidden'
         width: '100%'
         minHeight: 20
         padding: [_CP * 2, 'px ', _CP, 'px'].join ''

   render: ->
      computedStyle = @computeStyles @styles.common,
                                     @props.renderStyle
      `(
         <td style={computedStyle}
             title={this._getTitle()} >
             {this._getCellContent()}
         </td>
       )`

   ###*
   * Функция получения содержимого ячейки. Если задан произвольный рендер - возвращает
   *  результат выполнения произвольного рендера.
   *
   * @return {React-element} - содержимое ячейки.
   ###
   _getCellContent: ->
      matchExpression = @props.matchExpression

      `(
         <AllocationContent content={this.props.value}
                            expression={matchExpression} />
       )`

   ###*
   * Функция получения выводимой подсказки. Если для ячейки задан произвольный
   *  рендер - подсказка не формируется, иначе возвращается значение по данной
   *  ячейке(если значение имеет строковый тип).
   *
   * @return {String, undefined}
   ###
   _getTitle: ->
      cellValue = @props.value
      if !@props.onRender? and _.isString cellValue
         cellValue

###* Компонент: Ячейка опций строки таблицы данных: часть компонента DataTable.
*  Компонент выводит доступные операции над записью таблицы.
*
* @props:
*     {Boolean} isShown        - флаг показа опций.
*     {Boolean} enableEdit     - флаг разрешения редактирования записей
*     {Boolean} enableDelete   - флаг разрешения удаления записей.
*     {Array} customRowOptions - массив кастомных опций строки.
*     {String} rowKey          - ключ строки.
*     {Object} rowData         - хэш данных по строке.
*     {Function} onOptionClick - обработчик клика по опции.
* @state:
*     {Number} optionsOffset   - значение смещения опций (для того, чтобы они
*                                показывались над другими ячейками таблицы),
*                                зависит от ширины контейнера с опциями.
###
DataTableRowOptionsCell = React.createClass

   # @const {Object} - параметры стандартных опций дейтсвий над строкой.
   _STANDARD_OPTION_PARAMS:
      edit:
         icon: 'pencil'
         title: 'редактировать'
         value: 'update'
      delete:
         icon: 'remove'
         title: 'удалить'
         value: 'delete'

   mixins: [HelpersMixin]

   styles:
      common:
         width: '0%'
         overflow: 'hidden'
      cellWithShownOption:
         overflow: ''
      optionsContainer:
         opacity: 0.7
         visibility: 'hidden'
         position: 'relative'
      optionsWrapperShown:
         visibility: ''
      optionButton:
         fontSize: 20
         cursor: 'pointer'
         marginRight: _COMMON_PADDING
         padding: ['2px ', _CP, 'px'].join('')
      optionButtonRemove:
         color: _COLORS.alert

   getInitialState: ->
      optionsOffset: 0
      isOffsetCalculated: false

   componentWillReceiveProps: (nextProps) ->
      @setState isOffsetCalculated: false
      #@_setOperationCellOffest()

   render: ->

      `(
         <td style={this._getOptionsCellStyle()}>
            <span ref='optionsContainer'
                  style={this._getContainerStyle()}>
               {this._getCustomRowOptions()}
               {this._getStandardOption()}
               {this._getStandardOption(true)}
            </span>
         </td>
      )`

   ###*
   * Функция получения кнопки стандартной операции над строкой (обновление, удаление)
   *
   * @param {Boolean} isDelete - флаг кноки для удаления
   *                             (иначе - кнопка для редактирования)
   * @return {React-element, undefined}
   ###
   _getStandardOption: (isDelete) ->
      standardOptionParams = @_STANDARD_OPTION_PARAMS
      enableDelete = @props.enableDelete
      enableEdit = @props.enableEdit

      if isDelete
         options = standardOptionParams.delete
         secondStyle = @styles.optionButtonRemove
      else
         options = standardOptionParams.edit

      return if (isDelete and !enableDelete) or (!isDelete and !enableEdit)

      styleAddition = @computeStyles @styles.optionButton, secondStyle

      `(
         <Button styleAddition={styleAddition}
                 {...options}
                 onClick={this._onClickOption} />
       )`

   componentDidUpdate: (prevProps, prevState) ->
      @_setOperationCellOffest()

   componentDidMount: ->
      @_setOperationCellOffest()

   ###*
   * Функция получения смещения опций строки в зависимости от ширины контейнера
   *  с опциями. Делает установку смещения, если смещение не было получено ранее.
   *
   * @return
   ###
   _setOperationCellOffest: ->
      #stateOptionsOffset = @state.optionsOffset
      unless @state.isOffsetCalculated
         optionsContainerClientRect =
            @refs.optionsContainer.getBoundingClientRect()

         @setState
            optionsOffset: optionsContainerClientRect.width
            isOffsetCalculated: true

   ###*
   * Функция получения скомпанованного стиля для конейнера опций.
   *
   * @return {Object} - скомпанованные стили.
   ###
   _getOptionsCellStyle: ->
      @computeStyles @styles.common,
                     @props.isShown and @styles.cellWithShownOption

   ###*
   * Функция получения скомпанованного стиля для конейнера опций. Добавляет
   *  смещение в зависимости от ширины контейнера.
   *
   * @return {Object} - скомпанованные стили.
   ###
   _getContainerStyle: ->
      @computeStyles @styles.optionsContainer,
                     { marginLeft: -@state.optionsOffset},
                     @props.isShown and @styles.optionsWrapperShown

   ###*
   * Функция получения скомпанованного стиля для опции удаления.
   *
   * @return {Object} - скомпанованный стиль.
   ###
   _getRemoveOptionStyle: ->
      @computeStyles @styles.optionButton,
                     @styles.optionButtonRemove

   ###*
   * Функция формирования массива кастомных опций. Перебирает массив
   *  параметров опций и формирует массив кнопок-опций компонентов.
   *
   * @return {Array<React-element>} - массив кастомных опций.
   ###
   _getCustomRowOptions: ->
      customOptions = @props.customRowOptions
      customOptionButtons = undefined
      cellOptionsComponent = this

      if customOptions? and customOptions.length

         customOptionButtons = customOptions.map (value, index) ->
            title = cellOptionsComponent._getCustomRowOptionTitle value

            icon = cellOptionsComponent._getCustomRowOptionIcon value

            `(
               <Button key={index}
                       icon={icon}
                       title={title}
                       styleAddition={cellOptionsComponent.styles.optionButton}
                       value={value.name}
                       onClick={cellOptionsComponent._onClickOption} />
             )`

      customOptionButtons

   ###*
   * Функция преобразования целевого поля в данных по записи в логический формат(
   *  TODO: пока просто по-тупому есть - true, нет и все что дает false - false).
   *  Функция нужна для получения нужной иконки и надписи для пользовательской опции-
   *  переключателя.
   *
   * @param {Object} option - хэш с параметрами опции.
   * @return {Boolean} - результат преобразования значения поля в логический формат.
   ###
   _getCustomRowOptionsCondition: (option) ->
      conditionField = option.fieldForCondition
      !!@props.rowData.fields[conditionField].value

   ###*
   * Функция получения всплывающей подсказки пользовательской опции. Проверяет является ли параметр
   *  заголовка массивом. Если является - берет значение из массива согласно состоянию
   *  целевого поля, иначе берет просто строку.
   *
   * @param {Object} option - хэш с параметрами опции.
   * @return {String}       - всплывающая подсказка для опции.
   ###
   _getCustomRowOptionTitle: (option) ->
      title = option.title

      if title instanceof Array
         titleIndex = if @_getCustomRowOptionsCondition(option) then 0 else 1

         title = title[titleIndex]
      else
         title

   ###*
   * Функция получения имени иконки пользовательской опции. Проверяет является ли параметр
   *  заголовка массивом. Если является - берет значение из массива согласно состоянию
   *  целевого поля, иначе берет просто строку.
   *
   * @param {Object} option - хэш с параметрами опции.
   * @return {String}       - имя иконки для опции.
   ###
   _getCustomRowOptionIcon: (option) ->
      icon = option.icon

      if icon instanceof Array
         titleIndex = if @_getCustomRowOptionsCondition(option) then 0 else 1

         icon = icon[titleIndex]
      else
         icon

   ###*
   * Обработчик клика по кнопке опции
   *
   * @param {Object} value - значение, возвращаемое по клику на опция.
   * @param {Event-object} event - объект события.
   * @return
   ###
   _onClickOption: (value, event) ->
      event.stopPropagation()
      onOptionClickHandler = @props.onOptionClick

      onOptionClickHandler(@props.rowKey, value) if onOptionClickHandler?


###* Компонент: Хлебный навигатор по цепи операций над записями.
*
* @state:
*     {Array<Object>} chain - цепь элементов, управляемая через публичные
*                             функции addElement, removeElement.
* @functions:
*     addElement({Object} element), где element - параметры элемента. Вид:
*
###
DataTableOperationsOrganizer = React.createClass

   # @const {String} - символ-разделитель между элементами хлебного навигатора.
   _NAVIGATOR_SPLITTER_CHAR: '→'

   # @const {Object} - параметры для кнопки завершения всех операций для хлебного
   #                   навигатора.
   _NAVIGATOR_HOME_BUTTON_PARAMS:
      isClear: true
      title: 'завершить все операции'

   styles:
      common:
         position: 'fixed'
         bottom: 0
         left: 0
         width: '100%'
         backgroundColor: HelpersMixin.convertHex(_COLORS.mainDark, 60)
         zIndex: 1000
      hidden:
         display: 'none'
      navigatorCommon:
         display: 'flex'
         alignItems: 'center'
         minHeight: 50
         padding: _COMMON_PADDING
      navigatorItem:
         color: _COLORS.light
         fontSize: 20
      navigatorClearButton:
         color: _COLORS.light
         fontSize: 20

   getInitialState: ->
      chain: []

   render: ->
      `(
         <footer style={this._getStyle()}>
            <BreadNavigator items={this.state.chain}
                            enableHome={true}
                            homeParams={this._NAVIGATOR_HOME_BUTTON_PARAMS}
                            splitter={this._NAVIGATOR_SPLITTER_CHAR}
                            styleAddition={this._getNavigatorStyleAddition()}
                            onClickItem={this._onClickItem}
                            onClickHome={this._onClickHome}
                          />
         </footer>
      )`

   ###*
   * Функция добавления элемента в органайзер. Проверяет добавлен ли уже элемент
   *  с переданным идентификатором, если да - заменяет старый элемент на переданный.
   *  Иначе добавляет новый элемент в набор элементов.
   *
   * @param {Object} newElement - параметры нового элемента.
   * @return
   ###
   addElement: (newElement) ->
      if newElement?
         chain = @state.chain
         newElementIdentifier = newElement.identifier
         existIndex = if newElementIdentifier?
                         @_getElementIndexByIdentifier newElementIdentifier

         if existIndex?
            chain[existIndex] = newElement
         else
            chain.push newElement

         @setState chain: chain

   ###*
   * Функция удаления элемента из набора по идентификатору. Если элемент с данным
   *  идентификатором не был найдена - ничего не делает.
   *
   * @param {String} identifier - идентификатор удаляемого элемента.
   * @return
   ###
   removeElement: (identifier) ->
      chain = @state.chain
      deletedIndex = @_getElementIndexByIdentifier identifier

      if deletedIndex?
         chain.splice deletedIndex, 1

         @setState chain: chain

   ###*
   * Функция получения стиля для контейнера органайзера. Если в цепи органайзера
   *  задано более 1 элемента - показывает контейнер с органайзером, иначе оставляет
   *  скрытым. Функция реализует логику скрытия/показа области органайзера.
   *
   * @return {Object}
   ###
   _getStyle: ->
      chain = @state.chain
      isElementsInCollection = if chain?
                                  chain.length >= 2
                               else
                                  false

      if isElementsInCollection
         @styles.common
      else
         @styles.hidden

   ###*
   * Функция формирования параметров доп. стилей для элементов хлебного навигатора.
   *
   * @return {Object} - набор доп. стилей для навигатора.
   ###
   _getNavigatorStyleAddition: ->
      item: @styles.navigatorItem,
      common: @styles.navigatorCommon
      clearButton: @styles.navigatorClearButton

   ###*
   * Функция получения индекса элемента в цепи по идентификатору.
   *
   * @param {String} identifier - идентификатор искомого элемента.
   * @return {Number}
   ###
   _getElementIndexByIdentifier: (identifier) ->
      chain = @state.chain

      for element, idx in chain
         if identifier is element.identifier
            return idx

   ###*
   * Обработчик клика по элементу в хлебном навигаторе. Реализует поведение закрытия
   *  контейнеров всех крайних компонентов, заданных в цепи,
   *  вплоть до переданного элемента.
   *
   * @param {Object} targetItem - параметры элемента, по которому произведен клик.
   ###
   _onClickItem: (targetItem) ->
      targetItemIdentifier = targetItem.identifier
      chain = @state.chain

      if targetItemIdentifier?
         @_closeChainElements(chain, targetItemIdentifier)

   ###*
   * Обработчик клика на кнопку перехода в корень хлебного навигатора. Закрывает
   *  все контейнеры элементов в цепи органайзера.
   *
   * @return
   ###
   _onClickHome: ->
      chain = @state.chain
      @_closeChainElements(chain)


   ###*
   * Функция закрытия контейнеров элементов в цепи.
   *
   * @param {Array<Object>} chain   - цепь элементов.
   * @param {String} stopIdentifier - идентификатор до которого должны быть
   *                                  закрыты все контейнеры элементов цепи.
   *                                  Если параметр не задан будут закрыты все
   *                                  контейнеры.
   * @return {Number} - индекс элемента в цепи на котором было остановлено
   *                    закрытие контейнеров.
   ###
   _closeChainElements: (chain, stopIdentifier) ->
      idx = chain.length - 1

      while idx >= 0
         chainElement = chain[idx]
         chainElementIdentifier = chainElement.identifier

         if chainElementIdentifier is stopIdentifier
            return idx
         else
            chainElement.component.context.container.close()

         idx--

module.exports = DataTable